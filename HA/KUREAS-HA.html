<!DOCTYPE html>
<!--
    KUREAS-HE - Hazard Analysis Knowledge Management
    
    Developed by Curtis Lee Smith and Claude.ai
    
    MIT License
    
    Copyright (c) 2024-2025 Curtis Lee Smith
    
    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:
    
    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.
    
    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
    SOFTWARE.
    
    https://opensource.org/license/mit
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KUREAS-HA - Hazard Analysis Knowledge Management</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
	 <link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAEzUlEQVR4AcRXSUxUWRQ9r4oZmZpBpGkGATdudKUrh5hoXLgEosbExKEdAJV2ionzEDXRxKgxNmgjLETAGIdoTEx04caliImhAYONAgKFNHSoiaq+99f313/1XxVVHZP+4f733rn3vnv+rffvv9jwP18agcrKSv+PliraUyXmOPzsGgGetLW1gaW1uRl/HDmCxj170FhXBx6bz59HW2urpmebiEJ2zRcuoKGmBg27d+P3Xbs04XXTmTPGHhyTxSDAC/j9cH/+jD+3bkXnsmXoXL4c71auxJdr1+BzuTSTiLeZGTieP8c73bdzxQrNv2vVKvQSIe/4uMVdJsBqIgGfD5IwxrpI4vXC8ewZerdtg2tgIGhpsyF18WJUUGbTliwJ4vrMSkBXxDTowXu2b4eLMmj4UvD0pUux4M4dzFm0yIDNEysBIcz6wDxSBjj406fg4O7BwYA93yl4Jv0UC5qakLJwISNKsRJQmqlBPwUfe/IE3XRm3ENDQSMKnrV6Ncpv30ZSRUUQV8wkAn4yEELOgD/M0/s8How9fKg9uXdkhDz1Pwr+07p1KG9oQFJpqQ6GHyQC4c1kjRb8wQP07tgBT0jw3MpKlN+4gcTCQtkpzEoiIIQAZ8Fsy/kwZ4HT7rh/H730fntGRw1TQU+et2kT5l+9ioR58wx8tolEYDZjP6V9lApWz86d8I6NBc0peD69fvMvXUJ8bm4Qj2JmISCEnAV+ei0LHPzePe3Jvd++GVsLux0FtbUopuoXl51t4NFOLARUjn63G19bWtBDafdOTARNiGze5s0oPnUKcRkZQTyGmZUAbSoEP7O+C70Fw1RI+vbuxczkpA7qA+n+fv0azo8fdSD2wUpAsYdvehp8+BQqOLu78enkSfltUBmGwaIiEMZXg/mMOB4/xtDNm+CfSgNjuMVEwJaUhNLLl1HR2Ah7aqoRhrPzhfBx+hLyF9VQRDGJmgAHL6G+oIC+8TlVVZi7ZYu0vYc+tf1Hj2L6wwcJn21hJWA+gLq3FvzcOeRT5RMJCbCnpaGADmXo5/Wft2/x6fRpeB0ORHtZCSg88zZuxFz64NgSEw1tUkkJiujwxefkGBhPRjs6MNzUFPV5UBMIyYJITgao4HAAQ8gmgzqegn37IOLiDJir5cDFi5h49Qp+bmwMjXqiJqC2taCckXzKTNbatZLOMzyM/mPH4Orrk3DVwqYCLRgVHGEBA0B8Xh6K6PAll5UFAP0++eYN/qJMzJgrp64zD9ERMHso5tzz/Xz4MOwpKZJ2pKUFX+/ehY9KuaQwLX4IAT4DufRq5qxfD9DZgH75nE4MnD2LKcoGKIs6LA1qArSJEHLSueJJniELe3o6Cg8exBzqgM0kuEPuP34czv5+qPZQE8B/u5LLy/ELnYe4zExpg4mXLzF45Qp8U1MSzgslASHUPQE7RBRqTLLWrAkULHo1uUsCYSxDt25hjNo4SoO0hYWAPTNT26D4xAkUsVCxyaYmkyug5BlmYaOaUVhfj7Lr17U+gYsVS+GhQ2AioW4GgSo6RCwbqLWqpf9w9nd14cD79zhA46/UXldTNWR9NLKBGpe6Fy9QT6V5f2cnWH6jec2jR6iqrgbv8Z2IRqC9vV1I0tEh2gj7LpKO8FjWkWyZxL8AAAD//4MEZNkAAAAGSURBVAMAE0k4X2fO1c4AAAAASUVORK5CYII=" type="image/png">
    <style>
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        .line-clamp-2 {
            display: -webkit-box;
            -webkit-line-clamp: 2;
            -webkit-box-orient: vertical;
            overflow: hidden;
        }
        .resizer-horizontal {
            background: #cbd5e1;
            cursor: row-resize;
            height: 4px;
        }
        .resizer-horizontal:hover {
            background: #94a3b8;
        }
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        .modal-content {
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            max-width: 500px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
        }
        .rich-text-editor {
            border: 1px solid #d1d5db;
            min-height: 400px;
            padding: 12px;
        }
        .rich-text-editor h1 {
            font-size: 16pt;
            font-weight: bold;
            margin: 0.67em 0;
        }
        .rich-text-editor h2 {
            font-size: 1.5em;
            font-weight: bold;
            margin: 0.75em 0;
        }
        .rich-text-editor h3 {
            font-size: 1.17em;
            font-weight: bold;
            margin: 0.83em 0;
        }
        .rich-text-editor p {
            margin: 1em 0;
        }
        .rich-text-editor ul {
            list-style-type: disc;
            margin: 1em 0;
            padding-left: 40px;
        }
        .rich-text-editor ol {
            list-style-type: decimal;
            margin: 1em 0;
            padding-left: 40px;
        }
        .rich-text-editor li {
            margin: 0.5em 0;
        }
        .rich-text-editor strong {
            font-weight: bold;
        }
        .rich-text-editor em {
            font-style: italic;
        }
        .rich-text-editor u {
            text-decoration: underline;
        }
        .hazard-editor-modal {
            max-width: 900px;
            width: 90%;
            max-height: 90vh;
            min-height: 70vh;
            height: 85vh;
            overflow-y: auto;
        }
        .rich-text-toolbar {
            border-bottom: 1px solid #d1d5db;
            padding: 8px;
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
        }
        .toolbar-button {
            padding: 6px 12px;
            border: 1px solid #d1d5db;
            background: white;
            cursor: pointer;
            border-radius: 4px;
            font-size: 14px;
        }
        .toolbar-button:hover {
            background: #f3f4f6;
        }
        .toolbar-button.active {
            background: #e5e7eb;
        }
        .tree-node {
            cursor: pointer;
            user-select: none;
            padding: 2px 8px;
        }
        .tree-node:hover {
            background-color: #f3f4f6;
        }
        .hazard-button {
            padding: 2px 12px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
            border: 1px solid #d1d5db;
            font-weight: 500;
        }
        .hazard-button.unanalyzed {
            background-color: #3b82f6;
            color: white;
        }
        .hazard-button.screened {
            background-color: #6b7280;
            color: white;
        }
        .hazard-button.included {
            background-color: #10b981;
            color: white;
        }
        .operating-state-box {
            display: inline-block;
            height: 30px;
            border: 1px solid #333;
            text-align: center;
            line-height: 30px;
            font-size: 11px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback } = React;

        // Settings Icon Component
        const SettingsIcon = () => (
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"></path>
                <circle cx="12" cy="12" r="3"></circle>
            </svg>
        );

        // Default Facility Operating States
        const DEFAULT_OPERATING_STATES = [
            {
                id: 'FOS-1',
                name: 'Zero Power Operations',
                description: 'Test operations including operator training',
                color: '#93c5fd'
            },
            {
                id: 'FOS-2',
                name: 'Shutdown',
                description: 'Non-testing period while reactor is in safe shutdown',
                color: '#fca5a5'
            },
            {
                id: 'FOS-3',
                name: 'Refueling',
                description: 'Loading fuel and core elements to enable test operations',
                color: '#fde047'
            },
            {
                id: 'FOS-4',
                name: 'Defueling',
                description: 'End of testing and removing all used fuel to long-term storage',
                color: '#c4b5fd'
            }
        ];

        // NUREG-2169 Fire Ignition Frequencies (Table 4-4)
        // Each item has: bin, location, ignitionSource, mean (frequency /yr), ef (lognormal error factor)
        const NUREG2169_FIRE_IGNITION_DATA = [
            { bin: '1', location: 'Battery room', ignitionSource: 'Batteries (all plants all modes)', mean: 1.96e-04, ef: 25.92 },
            { bin: '2', location: 'Containment (PWR)', ignitionSource: 'Reactor coolant pump (PWR plants at power)', mean: 1.37e-03, ef: 9.94 },
            { bin: '3', location: 'Containment (PWR)', ignitionSource: 'Transients and hotwork (at power) (PWR plants at power)', mean: 4.21e-04, ef: 19.96 },
            { bin: '4', location: 'Control room', ignitionSource: 'Main control board (all plants all modes)', mean: 4.91e-03, ef: 32.45 },
            { bin: '5', location: 'Control / auxiliary / reactor building', ignitionSource: 'Cable fires caused by welding and cutting (all plants at power)', mean: 7.83e-04, ef: 23.02 },
            { bin: '6', location: 'Control / auxiliary / reactor building', ignitionSource: 'Transient fires caused by welding and cutting (all plants at power)', mean: 4.44e-03, ef: 26.24 },
            { bin: '7', location: 'Diesel generator room', ignitionSource: 'Transients (all plants at power)', mean: 3.33e-03, ef: 5.85 },
            { bin: '8', location: 'Plant-Wide Components', ignitionSource: 'Diesel generators (all plants all modes)', mean: 7.81e-03, ef: 3.39 },
            { bin: '9', location: 'Plant-Wide Components', ignitionSource: 'Air compressors (all plants all modes)', mean: 4.69e-03, ef: 6.29 },
            { bin: '10', location: 'Plant-Wide Components', ignitionSource: 'Battery chargers (all plants all modes)', mean: 1.12e-03, ef: 8.67 },
            { bin: '11', location: 'Plant-Wide Components', ignitionSource: 'Cable fires caused by welding and cutting (all plants at power)', mean: 2.77e-04, ef: 20.11 },
            { bin: '12', location: 'Plant-Wide Components', ignitionSource: 'Cable run (self-ignited cable fires) (all plants all modes)', mean: 7.02e-04, ef: 6.66 },
            { bin: '13', location: 'Plant-Wide Components', ignitionSource: 'Dryers (all plants all modes)', mean: 3.66e-03, ef: 6.32 },
            { bin: '14', location: 'Plant-Wide Components', ignitionSource: 'Electric motors (all plants all modes)', mean: 5.43e-03, ef: 4.67 },
            { bin: '15', location: 'Plant-Wide Components', ignitionSource: 'Electrical cabinets (non-HEAF) (all plants all modes)', mean: 3.00e-02, ef: 6.21 },
            { bin: '16.a', location: 'Plant-Wide Components', ignitionSource: 'HEAF for low-voltage electrical cabinets (480-1000 V) (all plants all modes)', mean: 1.52e-04, ef: 29.65 },
            { bin: '16.b', location: 'Plant-Wide Components', ignitionSource: 'HEAF for medium-voltage electrical cabinets (>1000 V) (all plants all modes)', mean: 2.13e-03, ef: 4.40 },
            { bin: '16.1', location: 'Plant-Wide Components', ignitionSource: 'HEAF for segmented bus ducts (all plants all modes)', mean: 1.10e-03, ef: 6.60 },
            { bin: '16.2', location: 'Plant-Wide Components', ignitionSource: 'HEAF for iso-phase bus ducts (all plants all modes)', mean: 5.91e-04, ef: 10.4 },
            { bin: '17', location: 'Plant-Wide Components', ignitionSource: 'Hydrogen tanks (all plants all modes)', mean: 4.93e-03, ef: 26.58 },
            { bin: '18', location: 'Plant-Wide Components', ignitionSource: 'Junction boxes (all plants all modes)', mean: 3.61e-03, ef: 6.98 },
            { bin: '19', location: 'Plant-Wide Components', ignitionSource: 'Miscellaneous hydrogen fires (all plants all modes)', mean: 4.82e-03, ef: 5.68 },
            { bin: '20', location: 'Plant-Wide Components', ignitionSource: 'Off-gas and H2 recombiner (BWR plants at power)', mean: 5.81e-03, ef: 4.82 },
            { bin: '21', location: 'Plant-Wide Components', ignitionSource: 'Pumps (all plants all modes)', mean: 2.72e-02, ef: 2.06 },
            { bin: '22', location: 'Plant-Wide Components', ignitionSource: 'RPS MG sets (all plants at power)', mean: 2.31e-03, ef: 15.57 },
            { bin: '23', location: 'Plant-Wide Components', ignitionSource: 'Transformers (all plants all modes)', mean: 9.56e-03, ef: 5.77 },
            { bin: '24', location: 'Plant-Wide Components', ignitionSource: 'Transient fires caused by welding and cutting (all plants at power)', mean: 4.79e-03, ef: 4.42 },
            { bin: '25', location: 'Plant-Wide Components', ignitionSource: 'Transients (all plants at power)', mean: 8.54e-03, ef: 3.12 },
            { bin: '26', location: 'Plant-Wide Components', ignitionSource: 'Ventilation subsystems (all plants all modes)', mean: 1.64e-02, ef: 4.03 },
            { bin: '27', location: 'Transformer yard', ignitionSource: 'Transformer - Catastrophic (all plants at power)', mean: 6.61e-03, ef: 4.49 },
            { bin: '28', location: 'Transformer yard', ignitionSource: 'Transformer - Non Catastrophic (all plants at power)', mean: 6.53e-03, ef: 4.20 },
            { bin: '29', location: 'Transformer yard', ignitionSource: 'Yard transformers (others) (all plants at power)', mean: 3.69e-03, ef: 11.60 },
            { bin: '30', location: 'Turbine building', ignitionSource: 'Boiler (all plants at power)', mean: 1.09e-03, ef: 8.20 },
            { bin: '31', location: 'Turbine building', ignitionSource: 'Cable fires caused by welding and cutting (all plants all modes)', mean: 3.47e-04, ef: 16.72 },
            { bin: '32', location: 'Turbine building', ignitionSource: 'Main feedwater pumps (all plants at power)', mean: 4.38e-03, ef: 5.31 },
            { bin: '33', location: 'Turbine building', ignitionSource: 'Turbine generator excitor (all plants at power)', mean: 8.36e-04, ef: 10.88 },
            { bin: '34', location: 'Turbine building', ignitionSource: 'Turbine generator hydrogen (all plants at power)', mean: 4.12e-03, ef: 7.03 },
            { bin: '35', location: 'Turbine building', ignitionSource: 'Turbine generator oil (all plants at power)', mean: 5.49e-03, ef: 5.46 },
            { bin: '36', location: 'Turbine building', ignitionSource: 'Transient fires caused by welding and cutting (all plants at power)', mean: 4.67e-03, ef: 5.09 },
            { bin: '37', location: 'Turbine building', ignitionSource: 'Transients (all plants at power)', mean: 6.71e-03, ef: 4.07 }
        ];

        // Rich Text Editor Component
        function RichTextEditor({ value, onChange, onClose, title }) {
            const editorRef = useRef(null);
            const [content, setContent] = useState(value || getDefaultDescription());
            const [selectedFontSize, setSelectedFontSize] = useState('14');
            const [selectedFontFamily, setSelectedFontFamily] = useState('Arial');

            useEffect(() => {
                if (editorRef.current) {
                    editorRef.current.innerHTML = content;
                }
            }, []);

            // Update font controls when cursor position changes
            const updateFontControls = () => {
                if (!editorRef.current) return;
                
                const selection = window.getSelection();
                if (selection.rangeCount > 0) {
                    const range = selection.getRangeAt(0);
                    let node = range.startContainer;
                    
                    // Walk up the tree to find the element with font styling
                    while (node && node !== editorRef.current) {
                        if (node.nodeType === Node.ELEMENT_NODE) {
                            const element = node;
                            
                            // Get computed styles
                            const computedStyle = window.getComputedStyle(element);
                            
                            // Update font size
                            const fontSize = computedStyle.fontSize;
                            if (fontSize) {
                                const sizeInPx = parseInt(fontSize);
                                setSelectedFontSize(sizeInPx.toString());
                            }
                            
                            // Update font family
                            const fontFamily = computedStyle.fontFamily;
                            if (fontFamily) {
                                // Extract the first font family name
                                const firstFont = fontFamily.split(',')[0].replace(/['"]/g, '').trim();
                                setSelectedFontFamily(firstFont);
                            }
                            
                            break;
                        }
                        node = node.parentNode;
                    }
                }
            };

            function getDefaultDescription() {
                return `<h2>Facility Description</h2>
<p>Provide an overview of the facility's purpose and mission.</p>

<h2>Facility Functions</h2>
<p>List the primary functions and operations performed at this facility.</p>

<h2>Design Characteristics</h2>
<p>Describe key design features, configuration, and major systems.</p>

<h2>Safety Features</h2>
<p>Document safety systems and protective features.</p>

<h2>References</h2>
<p>List relevant documentation, drawings, or sources.</p>`;
            }

            const execCommand = (command, value = null) => {
                if (editorRef.current) {
                    editorRef.current.focus();
                }
                
                if (command === 'formatBlock') {
                    document.execCommand('formatBlock', false, value);
                } else {
                    document.execCommand(command, false, value);
                }
                
                if (editorRef.current) {
                    setContent(editorRef.current.innerHTML);
                }
            };

            const applyFontSize = (size) => {
                // Get current selection
                const selection = window.getSelection();
                if (!selection.rangeCount) return;
                
                const range = selection.getRangeAt(0);
                if (range.collapsed) return; // Nothing selected
                
                // Use execCommand for font size
                editorRef.current.focus();
                
                // Wrap in a font tag with size attribute, then convert to span with style
                const selectedHtml = range.cloneContents();
                const span = document.createElement('span');
                span.style.fontSize = size + 'px';
                span.appendChild(selectedHtml);
                
                range.deleteContents();
                range.insertNode(span);
                
                // Reselect the modified content
                const newRange = document.createRange();
                newRange.selectNodeContents(span);
                selection.removeAllRanges();
                selection.addRange(newRange);
                
                if (editorRef.current) {
                    setContent(editorRef.current.innerHTML);
                }
            };

            const changeFontFamily = (family) => {
                // Get current selection
                const selection = window.getSelection();
                if (!selection.rangeCount) return;
                
                // Get selected text
                const range = selection.getRangeAt(0);
                if (range.collapsed) return; // Nothing selected
                
                editorRef.current.focus();
                
                // Clone the contents
                const selectedHtml = range.cloneContents();
                const span = document.createElement('span');
                // Add fallback fonts for better compatibility
                let fontFamilyString = family;
                if (family === 'Arial') fontFamilyString = 'Arial, sans-serif';
                else if (family === 'Times New Roman') fontFamilyString = "'Times New Roman', serif";
                else if (family === 'Courier New') fontFamilyString = "'Courier New', monospace";
                else if (family === 'Georgia') fontFamilyString = 'Georgia, serif';
                else if (family === 'Verdana') fontFamilyString = 'Verdana, sans-serif';
                else if (family === 'Segoe UI') fontFamilyString = "'Segoe UI', Arial, sans-serif";
                else if (family === 'Trebuchet MS') fontFamilyString = "'Trebuchet MS', sans-serif";
                
                span.style.fontFamily = fontFamilyString;
                span.appendChild(selectedHtml);
                
                range.deleteContents();
                range.insertNode(span);
                
                // Reselect the modified content
                const newRange = document.createRange();
                newRange.selectNodeContents(span);
                selection.removeAllRanges();
                selection.addRange(newRange);
                
                if (editorRef.current) {
                    setContent(editorRef.current.innerHTML);
                }
            };

            const removeFormatting = () => {
                // Use execCommand removeFormat which is more reliable
                editorRef.current.focus();
                document.execCommand('removeFormat', false, null);
                
                // Also remove font size and font family inline styles
                const selection = window.getSelection();
                if (!selection.rangeCount) return;
                
                const range = selection.getRangeAt(0);
                if (range.collapsed) return;
                
                // Get all elements in the selection
                const container = range.commonAncestorContainer;
                const parent = container.nodeType === 3 ? container.parentNode : container;
                
                // Remove style attributes from spans
                const spans = parent.getElementsByTagName('span');
                for (let i = spans.length - 1; i >= 0; i--) {
                    const span = spans[i];
                    if (span.style.fontSize || span.style.fontFamily || span.style.color) {
                        // Replace span with its contents
                        while (span.firstChild) {
                            span.parentNode.insertBefore(span.firstChild, span);
                        }
                        span.parentNode.removeChild(span);
                    }
                }
                
                if (editorRef.current) {
                    setContent(editorRef.current.innerHTML);
                }
            };

            const handleSave = () => {
                const html = editorRef.current?.innerHTML || '';
                onChange(html);
                onClose();
            };

            const handleInput = () => {
                if (editorRef.current) {
                    setContent(editorRef.current.innerHTML);
                }
            };

            const displayTitle = title || "Edit Extended Description";

            return (
                <div className="modal-overlay">
                    <div className="modal-content" style={{ 
                        maxWidth: '1000px', 
                        maxHeight: '85vh',
                        backgroundColor: '#ffffff',
                        color: '#111827',
                        display: 'flex',
                        flexDirection: 'column'
                    }}>
                        <div className="p-4" style={{ flex: '0 0 auto' }}>
                            <h2 className="text-xl font-bold mb-4">{displayTitle}</h2>
                            
                            <div className="rich-text-toolbar" style={{ position: 'sticky', top: 0, zIndex: 10, backgroundColor: '#ffffff', paddingBottom: '8px', borderBottom: '1px solid #e5e7eb', display: 'flex', flexWrap: 'wrap', alignItems: 'center', gap: '4px' }}>
                                <select
                                    className="toolbar-select"
                                    value={selectedFontSize}
                                    onChange={(e) => { 
                                        setSelectedFontSize(e.target.value);
                                        applyFontSize(e.target.value);
                                    }}
                                    style={{ padding: '4px 8px' }}
                                    title="Select text first, then choose font size"
                                >
                                    <option value="8">8pt</option>
                                    <option value="9">9pt</option>
                                    <option value="10">10pt</option>
                                    <option value="11">11pt</option>
                                    <option value="12">12pt</option>
                                    <option value="14">14pt</option>
                                    <option value="16">16pt</option>
                                    <option value="18">18pt</option>
                                    <option value="20">20pt</option>
                                    <option value="22">22pt</option>
                                    <option value="24">24pt</option>
                                    <option value="28">28pt</option>
                                    <option value="32">32pt</option>
                                </select>
                                <button 
                                    className="toolbar-button" 
                                    onMouseDown={(e) => { e.preventDefault(); removeFormatting(); }}
                                    title="Remove All Formatting (select text first)"
                                    style={{ backgroundColor: '#fef2f2', color: '#dc2626' }}
                                >
                                    Clear Format
                                </button>
                                <span style={{ padding: '4px', fontSize: '11px', color: '#666' }}>
                                    |
                                </span>
                                <button 
                                    className="toolbar-button" 
                                    onMouseDown={(e) => { e.preventDefault(); execCommand('bold'); }}
                                    title="Bold"
                                >
                                    <strong>B</strong>
                                </button>
                                <button 
                                    className="toolbar-button" 
                                    onMouseDown={(e) => { e.preventDefault(); execCommand('italic'); }}
                                    title="Italic"
                                >
                                    <em>I</em>
                                </button>
                                <button 
                                    className="toolbar-button" 
                                    onMouseDown={(e) => { e.preventDefault(); execCommand('underline'); }}
                                    title="Underline"
                                >
                                    <u>U</u>
                                </button>
                                <span style={{ padding: '4px', fontSize: '11px', color: '#666' }}>
                                    |
                                </span>
                                <button 
                                    className="toolbar-button" 
                                    onMouseDown={(e) => { e.preventDefault(); execCommand('formatBlock', '<h1>'); }}
                                    title="Heading 1"
                                >
                                    H1
                                </button>
                                <button 
                                    className="toolbar-button" 
                                    onMouseDown={(e) => { e.preventDefault(); execCommand('formatBlock', '<h2>'); }}
                                    title="Heading 2"
                                >
                                    H2
                                </button>
                                <button 
                                    className="toolbar-button" 
                                    onMouseDown={(e) => { e.preventDefault(); execCommand('formatBlock', '<h3>'); }}
                                    title="Heading 3"
                                >
                                    H3
                                </button>
                                <button 
                                    className="toolbar-button" 
                                    onMouseDown={(e) => { e.preventDefault(); execCommand('formatBlock', '<p>'); }}
                                    title="Paragraph"
                                >
                                    P
                                </button>
                                <span style={{ padding: '4px', fontSize: '11px', color: '#666' }}>
                                    |
                                </span>
                                <button 
                                    className="toolbar-button" 
                                    onMouseDown={(e) => { e.preventDefault(); execCommand('insertUnorderedList'); }}
                                    title="Bulleted List"
                                >
                                    &#8226; List
                                </button>
                                <button 
                                    className="toolbar-button" 
                                    onMouseDown={(e) => { e.preventDefault(); execCommand('insertOrderedList'); }}
                                    title="Numbered List"
                                >
                                    1. List
                                </button>
                                <div style={{ flexGrow: 1 }}></div>
                                <button
                                    onClick={onClose}
                                    className="px-4 py-2 border rounded hover:bg-gray-100"
                                    style={{ marginLeft: '8px' }}
                                >
                                    Cancel
                                </button>
                                <button
                                    onClick={handleSave}
                                    className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
                                    style={{ marginLeft: '8px' }}
                                >
                                    Save
                                </button>
                            </div>
                        </div>

                        {/* Scrollable editor container */}
                        <div style={{ flex: '1 1 auto', overflowY: 'auto', padding: '0 16px' }}>
                            <div 
                                ref={editorRef}
                                className="rich-text-editor"
                                contentEditable
                                onInput={handleInput}
                                onClick={updateFontControls}
                                onKeyUp={updateFontControls}
                                style={{ 
                                    minHeight: '500px',
                                    marginBottom: '16px'
                                }}
                            />
                        </div>

                        {/* Fixed buttons at bottom */}
                        <div style={{ flex: '0 0 auto', padding: '16px', borderTop: '1px solid #e5e7eb' }}>
                            <div className="flex gap-3 justify-end">
                                <button
                                    onClick={onClose}
                                    className="px-4 py-2 border rounded hover:bg-gray-100"
                                >
                                    Cancel
                                </button>
                                <button
                                    onClick={handleSave}
                                    className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
                                >
                                    Save
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        // Operating Schedule Editor Component
        function OperatingScheduleEditor({ schedule, onSave, onClose }) {
            const [periodYears, setPeriodYears] = useState(schedule.periodYears || 1);
            const [periods, setPeriods] = useState(schedule.periods || [
                { stateId: 'FOS-1', startDay: 0, endDay: 365 }
            ]);

            const totalDays = periodYears * 365;

            const handleAddPeriod = () => {
                // Add a new period with default values
                const newPeriod = {
                    stateId: 'FOS-1',
                    startDay: 0,
                    endDay: Math.min(30, totalDays)
                };
                setPeriods([...periods, newPeriod]);
            };

            const handleRemovePeriod = (index) => {
                if (periods.length > 1) {
                    setPeriods(periods.filter((_, i) => i !== index));
                }
            };

            const handlePeriodChange = (index, field, value) => {
                const newPeriods = [...periods];
                if (field === 'startDay' || field === 'endDay') {
                    value = Math.max(0, Math.min(totalDays, parseInt(value) || 0));
                }
                newPeriods[index] = { ...newPeriods[index], [field]: value };
                setPeriods(newPeriods);
            };

            const reconstructSchedule = () => {
                const totalDays = periodYears * 365;
                
                // If no periods, return default
                if (periods.length === 0) {
                    return [{ stateId: 'FOS-1', startDay: 0, endDay: totalDays }];
                }
                
                // Create a timeline array where each day has a state
                const timeline = new Array(totalDays);
                
                // Initialize with FOS-1
                for (let i = 0; i < totalDays; i++) {
                    timeline[i] = 'FOS-1';
                }
                
                // Apply each period (later periods override earlier ones if they overlap)
                for (const period of periods) {
                    const start = Math.max(0, Math.min(totalDays, Math.floor(period.startDay)));
                    const end = Math.max(0, Math.min(totalDays, Math.floor(period.endDay)));
                    
                    if (start < end) {
                        for (let i = start; i < end; i++) {
                            timeline[i] = period.stateId;
                        }
                    }
                }
                
                // Convert timeline array back to periods
                const result = [];
                let currentState = timeline[0];
                let currentStart = 0;
                
                for (let i = 1; i < totalDays; i++) {
                    if (timeline[i] !== currentState) {
                        result.push({
                            stateId: currentState,
                            startDay: currentStart,
                            endDay: i
                        });
                        currentState = timeline[i];
                        currentStart = i;
                    }
                }
                
                // Add the final period
                result.push({
                    stateId: currentState,
                    startDay: currentStart,
                    endDay: totalDays
                });
                
                return result;
            };

            const handleSave = () => {
                const reconstructed = reconstructSchedule();
                const newSchedule = {
                    periodYears,
                    periods: reconstructed
                };
                onSave(newSchedule);
                onClose();
            };

            return (
                <div className="modal-overlay">
                    <div className="modal-content" style={{ 
                        maxWidth: '800px',
                        backgroundColor: '#ffffff',
                        color: '#111827'
                    }}>
                        <div className="p-4">
                            <h2 className="text-xl font-bold mb-4">Edit Anticipated Operating Schedule</h2>
                            
                            <div className="mb-4">
                                <label className="block text-sm font-medium mb-2">
                                    Time Period (Years):
                                </label>
                                <input
                                    type="number"
                                    min="0.1"
                                    step="0.1"
                                    value={periodYears}
                                    onChange={(e) => setPeriodYears(parseFloat(e.target.value) || 1)}
                                    className="border rounded px-3 py-2 w-32"
                                />
                                <span className="ml-2 text-sm text-gray-600">
                                    ({totalDays} days)
                                </span>
                            </div>

                            <div className="mb-4">
                                <div className="flex justify-between items-center mb-2">
                                    <label className="block text-sm font-medium">Operating Periods:</label>
                                    <button
                                        onClick={handleAddPeriod}
                                        className="px-3 py-1 bg-blue-600 text-white text-sm rounded hover:bg-blue-700"
                                    >
                                        Add Period
                                    </button>
                                </div>
                                
                                <div className="space-y-2 max-h-96 overflow-y-auto">
                                    {periods.map((period, index) => (
                                        <div key={index} className="flex gap-2 items-center border p-2 rounded">
                                            <select
                                                value={period.stateId}
                                                onChange={(e) => handlePeriodChange(index, 'stateId', e.target.value)}
                                                className="border rounded px-2 py-1 flex-1"
                                            >
                                                {DEFAULT_OPERATING_STATES.map(state => (
                                                    <option key={state.id} value={state.id}>
                                                        {state.id}: {state.name}
                                                    </option>
                                                ))}
                                            </select>
                                            <input
                                                type="number"
                                                min="0"
                                                max={totalDays}
                                                value={period.startDay}
                                                onChange={(e) => handlePeriodChange(index, 'startDay', e.target.value)}
                                                className="border rounded px-2 py-1 w-24"
                                                placeholder="Start"
                                            />
                                            <span>to</span>
                                            <input
                                                type="number"
                                                min="0"
                                                max={totalDays}
                                                value={period.endDay}
                                                onChange={(e) => handlePeriodChange(index, 'endDay', e.target.value)}
                                                className="border rounded px-2 py-1 w-24"
                                                placeholder="End"
                                            />
                                            <span className="text-sm text-gray-600 w-20">
                                                ({period.endDay - period.startDay} d)
                                            </span>
                                            <button
                                                onClick={() => handleRemovePeriod(index)}
                                                className="px-2 py-1 bg-red-600 text-white text-sm rounded hover:bg-red-700"
                                            >
                                                Remove
                                            </button>
                                        </div>
                                    ))}
                                </div>
                                
                                <div className="mt-3 p-3 bg-blue-50 rounded text-sm">
                                    <strong>Note:</strong> Overlapping periods will be merged. Gaps will be filled with FOS-1. 
                                    Periods are automatically sorted by start time when saved.
                                </div>
                            </div>

                            <div className="flex gap-3 justify-end mt-4">
                                <button
                                    onClick={onClose}
                                    className="px-4 py-2 border rounded hover:bg-gray-100"
                                >
                                    Cancel
                                </button>
                                <button
                                    onClick={handleSave}
                                    className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
                                >
                                    Save
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        // Operating Schedule Display Component
        function OperatingScheduleDisplay({ schedule, stateColors }) {
            const totalDays = (schedule.periodYears || 1) * 365;
            const periods = schedule.periods || [];

            const getStateColor = (stateId) => {
                if (stateColors && stateColors[stateId]) {
                    return stateColors[stateId];
                }
                const state = DEFAULT_OPERATING_STATES.find(s => s.id === stateId);
                return state ? state.color : '#e5e7eb';
            };

            const getStateName = (stateId) => {
                const state = DEFAULT_OPERATING_STATES.find(s => s.id === stateId);
                return state ? state.id : stateId;
            };

            const getStateDescription = (stateId) => {
                const state = DEFAULT_OPERATING_STATES.find(s => s.id === stateId);
                return state ? state.description : '';
            };

            // Generate day labels at regular intervals
            const generateDayLabels = () => {
                const labels = [];
                const interval = totalDays <= 365 ? 30 : Math.ceil(totalDays / 12);
                
                for (let day = 0; day <= totalDays; day += interval) {
                    if (day === totalDays) {
                        labels.push({ day, position: 100 });
                    } else {
                        labels.push({ day, position: (day / totalDays) * 100 });
                    }
                }
                
                return labels;
            };

            const dayLabels = generateDayLabels();

            return (
                <div className="flex flex-col gap-1">
                    <div className="flex" style={{ height: '30px', border: '1px solid #333', position: 'relative' }}>
                        {periods.map((period, index) => {
                            const width = ((period.endDay - period.startDay) / totalDays) * 100;
                            return (
                                <div
                                    key={index}
                                    className="operating-state-box"
                                    style={{
                                        width: `${width}%`,
                                        backgroundColor: getStateColor(period.stateId),
                                        borderRight: index < periods.length - 1 ? '1px solid #333' : 'none'
                                    }}
                                    title={`${period.stateId}: ${getStateDescription(period.stateId)} (${period.startDay}-${period.endDay} days)`}
                                >
                                    {width > 8 ? getStateName(period.stateId) : ''}
                                </div>
                            );
                        })}
                    </div>
                    <div style={{ position: 'relative', height: '16px' }}>
                        {dayLabels.map((label, index) => (
                            <span 
                                key={index}
                                className="text-xs text-gray-600"
                                style={{ 
                                    position: 'absolute', 
                                    left: `${label.position}%`,
                                    transform: 'translateX(-50%)'
                                }}
                            >
                                {label.day}
                            </span>
                        ))}
                    </div>
                    <div className="text-xs text-gray-600 text-right">
                        {totalDays} days ({schedule.periodYears || 1} yr)
                    </div>
                </div>
            );
        }

        // Hazard Plot Modal Component with Zoom and Pan
        function HazardPlotModal({ createHazardPlot, getAvailableHazards, onClose }) {
            const canvasRef = useRef(null);
            const containerRef = useRef(null);
            const [scale, setScale] = useState(1);
            const [offset, setOffset] = useState({ x: 0, y: 0 });
            const [isDragging, setIsDragging] = useState(false);
            const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
            const [baseImage, setBaseImage] = useState(null);
            const [containerSize, setContainerSize] = useState({ width: 0, height: 0 });
            const [plotType, setPlotType] = useState('individual'); // 'individual' or 'total'
            const [availableHazards, setAvailableHazards] = useState([]);
            const [selectedHazards, setSelectedHazards] = useState(new Set());
            const [showSidebar, setShowSidebar] = useState(true);

            // Get available hazards on mount
            useEffect(() => {
                const hazards = getAvailableHazards();
                setAvailableHazards(hazards);
                // Initially select all hazards
                setSelectedHazards(new Set(hazards.map(h => h.name)));
            }, []);

            useEffect(() => {
                // Measure container size
                const updateSize = () => {
                    if (containerRef.current) {
                        const rect = containerRef.current.getBoundingClientRect();
                        setContainerSize({ width: rect.width, height: rect.height });
                    }
                };
                
                updateSize();
                window.addEventListener('resize', updateSize);
                
                return () => window.removeEventListener('resize', updateSize);
            }, []);

            useEffect(() => {
                // Create the base plot image
                if (containerSize.width > 0) {
                    const img = new Image();
                    img.onload = () => {
                        setBaseImage(img);
                        drawCanvas(img, scale, offset);
                    };
                    img.src = createHazardPlot(plotType, selectedHazards);
                }
            }, [containerSize, plotType, selectedHazards]);

            useEffect(() => {
                if (baseImage) {
                    drawCanvas(baseImage, scale, offset);
                }
            }, [scale, offset, baseImage, containerSize]);

            const drawCanvas = (img, currentScale, currentOffset) => {
                const canvas = canvasRef.current;
                if (!canvas || !img || containerSize.width === 0) return;

                const ctx = canvas.getContext('2d');
                
                // Set display size (CSS pixels) to container size
                canvas.style.width = containerSize.width + 'px';
                canvas.style.height = containerSize.height + 'px';
                
                // Set actual size in memory (scaled for retina displays)
                const dpr = window.devicePixelRatio || 1;
                canvas.width = containerSize.width * dpr;
                canvas.height = containerSize.height * dpr;
                
                // Scale context for retina displays
                ctx.scale(dpr, dpr);

                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Fill with white background
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, containerSize.width, containerSize.height);

                // Save context state
                ctx.save();

                // Apply transformations
                ctx.translate(currentOffset.x, currentOffset.y);
                ctx.scale(currentScale, currentScale);

                // Draw the image scaled to fit container width
                const imgAspect = img.width / img.height;
                const containerAspect = containerSize.width / containerSize.height;
                
                let drawWidth, drawHeight;
                if (imgAspect > containerAspect) {
                    // Image is wider, fit to width
                    drawWidth = containerSize.width;
                    drawHeight = containerSize.width / imgAspect;
                } else {
                    // Image is taller, fit to height
                    drawHeight = containerSize.height;
                    drawWidth = containerSize.height * imgAspect;
                }
                
                ctx.drawImage(img, 0, 0, drawWidth, drawHeight);

                // Restore context state
                ctx.restore();
            };

            const handleWheel = (e) => {
                e.preventDefault();
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                const newScale = Math.max(0.5, Math.min(5, scale * delta));
                setScale(newScale);
            };

            const handleMouseDown = (e) => {
                setIsDragging(true);
                setDragStart({ x: e.clientX - offset.x, y: e.clientY - offset.y });
            };

            const handleMouseMove = (e) => {
                if (isDragging) {
                    setOffset({
                        x: e.clientX - dragStart.x,
                        y: e.clientY - dragStart.y
                    });
                }
            };

            const handleMouseUp = () => {
                setIsDragging(false);
            };

            const handleReset = () => {
                setScale(1);
                setOffset({ x: 0, y: 0 });
            };

            const handleZoomIn = () => {
                const newScale = Math.min(5, scale * 1.2);
                setScale(newScale);
            };

            const handleZoomOut = () => {
                const newScale = Math.max(0.5, scale / 1.2);
                setScale(newScale);
            };

            const toggleHazard = (hazardName) => {
                setSelectedHazards(prev => {
                    const newSet = new Set(prev);
                    if (newSet.has(hazardName)) {
                        newSet.delete(hazardName);
                    } else {
                        newSet.add(hazardName);
                    }
                    return newSet;
                });
            };

            const selectAll = () => {
                setSelectedHazards(new Set(availableHazards.map(h => h.name)));
            };

            const selectNone = () => {
                setSelectedHazards(new Set());
            };

            // Define colors to match the plot
            const colors = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6', '#1abc9c', '#e67e22', '#34495e'];

            return (
                <div className="modal-overlay">
                    <div className="modal-content" style={{ 
                        maxWidth: '95vw',
                        width: '95vw',
                        maxHeight: '95vh',
                        height: '95vh',
                        backgroundColor: '#ffffff',
                        color: '#111827',
                        display: 'flex',
                        flexDirection: 'column'
                    }}>
                        <div className="p-4 border-b flex justify-between items-start">
                            <div>
                                <h2 className="text-xl font-bold">Hazard Frequency Plot</h2>
                                <div className="text-sm text-gray-600 mt-1">
                                    Use mouse wheel to zoom, click and drag to pan
                                </div>
                            </div>
                            <div className="flex gap-2">
                                <button
                                    onClick={() => setPlotType('individual')}
                                    className={`px-3 py-1 text-sm rounded ${plotType === 'individual' ? 'bg-blue-600 text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}
                                >
                                    Individual Hazards
                                </button>
                                <button
                                    onClick={() => setPlotType('total')}
                                    className={`px-3 py-1 text-sm rounded ${plotType === 'total' ? 'bg-blue-600 text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}
                                >
                                    Total Hazard Frequency
                                </button>
                                <span className="mx-2 text-gray-300">|</span>
                                <button
                                    onClick={() => setShowSidebar(!showSidebar)}
                                    className={`px-3 py-1 text-sm rounded ${showSidebar ? 'bg-gray-600 text-white' : 'bg-gray-200 text-gray-700 hover:bg-gray-300'}`}
                                >
                                    {showSidebar ? 'Hide' : 'Show'} Hazard List
                                </button>
                            </div>
                        </div>
                        <div className="flex-1 flex overflow-hidden">
                            {/* Main plot area */}
                            <div 
                                ref={containerRef}
                                className="flex-1 overflow-hidden"
                                style={{ 
                                    cursor: isDragging ? 'grabbing' : 'grab',
                                    position: 'relative',
                                    backgroundColor: '#f3f4f6',
                                    display: 'flex',
                                    alignItems: 'center',
                                    justifyContent: 'center'
                                }}
                            >
                                <canvas
                                    ref={canvasRef}
                                    onWheel={handleWheel}
                                    onMouseDown={handleMouseDown}
                                    onMouseMove={handleMouseMove}
                                    onMouseUp={handleMouseUp}
                                    onMouseLeave={handleMouseUp}
                                    style={{
                                        display: 'block'
                                    }}
                                />
                            </div>
                            
                            {/* Hazard selection sidebar */}
                            {showSidebar && (
                                <div className="w-64 border-l bg-white flex flex-col" style={{ minWidth: '250px' }}>
                                    <div className="p-3 border-b bg-gray-50">
                                        <div className="font-semibold text-sm mb-2">Select Hazards to Display</div>
                                        <div className="flex gap-2">
                                            <button
                                                onClick={selectAll}
                                                className="px-2 py-1 text-xs bg-blue-100 text-blue-700 rounded hover:bg-blue-200"
                                            >
                                                Select All
                                            </button>
                                            <button
                                                onClick={selectNone}
                                                className="px-2 py-1 text-xs bg-gray-100 text-gray-700 rounded hover:bg-gray-200"
                                            >
                                                Select None
                                            </button>
                                        </div>
                                        <div className="text-xs text-gray-500 mt-2">
                                            {selectedHazards.size} of {availableHazards.length} selected
                                        </div>
                                    </div>
                                    <div className="flex-1 overflow-y-auto p-2">
                                        {availableHazards.length === 0 ? (
                                            <div className="text-sm text-gray-500 text-center py-4">
                                                No hazards with frequency data
                                            </div>
                                        ) : (
                                            availableHazards.map((hazard, index) => (
                                                <label 
                                                    key={hazard.name} 
                                                    className="flex items-start gap-2 p-2 hover:bg-gray-50 rounded cursor-pointer"
                                                >
                                                    <input
                                                        type="checkbox"
                                                        checked={selectedHazards.has(hazard.name)}
                                                        onChange={() => toggleHazard(hazard.name)}
                                                        className="mt-1"
                                                    />
                                                    <div className="flex-1 min-w-0">
                                                        <div className="flex items-center gap-2">
                                                            <span 
                                                                className="w-3 h-3 rounded-sm flex-shrink-0"
                                                                style={{ backgroundColor: colors[index % colors.length] }}
                                                            ></span>
                                                            <span className="text-sm font-medium truncate">{hazard.name}</span>
                                                        </div>
                                                        <div className="text-xs text-gray-500 ml-5">
                                                            {hazard.frequency.toExponential(2)} /yr
                                                            {hazard.isOutOfRange && (
                                                                <span className="ml-1 text-orange-600" title="Frequency outside plot range">&#9888;</span>
                                                            )}
                                                        </div>
                                                    </div>
                                                </label>
                                            ))
                                        )}
                                    </div>
                                </div>
                            )}
                        </div>
                        <div className="p-4 border-t flex gap-3 justify-between items-center">
                            <div className="flex gap-2">
                                <button
                                    onClick={handleZoomIn}
                                    className="px-3 py-1 bg-gray-200 rounded hover:bg-gray-300"
                                    title="Zoom In"
                                >
                                    <span style={{ fontSize: '18px' }}>+</span>
                                </button>
                                <button
                                    onClick={handleZoomOut}
                                    className="px-3 py-1 bg-gray-200 rounded hover:bg-gray-300"
                                    title="Zoom Out"
                                >
                                    <span style={{ fontSize: '18px' }}>&#8722;</span>
                                </button>
                                <button
                                    onClick={handleReset}
                                    className="px-3 py-1 bg-gray-200 rounded hover:bg-gray-300"
                                >
                                    Reset View
                                </button>
                                <span className="px-3 py-1 text-sm text-gray-600">
                                    Zoom: {Math.round(scale * 100)}%
                                </span>
                            </div>
                            <button
                                onClick={onClose}
                                className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
                            >
                                Close
                            </button>
                        </div>
                    </div>
                </div>
            );
        }

        // Hazard Editor Component
        function HazardEditor({ hazard, onSave, onClose, allAnalysisData, allStates, settings }) {
            const { hazardId, hazardName, stateId } = hazard;
            const key = `${hazardId}_${stateId}`;
            
            const [useInfoFrom, setUseInfoFrom] = useState('');
            const [applicableEvents, setApplicableEvents] = useState([]);
            const [status, setStatus] = useState('unanalyzed');
            const [editingEventIndex, setEditingEventIndex] = useState(null);
            const [editingDescription, setEditingDescription] = useState(null);
            const [originalEventData, setOriginalEventData] = useState(null);
            const [collapsedEvents, setCollapsedEvents] = useState(new Set()); // Events are expanded by default

            // Format frequency based on settings
            const formatFrequency = (value) => {
                if (value === null || value === undefined) return '';
                const digits = settings.frequencyDigits !== undefined ? settings.frequencyDigits : 2;
                return value.toExponential(digits);
            };

            // Load existing data
            useEffect(() => {
                const existingData = allAnalysisData[key];
                if (existingData) {
                    setUseInfoFrom(existingData.useInfoFrom || '');
                    setApplicableEvents(existingData.applicableEvents || []);
                    setStatus(existingData.status || 'unanalyzed');
                } else if (useInfoFrom) {
                    // If using info from another state, also copy the status
                    const sourceKey = `${hazardId}_${useInfoFrom}`;
                    const sourceData = allAnalysisData[sourceKey];
                    if (sourceData) {
                        setStatus(sourceData.status || 'unanalyzed');
                    }
                }
            }, []);  // Only run on mount

            // Handle changes to useInfoFrom selection
            const handleUseInfoFromChange = (newValue) => {
                setUseInfoFrom(newValue);
                
                if (newValue === '') {
                    // Switching back to "Enter new information"
                    // Keep existing events if they exist, otherwise clear
                    const existingData = allAnalysisData[key];
                    if (existingData && existingData.applicableEvents && existingData.applicableEvents.length > 0) {
                        // If we had saved events before, restore them
                        setApplicableEvents(existingData.applicableEvents);
                        setStatus(existingData.status || 'unanalyzed');
                    } else {
                        // Otherwise start fresh
                        setApplicableEvents([]);
                        setStatus('unanalyzed');
                    }
                } else {
                    // Using info from another state - don't modify applicableEvents here
                    // They will be displayed from sourceData in read-only mode
                    const sourceKey = `${hazardId}_${newValue}`;
                    const sourceData = allAnalysisData[sourceKey];
                    if (sourceData) {
                        setStatus(sourceData.status || 'unanalyzed');
                    }
                }
            };

            // Get available states to copy from
            const getAvailableStates = () => {
                const available = [];
                DEFAULT_OPERATING_STATES.forEach(state => {
                    const testKey = `${hazardId}_${state.id}`;
                    if (state.id !== stateId && allAnalysisData[testKey] && allAnalysisData[testKey].applicableEvents?.length > 0) {
                        available.push(state);
                    }
                });
                return available;
            };

            const availableStates = getAvailableStates();

            // Build breadcrumb path from hazard ID
            const getBreadcrumbPath = (hazardId, hazardList) => {
                const path = [];
                
                const findPath = (nodes, targetId, currentPath) => {
                    for (const node of nodes) {
                        const newPath = [...currentPath, node.name];
                        if (node.id === targetId) {
                            return newPath;
                        }
                        if (node.children && node.children.length > 0) {
                            const result = findPath(node.children, targetId, newPath);
                            if (result) return result;
                        }
                    }
                    return null;
                };
                
                const result = findPath(hazardList, hazardId, []);
                return result || [];
            };

            const getDefaultDescription = (hazardName) => {
                return `<h1>${hazardName} Hazard</h1><br><h1>Hazard Description</h1><br><p></p><h1>Assumptions</h1><br><p></p><h1>Requirements</h1><br><p></p><h1>Uncertainty Discussion</h1><br><p></p><h1>References</h1><br><p></p>`;
            };

            const handleAddEvent = () => {
                const newEvent = {
                    id: Date.now(),
                    name: hazardName,
                    eventDescription: '',
                    occurrenceModel: 'frequency',
                    // Frequency occurrence data
                    frequencyDistribution: 'cni',
                    gammaShape: '',
                    gammaScale: '',
                    pointEstimate: '',
                    frequencyUnits: '/yr',
                    // Probability per Opportunity data
                    opportunitiesPerPeriod: '',
                    probabilityDistribution: 'cni',
                    betaShape: '',
                    betaScale: '',
                    probLognormalMean: '',
                    probLognormalEF: '',
                    probCniMean: '',
                    probPointEstimate: '',
                    // Hazard curve data
                    hazardCurveRows: 5,
                    hazardCurveData: [],
                    hazardFrequencyUnits: '/yr',
                    hazardMagnitudeUnits: '',
                    // NUREG-2169 Fire Ignition data
                    fireIgnitionSelections: {},  // Object with bin as key, boolean as value
                    fireIgnitionComponentCount: 1,  // Number of components of this type (frequency divided by this)
                    fireIgnitionPropagationFactor: 1,  // Fire propagation or adjustment factor (multiplier)
                    restorationModel: 'none',
                    description: getDefaultDescription(hazardName)
                };
                setApplicableEvents([...applicableEvents, newEvent]);
                setOriginalEventData(JSON.stringify(newEvent));
                setEditingEventIndex(applicableEvents.length);
            };

            const handleDeleteEvent = (index) => {
                if (confirm('Delete this applicable event?')) {
                    setApplicableEvents(applicableEvents.filter((_, i) => i !== index));
                    if (editingEventIndex === index) {
                        setEditingEventIndex(null);
                        setOriginalEventData(null);
                    }
                    // Update collapsed events set - remove this index and adjust higher indices
                    setCollapsedEvents(prev => {
                        const newSet = new Set();
                        prev.forEach(i => {
                            if (i < index) newSet.add(i);
                            else if (i > index) newSet.add(i - 1);
                        });
                        return newSet;
                    });
                }
            };

            const handleEventChange = (index, field, value) => {
                const updated = [...applicableEvents];
                updated[index] = { ...updated[index], [field]: value };
                
                // Initialize hazard curve data if rows changed
                if (field === 'hazardCurveRows') {
                    const rows = parseInt(value) || 0;
                    const currentData = updated[index].hazardCurveData || [];
                    const newData = [];
                    for (let i = 0; i < rows; i++) {
                        newData.push(currentData[i] || { magnitude: '', frequency: '' });
                    }
                    updated[index].hazardCurveData = newData;
                }
                
                setApplicableEvents(updated);
            };

            const handleHazardCurveDataChange = (eventIndex, rowIndex, field, value) => {
                const updated = [...applicableEvents];
                const curveData = [...(updated[eventIndex].hazardCurveData || [])];
                if (!curveData[rowIndex]) {
                    curveData[rowIndex] = { magnitude: '', frequency: '' };
                }
                curveData[rowIndex][field] = value;
                updated[eventIndex].hazardCurveData = curveData;
                setApplicableEvents(updated);
            };

            const handlePasteHazardCurve = (eventIndex, pasteData) => {
                try {
                    const lines = pasteData.trim().split('\n');
                    const newData = [];
                    for (const line of lines) {
                        const cells = line.split('\t');
                        if (cells.length >= 2) {
                            newData.push({
                                magnitude: cells[0].trim(),
                                frequency: cells[1].trim()
                            });
                        }
                    }
                    if (newData.length > 0) {
                        const updated = [...applicableEvents];
                        updated[eventIndex].hazardCurveData = newData;
                        updated[eventIndex].hazardCurveRows = newData.length;
                        setApplicableEvents(updated);
                        alert(`Pasted ${newData.length} rows successfully`);
                    }
                } catch (err) {
                    alert('Error pasting data: ' + err.message);
                }
            };

            const handleSave = () => {
                const data = {
                    useInfoFrom,
                    applicableEvents,
                    status
                };
                onSave(key, data);
                onClose();
            };

            const currentState = DEFAULT_OPERATING_STATES.find(s => s.id === stateId);
            const isReadOnly = useInfoFrom !== '';
            const sourceData = useInfoFrom ? allAnalysisData[`${hazardId}_${useInfoFrom}`] : null;
            const displayEvents = isReadOnly && sourceData ? sourceData.applicableEvents : applicableEvents;
            const isEditingEvent = editingEventIndex !== null;

            // Get breadcrumb path for display
            const breadcrumbPath = getBreadcrumbPath(hazardId, window.currentHazardList || []);

            return (
                <div className="modal-overlay">
                    <div className="modal-content hazard-editor-modal" style={{ backgroundColor: '#ffffff', color: '#111827', display: 'flex', flexDirection: 'column' }}>
                        <div className="p-4 flex flex-col" style={{ height: '100%', overflow: 'hidden' }}>
                            <div className="mb-4 pb-3 border-b flex-shrink-0">
                                <h2 className="text-xl font-bold">Hazard Analysis Editor</h2>
                                <div className="mt-2 text-sm">
                                    {breadcrumbPath.length > 0 && (
                                        <div className="text-gray-600 mb-1">
                                            {breadcrumbPath.map((part, index) => (
                                                <span key={index}>
                                                    {index > 0 && ' > '}
                                                    {index === breadcrumbPath.length - 1 ? (
                                                        <strong>{part}</strong>
                                                    ) : (
                                                        part
                                                    )}
                                                </span>
                                            ))}
                                        </div>
                                    )}
                                    <div><strong>Operating State:</strong> {currentState?.id} - {currentState?.name}</div>
                                </div>
                            </div>

                            {/* Use Information From */}
                            {availableStates.length > 0 && (
                                <div className="mb-4 flex-shrink-0">
                                    <label className="block text-sm font-medium mb-2">Only Use Information From:</label>
                                    <select
                                        value={useInfoFrom}
                                        onChange={(e) => handleUseInfoFromChange(e.target.value)}
                                        className="w-full border rounded px-3 py-2"
                                        disabled={isEditingEvent}
                                    >
                                        <option value="">-- Enter new information --</option>
                                        {availableStates.map(state => (
                                            <option key={state.id} value={state.id}>
                                                {state.id} - {state.name}
                                            </option>
                                        ))}
                                    </select>
                                    {isReadOnly && (
                                        <p className="text-xs text-gray-600 mt-1">
                                            Information is read-only when copied from another operating state. Select "-- Enter new information --" to add your own data.
                                        </p>
                                    )}
                                </div>
                            )}

                            {/* Applicable Events */}
                            <div className="mb-4 flex-1 flex flex-col overflow-hidden">
                                <div className="flex justify-between items-center mb-2 flex-shrink-0">
                                    <label className="block text-sm font-medium">Applicable Initiating Event(s) for this Hazard:</label>
                                    {!isReadOnly && (
                                        <button
                                            onClick={handleAddEvent}
                                            className="px-3 py-1 bg-green-600 text-white text-sm rounded hover:bg-green-700 disabled:bg-gray-400 disabled:cursor-not-allowed"
                                            disabled={isEditingEvent}
                                        >
                                            Add Event
                                        </button>
                                    )}
                                </div>

                                <div className="space-y-3 flex-1 overflow-y-auto" style={{ minHeight: '200px' }}>
                                    {displayEvents && displayEvents.length > 0 ? (
                                        displayEvents.map((event, index) => {
                                            const isScreened = event.occurrenceModel === 'screened-low-freq' || 
                                                             event.occurrenceModel === 'screened-low-consequence' ||
                                                             event.occurrenceModel === 'screened-not-applicable';
                                            const bgColor = isScreened ? '#ffe0e0' : '#f9fafb';
                                            
                                            return (
                                                <div key={event.id || index} className="border rounded p-3" style={{ backgroundColor: bgColor }}>
                                                    {editingEventIndex === index && !isReadOnly ? (
                                                        <div className="space-y-3" style={{ position: 'relative' }}>
                                                            {/* Action buttons at top - sticky */}
                                                            <div className="flex gap-2 mb-3 pb-2 border-b" style={{ position: 'sticky', top: 0, backgroundColor: bgColor, zIndex: 5 }}>
                                                                <button
                                                                    onClick={() => {
                                                                        // Cancel editing - check if changes were made
                                                                        const hasChanges = originalEventData && JSON.stringify(event) !== originalEventData;
                                                                        if (!hasChanges || confirm('Cancel editing? Any unsaved changes to this event will be lost.')) {
                                                                            setOriginalEventData(null);
                                                                            setEditingEventIndex(null);
                                                                        }
                                                                    }}
                                                                    className="px-2 py-1 bg-gray-500 text-white text-xs rounded hover:bg-gray-600"
                                                                >
                                                                    Cancel
                                                                </button>
                                                                <button
                                                                    onClick={() => {
                                                                        setOriginalEventData(null);
                                                                        setEditingEventIndex(null);
                                                                    }}
                                                                    className="px-2 py-1 bg-green-800 text-white text-xs rounded hover:bg-green-900"
                                                                >
                                                                    Done Editing
                                                                </button>
                                                                <button
                                                                    onClick={() => handleDeleteEvent(index)}
                                                                    className="px-2 py-1 bg-red-600 text-white text-xs rounded hover:bg-red-700"
                                                                >
                                                                    Delete Event
                                                                </button>
                                                            </div>
                                                            
                                                            <div>
                                                                <label className="block text-xs font-medium mb-1">Name:</label>
                                                                <input
                                                                    type="text"
                                                                    value={event.name}
                                                                    onChange={(e) => handleEventChange(index, 'name', e.target.value)}
                                                                    className="w-full border rounded px-2 py-1 text-sm"
                                                                />
                                                            </div>
                                                            <div>
                                                                <label className="block text-xs font-medium mb-1">Event Description:</label>
                                                                <input
                                                                    type="text"
                                                                    value={event.eventDescription}
                                                                    onChange={(e) => handleEventChange(index, 'eventDescription', e.target.value)}
                                                                    className="w-full border rounded px-2 py-1 text-sm"
                                                                />
                                                            </div>
                                                            <div>
                                                                <label className="block text-xs font-medium mb-1">Occurrence Model:</label>
                                                                <select
                                                                    value={event.occurrenceModel}
                                                                    onChange={(e) => handleEventChange(index, 'occurrenceModel', e.target.value)}
                                                                    className="w-full border rounded px-2 py-1 text-sm"
                                                                >
                                                                    <option value="frequency">Frequency of occurrence</option>
                                                                    <option value="prob-per-opportunity">Probability per Opportunity</option>
                                                                    <option value="hazard-curve">Hazard Curve</option>
                                                                    <option value="nureg-2169-fire">NUREG-2169 Fire Ignition</option>
                                                                    <option value="screened-low-freq">Screened due to low frequency</option>
                                                                    <option value="screened-low-consequence">Screened due to low consequence</option>
                                                                    <option value="screened-not-applicable">Screened due to not being applicable</option>
                                                                </select>
                                                            </div>

                                                            {/* Frequency of Occurrence Fields */}
                                                            {event.occurrenceModel === 'frequency' && (
                                                                <div className="border rounded p-3 bg-blue-50 space-y-2">
                                                                    <div>
                                                                        <label className="block text-xs font-medium mb-1">Frequency Distribution:</label>
                                                                        <select
                                                                            value={event.frequencyDistribution || 'gamma'}
                                                                            onChange={(e) => handleEventChange(index, 'frequencyDistribution', e.target.value)}
                                                                            className="w-full border rounded px-2 py-1 text-sm"
                                                                        >
                                                                            <option value="gamma">Gamma</option>
                                                                            <option value="lognormal">Lognormal</option>
                                                                            <option value="cni">Constrained Non-Informative (CNI)</option>
                                                                            <option value="point">Point estimate</option>
                                                                        </select>
                                                                    </div>
                                                                    
                                                                    {event.frequencyDistribution === 'gamma' ? (
                                                                        <>
                                                                            <div className="flex gap-2">
                                                                                <div className="flex-1">
                                                                                    <label className="block text-xs font-medium mb-1">Gamma Shape Parameter (&#945;):</label>
                                                                                    <input
                                                                                        type="text"
                                                                                        value={event.gammaShape || ''}
                                                                                        onChange={(e) => handleEventChange(index, 'gammaShape', e.target.value)}
                                                                                        className="w-full border rounded px-2 py-1 text-sm"
                                                                                        placeholder="&#945; (alpha)"
                                                                                    />
                                                                                </div>
                                                                                <div className="flex-1">
                                                                                    <label className="block text-xs font-medium mb-1">Gamma Scale Parameter (&#952;):</label>
                                                                                    <input
                                                                                        type="text"
                                                                                        value={event.gammaScale || ''}
                                                                                        onChange={(e) => handleEventChange(index, 'gammaScale', e.target.value)}
                                                                                        className="w-full border rounded px-2 py-1 text-sm"
                                                                                        placeholder="&#952; (theta)"
                                                                                    />
                                                                                </div>
                                                                            </div>
                                                                        </>
                                                                    ) : event.frequencyDistribution === 'lognormal' ? (
                                                                        <>
                                                                            <div className="flex gap-2">
                                                                                <div className="flex-1">
                                                                                    <label className="block text-xs font-medium mb-1">Mean:</label>
                                                                                    <input
                                                                                        type="text"
                                                                                        value={event.lognormalMean || ''}
                                                                                        onChange={(e) => handleEventChange(index, 'lognormalMean', e.target.value)}
                                                                                        className="w-full border rounded px-2 py-1 text-sm"
                                                                                        placeholder="Mean value"
                                                                                    />
                                                                                </div>
                                                                                <div className="flex-1">
                                                                                    <label className="block text-xs font-medium mb-1">Error Factor (EF):</label>
                                                                                    <input
                                                                                        type="text"
                                                                                        value={event.lognormalEF || ''}
                                                                                        onChange={(e) => handleEventChange(index, 'lognormalEF', e.target.value)}
                                                                                        className="w-full border rounded px-2 py-1 text-sm"
                                                                                        placeholder="EF = 95%/50%"
                                                                                        title="Error Factor: ratio of 95th percentile to median (95%/50%)"
                                                                                    />
                                                                                </div>
                                                                            </div>
                                                                            <p className="text-xs text-gray-600 mt-1">
                                                                                EF is the ratio of the 95th percentile to the 50th percentile (median): EF = 95%/50%
                                                                            </p>
                                                                        </>
                                                                    ) : event.frequencyDistribution === 'cni' ? (
                                                                        <>
                                                                            <div>
                                                                                <label className="block text-xs font-medium mb-1">Mean:</label>
                                                                                <input
                                                                                    type="text"
                                                                                    value={event.cniMean || ''}
                                                                                    onChange={(e) => handleEventChange(index, 'cniMean', e.target.value)}
                                                                                    className="w-full border rounded px-2 py-1 text-sm"
                                                                                    placeholder="Mean value"
                                                                                />
                                                                            </div>
                                                                            <p className="text-xs text-gray-600 mt-1">
                                                                                CNI uses a gamma distribution with shape \u03B1=0.5 and scale \u03B8=2\u00D7mean
                                                                            </p>
                                                                        </>
                                                                    ) : (
                                                                        <div>
                                                                            <label className="block text-xs font-medium mb-1">Point Estimate Value:</label>
                                                                            <input
                                                                                type="text"
                                                                                value={event.pointEstimate || ''}
                                                                                onChange={(e) => handleEventChange(index, 'pointEstimate', e.target.value)}
                                                                                className="w-full border rounded px-2 py-1 text-sm"
                                                                            />
                                                                        </div>
                                                                    )}
                                                                    
                                                                    <div>
                                                                        <label className="block text-xs font-medium mb-1">Units:</label>
                                                                        <select
                                                                            value={event.frequencyUnits || '/yr'}
                                                                            onChange={(e) => handleEventChange(index, 'frequencyUnits', e.target.value)}
                                                                            className="w-full border rounded px-2 py-1 text-sm"
                                                                        >
                                                                            <option value="/hr">/hr (per hour)</option>
                                                                            <option value="/yr">/yr (per year)</option>
                                                                        </select>
                                                                    </div>
                                                                </div>
                                                            )}

                                                            {/* Probability per Opportunity Fields */}
                                                            {event.occurrenceModel === 'prob-per-opportunity' && (
                                                                <div className="border rounded p-3 bg-purple-50 space-y-2">
                                                                    <div>
                                                                        <label className="block text-xs font-medium mb-1">Number of Opportunities in Each Operating Period:</label>
                                                                        <input
                                                                            type="number"
                                                                            min="1"
                                                                            step="1"
                                                                            value={event.opportunitiesPerPeriod || ''}
                                                                            onChange={(e) => handleEventChange(index, 'opportunitiesPerPeriod', e.target.value)}
                                                                            className="w-full border rounded px-2 py-1 text-sm"
                                                                            placeholder="Number of opportunities (integer)"
                                                                        />
                                                                        <p className="text-xs text-gray-600 mt-1">
                                                                            Each opportunity occurs at least once per operating period
                                                                        </p>
                                                                    </div>
                                                                    
                                                                    <div>
                                                                        <label className="block text-xs font-medium mb-1">Probability Distribution:</label>
                                                                        <select
                                                                            value={event.probabilityDistribution || 'cni'}
                                                                            onChange={(e) => handleEventChange(index, 'probabilityDistribution', e.target.value)}
                                                                            className="w-full border rounded px-2 py-1 text-sm"
                                                                        >
                                                                            <option value="beta">Beta</option>
                                                                            <option value="cni">Constrained Non-Informative (CNI)</option>
                                                                            <option value="lognormal">Lognormal</option>
                                                                            <option value="point">Point estimate</option>
                                                                        </select>
                                                                    </div>
                                                                    
                                                                    {event.probabilityDistribution === 'beta' ? (
                                                                        <>
                                                                            <div className="flex gap-2">
                                                                                <div className="flex-1">
                                                                                    <label className="block text-xs font-medium mb-1">Beta Shape Parameter (&#945;):</label>
                                                                                    <input
                                                                                        type="text"
                                                                                        value={event.betaShape || ''}
                                                                                        onChange={(e) => handleEventChange(index, 'betaShape', e.target.value)}
                                                                                        className="w-full border rounded px-2 py-1 text-sm"
                                                                                        placeholder="&#945; (alpha)"
                                                                                    />
                                                                                </div>
                                                                                <div className="flex-1">
                                                                                    <label className="block text-xs font-medium mb-1">Beta Scale Parameter (&#946;):</label>
                                                                                    <input
                                                                                        type="text"
                                                                                        value={event.betaScale || ''}
                                                                                        onChange={(e) => handleEventChange(index, 'betaScale', e.target.value)}
                                                                                        className="w-full border rounded px-2 py-1 text-sm"
                                                                                        placeholder="&#946; (beta)"
                                                                                    />
                                                                                </div>
                                                                            </div>
                                                                            <p className="text-xs text-gray-600 mt-1">
                                                                                Mean = &#945; / (&#945; + &#946;)
                                                                            </p>
                                                                        </>
                                                                    ) : event.probabilityDistribution === 'lognormal' ? (
                                                                        <>
                                                                            <div className="flex gap-2">
                                                                                <div className="flex-1">
                                                                                    <label className="block text-xs font-medium mb-1">Mean:</label>
                                                                                    <input
                                                                                        type="text"
                                                                                        value={event.probLognormalMean || ''}
                                                                                        onChange={(e) => handleEventChange(index, 'probLognormalMean', e.target.value)}
                                                                                        className="w-full border rounded px-2 py-1 text-sm"
                                                                                        placeholder="Mean value"
                                                                                    />
                                                                                </div>
                                                                                <div className="flex-1">
                                                                                    <label className="block text-xs font-medium mb-1">Error Factor (EF):</label>
                                                                                    <input
                                                                                        type="text"
                                                                                        value={event.probLognormalEF || ''}
                                                                                        onChange={(e) => handleEventChange(index, 'probLognormalEF', e.target.value)}
                                                                                        className="w-full border rounded px-2 py-1 text-sm"
                                                                                        placeholder="EF = 95%/50%"
                                                                                        title="Error Factor: ratio of 95th percentile to median (95%/50%)"
                                                                                    />
                                                                                </div>
                                                                            </div>
                                                                            <p className="text-xs text-gray-600 mt-1">
                                                                                EF is the ratio of the 95th percentile to the 50th percentile (median): EF = 95%/50%
                                                                            </p>
                                                                        </>
                                                                    ) : event.probabilityDistribution === 'point' ? (
                                                                        <div>
                                                                            <label className="block text-xs font-medium mb-1">Point Estimate Value:</label>
                                                                            <input
                                                                                type="text"
                                                                                value={event.probPointEstimate || ''}
                                                                                onChange={(e) => handleEventChange(index, 'probPointEstimate', e.target.value)}
                                                                                className="w-full border rounded px-2 py-1 text-sm"
                                                                                placeholder="Probability (0 to 1)"
                                                                            />
                                                                        </div>
                                                                    ) : (
                                                                        <>
                                                                            <div>
                                                                                <label className="block text-xs font-medium mb-1">Mean Value:</label>
                                                                                <input
                                                                                    type="text"
                                                                                    value={event.probCniMean || ''}
                                                                                    onChange={(e) => handleEventChange(index, 'probCniMean', e.target.value)}
                                                                                    className="w-full border rounded px-2 py-1 text-sm"
                                                                                    placeholder="Mean value"
                                                                                />
                                                                            </div>
                                                                            <p className="text-xs text-gray-600 mt-1">
                                                                                CNI uses a beta distribution with shape &#945;=0.5 and scale &#946;=(0.5/mean)-0.5
                                                                            </p>
                                                                        </>
                                                                    )}
                                                                </div>
                                                            )}

                                                            {/* Hazard Curve Fields */}
                                                            {event.occurrenceModel === 'hazard-curve' && (
                                                                <div className="border rounded p-3 bg-green-50 space-y-2">
                                                                    <div>
                                                                        <label className="block text-xs font-medium mb-1">Number of Data Points:</label>
                                                                        <input
                                                                            type="text"
                                                                            value={event.hazardCurveRows || 5}
                                                                            onChange={(e) => handleEventChange(index, 'hazardCurveRows', e.target.value)}
                                                                            className="w-32 border rounded px-2 py-1 text-sm"
                                                                        />
                                                                    </div>
                                                                    
                                                                    <div>
                                                                        <div className="flex justify-between items-center mb-1">
                                                                            <label className="block text-xs font-medium">Hazard Curve Data:</label>
                                                                            <button
                                                                                onClick={() => {
                                                                                    const paste = prompt('Paste two-column data (tab-separated):\nColumn 1: Hazard Magnitude\nColumn 2: Hazard Frequency');
                                                                                    if (paste) handlePasteHazardCurve(index, paste);
                                                                                }}
                                                                                className="px-2 py-1 bg-blue-600 text-white text-xs rounded hover:bg-blue-700"
                                                                            >
                                                                                Paste from Excel
                                                                            </button>
                                                                        </div>
                                                                        <div className="border rounded bg-white max-h-48 overflow-y-auto">
                                                                            <table className="w-full text-xs">
                                                                                <thead className="bg-gray-100 sticky top-0">
                                                                                    <tr>
                                                                                        <th className="border p-1 text-left">Hazard Magnitude</th>
                                                                                        <th className="border p-1 text-left">Hazard Frequency</th>
                                                                                    </tr>
                                                                                </thead>
                                                                                <tbody>
                                                                                    {Array.from({ length: event.hazardCurveRows || 5 }).map((_, rowIdx) => {
                                                                                        const rowData = (event.hazardCurveData || [])[rowIdx] || { magnitude: '', frequency: '' };
                                                                                        return (
                                                                                            <tr key={rowIdx}>
                                                                                                <td className="border p-1">
                                                                                                    <input
                                                                                                        type="text"
                                                                                                        value={rowData.magnitude}
                                                                                                        onChange={(e) => handleHazardCurveDataChange(index, rowIdx, 'magnitude', e.target.value)}
                                                                                                        className="w-full px-1 py-0.5 text-xs"
                                                                                                    />
                                                                                                </td>
                                                                                                <td className="border p-1">
                                                                                                    <input
                                                                                                        type="text"
                                                                                                        value={rowData.frequency}
                                                                                                        onChange={(e) => handleHazardCurveDataChange(index, rowIdx, 'frequency', e.target.value)}
                                                                                                        className="w-full px-1 py-0.5 text-xs"
                                                                                                    />
                                                                                                </td>
                                                                                            </tr>
                                                                                        );
                                                                                    })}
                                                                                </tbody>
                                                                            </table>
                                                                        </div>
                                                                    </div>
                                                                    
                                                                    <div className="flex gap-2">
                                                                        <div className="flex-1">
                                                                            <label className="block text-xs font-medium mb-1">Hazard Magnitude Units:</label>
                                                                            <input
                                                                                type="text"
                                                                                value={event.hazardMagnitudeUnits || ''}
                                                                                onChange={(e) => handleEventChange(index, 'hazardMagnitudeUnits', e.target.value)}
                                                                                className="w-full border rounded px-2 py-1 text-sm"
                                                                                placeholder="e.g., psi, g, mph"
                                                                            />
                                                                        </div>
                                                                        <div className="flex-1">
                                                                            <label className="block text-xs font-medium mb-1">Hazard Frequency Units:</label>
                                                                            <select
                                                                                value={event.hazardFrequencyUnits || '/yr'}
                                                                                onChange={(e) => handleEventChange(index, 'hazardFrequencyUnits', e.target.value)}
                                                                                className="w-full border rounded px-2 py-1 text-sm"
                                                                            >
                                                                                <option value="/hr">/hr (per hour)</option>
                                                                                <option value="/yr">/yr (per year)</option>
                                                                            </select>
                                                                        </div>
                                                                    </div>
                                                                </div>
                                                            )}

                                                            {/* NUREG-2169 Fire Ignition Fields */}
                                                            {event.occurrenceModel === 'nureg-2169-fire' && (
                                                                <div className="border rounded p-3 bg-orange-50 space-y-2">
                                                                    <div className="flex justify-between items-center mb-2">
                                                                        <label className="block text-xs font-medium">Select Fire Ignition Sources (NUREG-2169 Table 4-4):</label>
                                                                        <div className="flex gap-2">
                                                                            <button
                                                                                onClick={() => {
                                                                                    const allSelected = {};
                                                                                    NUREG2169_FIRE_IGNITION_DATA.forEach(item => {
                                                                                        allSelected[item.bin] = true;
                                                                                    });
                                                                                    handleEventChange(index, 'fireIgnitionSelections', allSelected);
                                                                                }}
                                                                                className="px-2 py-1 bg-green-600 text-white text-xs rounded hover:bg-green-700"
                                                                            >
                                                                                Select All
                                                                            </button>
                                                                            <button
                                                                                onClick={() => {
                                                                                    handleEventChange(index, 'fireIgnitionSelections', {});
                                                                                }}
                                                                                className="px-2 py-1 bg-gray-600 text-white text-xs rounded hover:bg-gray-700"
                                                                            >
                                                                                Clear All
                                                                            </button>
                                                                        </div>
                                                                    </div>
                                                                    
                                                                    <div className="border rounded bg-white max-h-64 overflow-y-auto">
                                                                        <table className="w-full text-xs" style={{ tableLayout: 'fixed' }}>
                                                                            <thead className="bg-gray-100 sticky top-0">
                                                                                <tr>
                                                                                    <th className="py-1 px-2 text-left" style={{ width: '30px' }}></th>
                                                                                    <th className="py-1 px-2 text-left" style={{ width: '45px' }}>Bin</th>
                                                                                    <th className="py-1 px-2 text-left" style={{ width: '180px' }}>Location</th>
                                                                                    <th className="py-1 px-2 text-left">Ignition Source</th>
                                                                                    <th className="py-1 px-2 text-right" style={{ width: '80px' }}>Mean (/yr)</th>
                                                                                    <th className="py-1 px-2 text-right" style={{ width: '60px' }}>EF</th>
                                                                                </tr>
                                                                            </thead>
                                                                            <tbody>
                                                                                {NUREG2169_FIRE_IGNITION_DATA.map((item) => (
                                                                                    <tr 
                                                                                        key={item.bin}
                                                                                        className={`hover:bg-gray-50 cursor-pointer ${(event.fireIgnitionSelections || {})[item.bin] ? 'bg-orange-100' : ''}`}
                                                                                        onClick={() => {
                                                                                            const newSelections = { ...(event.fireIgnitionSelections || {}) };
                                                                                            newSelections[item.bin] = !newSelections[item.bin];
                                                                                            handleEventChange(index, 'fireIgnitionSelections', newSelections);
                                                                                        }}
                                                                                    >
                                                                                        <td className="py-1 px-2" style={{ width: '30px' }}>
                                                                                            <input
                                                                                                type="checkbox"
                                                                                                checked={(event.fireIgnitionSelections || {})[item.bin] || false}
                                                                                                onChange={() => {}}
                                                                                                className="cursor-pointer"
                                                                                            />
                                                                                        </td>
                                                                                        <td className="py-1 px-2" style={{ width: '45px' }}>{item.bin}</td>
                                                                                        <td className="py-1 px-2" style={{ width: '180px' }}>{item.location}</td>
                                                                                        <td className="py-1 px-2">{item.ignitionSource}</td>
                                                                                        <td className="py-1 px-2 text-right" style={{ width: '80px' }}>{item.mean.toExponential(2)}</td>
                                                                                        <td className="py-1 px-2 text-right" style={{ width: '60px' }}>{item.ef.toFixed(2)}</td>
                                                                                    </tr>
                                                                                ))}
                                                                            </tbody>
                                                                        </table>
                                                                    </div>
                                                                    
                                                                    {/* Component count and propagation factor inputs */}
                                                                    <div className="mt-2 flex items-end gap-4">
                                                                        <div>
                                                                            <label className="block text-xs font-medium mb-1">How many components of this type?</label>
                                                                            <input
                                                                                type="number"
                                                                                min="1"
                                                                                step="1"
                                                                                value={event.fireIgnitionComponentCount || 1}
                                                                                onChange={(e) => handleEventChange(index, 'fireIgnitionComponentCount', Math.max(1, parseInt(e.target.value) || 1))}
                                                                                className="w-24 border rounded px-2 py-1 text-sm"
                                                                            />
                                                                        </div>
                                                                        <div>
                                                                            <label className="block text-xs font-medium mb-1">Fire propagation or adjustment factor:</label>
                                                                            <input
                                                                                type="text"
                                                                                value={event.fireIgnitionPropagationFactor !== undefined ? event.fireIgnitionPropagationFactor : 1}
                                                                                onChange={(e) => {
                                                                                    const val = e.target.value;
                                                                                    // Allow empty, partial decimals like "0." or ".", and valid numbers
                                                                                    if (val === '' || val === '.' || val === '0.' || /^-?\d*\.?\d*$/.test(val)) {
                                                                                        // Store the string value while typing to preserve partial input
                                                                                        handleEventChange(index, 'fireIgnitionPropagationFactor', val);
                                                                                    }
                                                                                }}
                                                                                onBlur={(e) => {
                                                                                    // On blur, convert to number (default to 1 if invalid or zero)
                                                                                    const val = parseFloat(e.target.value);
                                                                                    if (isNaN(val) || val <= 0) {
                                                                                        handleEventChange(index, 'fireIgnitionPropagationFactor', 1);
                                                                                    } else {
                                                                                        handleEventChange(index, 'fireIgnitionPropagationFactor', val);
                                                                                    }
                                                                                }}
                                                                                className="w-24 border rounded px-2 py-1 text-sm"
                                                                            />
                                                                        </div>
                                                                    </div>
                                                                    <p className="text-xs text-gray-600 mt-1">
                                                                        Final Frequency = (Table Frequency / # Components)  Propagation Factor
                                                                    </p>
                                                                    
                                                                    {/* Summary of selected fire ignition sources */}
                                                                    {(() => {
                                                                        const selections = event.fireIgnitionSelections || {};
                                                                        const selectedItems = NUREG2169_FIRE_IGNITION_DATA.filter(item => selections[item.bin]);
                                                                        const totalTableMean = selectedItems.reduce((sum, item) => sum + item.mean, 0);
                                                                        const componentCount = event.fireIgnitionComponentCount || 1;
                                                                        const propagationFactor = parseFloat(event.fireIgnitionPropagationFactor) || 1;
                                                                        const adjustedMean = (totalTableMean / componentCount) * propagationFactor;
                                                                        const selectedCount = selectedItems.length;
                                                                        
                                                                        return (
                                                                            <div className="mt-2 p-2 bg-orange-100 rounded text-xs">
                                                                                <strong>Selected:</strong> {selectedCount} source{selectedCount !== 1 ? 's' : ''} | 
                                                                                <strong> Table Frequency:</strong> {totalTableMean > 0 ? totalTableMean.toExponential(2) : '0.00E+00'} /yr |
                                                                                <strong> Components:</strong> {componentCount} |
                                                                                <strong> Propagation Factor:</strong> {propagationFactor} |
                                                                                <strong> Final Frequency:</strong> {adjustedMean > 0 ? adjustedMean.toExponential(2) : '0.00E+00'} /yr
                                                                            </div>
                                                                        );
                                                                    })()}
                                                                    
                                                                    <p className="text-xs text-gray-600 mt-1">
                                                                        Fire ignition frequencies are lognormally distributed with the given Mean and Error Factor (EF = 95th/50th percentile).
                                                                    </p>
                                                                </div>
                                                            )}
                                                            
                                                            <div>
                                                                <label className="block text-xs font-medium mb-1">Restoration Model:</label>
                                                                <select
                                                                    value={event.restorationModel}
                                                                    onChange={(e) => handleEventChange(index, 'restorationModel', e.target.value)}
                                                                    className="w-full border rounded px-2 py-1 text-sm"
                                                                >
                                                                    <option value="none">None</option>
                                                                    <option value="time-distribution">Restoration Time Distribution</option>
                                                                    <option value="timeline">Restoration Timeline</option>
                                                                </select>
                                                            </div>
                                                            <div>
                                                                <label className="block text-xs font-medium mb-1">Supporting Information:</label>
                                                                <div 
                                                                    className="border rounded p-3 bg-white min-h-[100px] max-h-[200px] overflow-y-auto cursor-pointer hover:bg-gray-50 text-sm"
                                                                    onClick={() => setEditingDescription(index)}
                                                                    dangerouslySetInnerHTML={{ __html: event.description || '<p class="text-gray-400">Click to edit supporting information</p>' }}
                                                                />
                                                            </div>
                                                        </div>
                                                    ) : (
                                                        <div>
                                                            <div className="flex justify-between items-start mb-2">
                                                                <div className="flex-1">
                                                                    <span className="font-semibold">{event.name}</span>
                                                                    {event.eventDescription && (
                                                                        <span className="text-sm text-gray-600 ml-2">- {event.eventDescription}</span>
                                                                    )}
                                                                </div>
                                                                <div className="flex gap-1 ml-2">
                                                                    {!isEditingEvent && (
                                                                        <button
                                                                            onClick={() => {
                                                                                setCollapsedEvents(prev => {
                                                                                    const newSet = new Set(prev);
                                                                                    if (newSet.has(index)) {
                                                                                        newSet.delete(index);
                                                                                    } else {
                                                                                        newSet.add(index);
                                                                                    }
                                                                                    return newSet;
                                                                                });
                                                                            }}
                                                                            className="px-2 py-1 bg-gray-500 text-white text-xs rounded hover:bg-gray-600"
                                                                        >
                                                                            {collapsedEvents.has(index) ? 'Expand' : 'Collapse'}
                                                                        </button>
                                                                    )}
                                                                    {!isReadOnly && !isEditingEvent && (
                                                                        <button
                                                                            onClick={() => {
                                                                                setOriginalEventData(JSON.stringify(event));
                                                                                setCollapsedEvents(prev => new Set(prev).add(index));
                                                                                setEditingEventIndex(index);
                                                                            }}
                                                                            className="px-2 py-1 bg-blue-600 text-white text-xs rounded hover:bg-blue-700"
                                                                        >
                                                                            Edit
                                                                        </button>
                                                                    )}
                                                                </div>
                                                            </div>
                                                            <div className="text-xs text-gray-600">
                                                                <div>
                                                                    Occurrence: {
                                                                        event.occurrenceModel === 'frequency' ? (
                                                                            (() => {
                                                                                if (event.frequencyDistribution === 'point' && event.pointEstimate) {
                                                                                    const value = parseFloat(event.pointEstimate);
                                                                                    return `${formatFrequency(value)} ${event.frequencyUnits || '/yr'}`;
                                                                                } else if (event.frequencyDistribution === 'gamma' && event.gammaShape && event.gammaScale) {
                                                                                    // Mean of gamma distribution = shape * scale
                                                                                    const mean = parseFloat(event.gammaShape) * parseFloat(event.gammaScale);
                                                                                    return `${formatFrequency(mean)} ${event.frequencyUnits || '/yr'} (Gamma)`;
                                                                                } else if (event.frequencyDistribution === 'lognormal' && event.lognormalMean) {
                                                                                    // Display mean value for lognormal
                                                                                    const mean = parseFloat(event.lognormalMean);
                                                                                    return `${formatFrequency(mean)} ${event.frequencyUnits || '/yr'} (Lognormal)`;
                                                                                } else if (event.frequencyDistribution === 'cni' && event.cniMean) {
                                                                                    // Display mean value for CNI
                                                                                    const mean = parseFloat(event.cniMean);
                                                                                    return `${formatFrequency(mean)} ${event.frequencyUnits || '/yr'} (CNI)`;
                                                                                } else {
                                                                                    return 'Frequency of occurrence';
                                                                                }
                                                                            })()
                                                                        ) : event.occurrenceModel === 'prob-per-opportunity' ? (
                                                                            (() => {
                                                                                let prob = null;
                                                                                const dist = event.probabilityDistribution || 'cni';
                                                                                if (dist === 'point' && event.probPointEstimate) {
                                                                                    prob = parseFloat(event.probPointEstimate);
                                                                                } else if (dist === 'beta' && event.betaShape && event.betaScale) {
                                                                                    // Mean of beta = alpha / (alpha + beta)
                                                                                    const alpha = parseFloat(event.betaShape);
                                                                                    const beta = parseFloat(event.betaScale);
                                                                                    prob = alpha / (alpha + beta);
                                                                                } else if (dist === 'lognormal' && event.probLognormalMean) {
                                                                                    prob = parseFloat(event.probLognormalMean);
                                                                                } else if (dist === 'cni' && event.probCniMean) {
                                                                                    prob = parseFloat(event.probCniMean);
                                                                                }
                                                                                const opps = parseInt(event.opportunitiesPerPeriod) || 0;
                                                                                const distName = dist === 'beta' ? 'Beta' : dist === 'lognormal' ? 'Lognormal' : dist === 'cni' ? 'CNI' : '';
                                                                                if (prob !== null && opps > 0) {
                                                                                    return `Prob/Opp: ${prob.toExponential(2)} x ${opps} opps/period (${distName})`;
                                                                                } else if (prob !== null) {
                                                                                    return `Prob/Opp: ${prob.toExponential(2)} (${distName})`;
                                                                                } else {
                                                                                    return 'Probability per Opportunity';
                                                                                }
                                                                            })()
                                                                        ) : event.occurrenceModel === 'hazard-curve' ? 'Hazard Curve' :
                                                                          event.occurrenceModel === 'nureg-2169-fire' ? (() => {
                                                                              const selections = event.fireIgnitionSelections || {};
                                                                              const selectedItems = NUREG2169_FIRE_IGNITION_DATA.filter(item => selections[item.bin]);
                                                                              const totalTableMean = selectedItems.reduce((sum, item) => sum + item.mean, 0);
                                                                              const componentCount = event.fireIgnitionComponentCount || 1;
                                                                              const propagationFactor = parseFloat(event.fireIgnitionPropagationFactor) || 1;
                                                                              const finalMean = (totalTableMean / componentCount) * propagationFactor;
                                                                              const componentInfo = componentCount > 1 ? `  ${componentCount}` : '';
                                                                              const propInfo = propagationFactor !== 1 ? `  ${propagationFactor}` : '';
                                                                              return `NUREG-2169 Fire: ${formatFrequency(finalMean)} /yr (${selectedItems.length} sources${componentInfo}${propInfo})`;
                                                                          })() :
                                                                                          event.occurrenceModel === 'screened-low-freq' ? 'Screened (low frequency)' :
                                                                          event.occurrenceModel === 'screened-low-consequence' ? 'Screened (low consequence)' :
                                                                          event.occurrenceModel === 'screened-not-applicable' ? 'Screened (not applicable)' :
                                                                          event.occurrenceModel
                                                                    }
                                                                </div>
                                                                <div>Restoration: {event.restorationModel}</div>
                                                            </div>
                                                            
                                                            {/* Expanded View - Read Only Details (shown by default, hidden when collapsed) */}
                                                            {!collapsedEvents.has(index) && (
                                                                <div className="mt-3 pt-3 border-t border-gray-300 space-y-3 bg-gray-50 p-3 rounded">
                                                                    {/* Occurrence Model Details */}
                                                                    {event.occurrenceModel === 'frequency' && (
                                                                        <div className="border rounded p-3 bg-blue-50">
                                                                            <div className="font-medium text-sm mb-2">Frequency Distribution Details</div>
                                                                            <div className="text-xs space-y-1">
                                                                                <div><strong>Distribution:</strong> {
                                                                                    event.frequencyDistribution === 'gamma' ? 'Gamma' :
                                                                                    event.frequencyDistribution === 'lognormal' ? 'Lognormal' :
                                                                                    event.frequencyDistribution === 'cni' ? 'Constrained Non-Informative (CNI)' :
                                                                                    event.frequencyDistribution === 'point' ? 'Point Estimate' : event.frequencyDistribution
                                                                                }</div>
                                                                                {event.frequencyDistribution === 'gamma' && (
                                                                                    <>
                                                                                        <div><strong>Shape ():</strong> {event.gammaShape || 'Not specified'}</div>
                                                                                        <div><strong>Scale ():</strong> {event.gammaScale || 'Not specified'}</div>
                                                                                        {event.gammaShape && event.gammaScale && (
                                                                                            <div><strong>Mean:</strong> {formatFrequency(parseFloat(event.gammaShape) * parseFloat(event.gammaScale))} {event.frequencyUnits || '/yr'}</div>
                                                                                        )}
                                                                                    </>
                                                                                )}
                                                                                {event.frequencyDistribution === 'lognormal' && (
                                                                                    <>
                                                                                        <div><strong>Mean:</strong> {event.lognormalMean || 'Not specified'}</div>
                                                                                        <div><strong>Error Factor (EF):</strong> {event.lognormalEF || 'Not specified'}</div>
                                                                                    </>
                                                                                )}
                                                                                {event.frequencyDistribution === 'cni' && (
                                                                                    <div><strong>Mean:</strong> {event.cniMean || 'Not specified'}</div>
                                                                                )}
                                                                                {event.frequencyDistribution === 'point' && (
                                                                                    <div><strong>Value:</strong> {event.pointEstimate || 'Not specified'}</div>
                                                                                )}
                                                                                <div><strong>Units:</strong> {event.frequencyUnits || '/yr'}</div>
                                                                            </div>
                                                                        </div>
                                                                    )}
                                                                    
                                                                    {event.occurrenceModel === 'prob-per-opportunity' && (
                                                                        <div className="border rounded p-3 bg-purple-50">
                                                                            <div className="font-medium text-sm mb-2">Probability per Opportunity Details</div>
                                                                            <div className="text-xs space-y-1">
                                                                                <div><strong>Opportunities per Period:</strong> {event.opportunitiesPerPeriod || 'Not specified'}</div>
                                                                                <div><strong>Distribution:</strong> {
                                                                                    event.probabilityDistribution === 'beta' ? 'Beta' :
                                                                                    event.probabilityDistribution === 'lognormal' ? 'Lognormal' :
                                                                                    event.probabilityDistribution === 'cni' ? 'Constrained Non-Informative (CNI)' :
                                                                                    event.probabilityDistribution === 'point' ? 'Point Estimate' : event.probabilityDistribution
                                                                                }</div>
                                                                                {event.probabilityDistribution === 'beta' && (
                                                                                    <>
                                                                                        <div><strong>Shape ():</strong> {event.betaShape || 'Not specified'}</div>
                                                                                        <div><strong>Scale ():</strong> {event.betaScale || 'Not specified'}</div>
                                                                                        {event.betaShape && event.betaScale && (
                                                                                            <div><strong>Mean:</strong> {(parseFloat(event.betaShape) / (parseFloat(event.betaShape) + parseFloat(event.betaScale))).toExponential(2)}</div>
                                                                                        )}
                                                                                    </>
                                                                                )}
                                                                                {event.probabilityDistribution === 'lognormal' && (
                                                                                    <>
                                                                                        <div><strong>Mean:</strong> {event.probLognormalMean || 'Not specified'}</div>
                                                                                        <div><strong>Error Factor (EF):</strong> {event.probLognormalEF || 'Not specified'}</div>
                                                                                    </>
                                                                                )}
                                                                                {event.probabilityDistribution === 'cni' && (
                                                                                    <div><strong>Mean:</strong> {event.probCniMean || 'Not specified'}</div>
                                                                                )}
                                                                                {event.probabilityDistribution === 'point' && (
                                                                                    <div><strong>Value:</strong> {event.probPointEstimate || 'Not specified'}</div>
                                                                                )}
                                                                            </div>
                                                                        </div>
                                                                    )}
                                                                    
                                                                    {event.occurrenceModel === 'hazard-curve' && (
                                                                        <div className="border rounded p-3 bg-green-50">
                                                                            <div className="font-medium text-sm mb-2">Hazard Curve Details</div>
                                                                            <div className="text-xs space-y-1">
                                                                                <div><strong>Magnitude Units:</strong> {event.hazardMagnitudeUnits || 'Not specified'}</div>
                                                                                <div><strong>Frequency Units:</strong> {event.hazardFrequencyUnits || '/yr'}</div>
                                                                                {event.hazardCurveData && event.hazardCurveData.length > 0 && (
                                                                                    <div className="mt-2">
                                                                                        <strong>Curve Data ({event.hazardCurveData.length} points):</strong>
                                                                                        <table className="mt-1 w-full border-collapse text-xs">
                                                                                            <thead>
                                                                                                <tr className="bg-gray-100">
                                                                                                    <th className="border px-2 py-1 text-left">Magnitude</th>
                                                                                                    <th className="border px-2 py-1 text-left">Frequency</th>
                                                                                                </tr>
                                                                                            </thead>
                                                                                            <tbody>
                                                                                                {event.hazardCurveData.slice(0, 10).map((row, idx) => (
                                                                                                    <tr key={idx}>
                                                                                                        <td className="border px-2 py-1">{row.magnitude || '-'}</td>
                                                                                                        <td className="border px-2 py-1">{row.frequency || '-'}</td>
                                                                                                    </tr>
                                                                                                ))}
                                                                                                {event.hazardCurveData.length > 10 && (
                                                                                                    <tr>
                                                                                                        <td colSpan="2" className="border px-2 py-1 text-center text-gray-500">
                                                                                                            ... and {event.hazardCurveData.length - 10} more rows
                                                                                                        </td>
                                                                                                    </tr>
                                                                                                )}
                                                                                            </tbody>
                                                                                        </table>
                                                                                    </div>
                                                                                )}
                                                                            </div>
                                                                        </div>
                                                                    )}
                                                                    
                                                                    {event.occurrenceModel === 'nureg-2169-fire' && (
                                                                        <div className="border rounded p-3 bg-orange-50">
                                                                            <div className="font-medium text-sm mb-2">NUREG-2169 Fire Ignition Details</div>
                                                                            <div className="text-xs space-y-1">
                                                                                {(() => {
                                                                                    const selections = event.fireIgnitionSelections || {};
                                                                                    const selectedItems = NUREG2169_FIRE_IGNITION_DATA.filter(item => selections[item.bin]);
                                                                                    const totalTableMean = selectedItems.reduce((sum, item) => sum + item.mean, 0);
                                                                                    const componentCount = event.fireIgnitionComponentCount || 1;
                                                                                    const propagationFactor = parseFloat(event.fireIgnitionPropagationFactor) || 1;
                                                                                    const finalMean = (totalTableMean / componentCount) * propagationFactor;
                                                                                    return (
                                                                                        <>
                                                                                            <div><strong>Selected Sources:</strong> {selectedItems.length}</div>
                                                                                            <div><strong>Number of Components:</strong> {componentCount}</div>
                                                                                            <div><strong>Propagation Factor:</strong> {propagationFactor}</div>
                                                                                            <div><strong>Table Frequency:</strong> {formatFrequency(totalTableMean)} /yr</div>
                                                                                            <div><strong>Final Frequency:</strong> {formatFrequency(finalMean)} /yr {(componentCount > 1 || propagationFactor !== 1) ? `(Table  ${componentCount}  ${propagationFactor})` : ''}</div>
                                                                                            {selectedItems.length > 0 && (
                                                                                                <div className="mt-2">
                                                                                                    <strong>Selected Items:</strong>
                                                                                                    <ul className="mt-1 ml-4 list-disc">
                                                                                                        {selectedItems.map(item => (
                                                                                                            <li key={item.bin}>
                                                                                                                {item.location} - {item.ignitionSource} (Mean: {formatFrequency(item.mean)}/yr, EF: {item.ef})
                                                                                                            </li>
                                                                                                        ))}
                                                                                                    </ul>
                                                                                                </div>
                                                                                            )}
                                                                                        </>
                                                                                    );
                                                                                })()}
                                                                            </div>
                                                                        </div>
                                                                    )}
                                                                    
                                                                    {(event.occurrenceModel === 'screened-low-freq' || 
                                                                      event.occurrenceModel === 'screened-low-consequence' ||
                                                                      event.occurrenceModel === 'screened-not-applicable') && (
                                                                        <div className="border rounded p-3 bg-red-50">
                                                                            <div className="font-medium text-sm mb-2">Screening Information</div>
                                                                            <div className="text-xs">
                                                                                <div><strong>Reason:</strong> {
                                                                                    event.occurrenceModel === 'screened-low-freq' ? 'Screened due to low frequency' :
                                                                                    event.occurrenceModel === 'screened-low-consequence' ? 'Screened due to low consequence' :
                                                                                    'Screened due to not being applicable'
                                                                                }</div>
                                                                            </div>
                                                                        </div>
                                                                    )}
                                                                    
                                                                    {/* Restoration Model */}
                                                                    <div className="border rounded p-3 bg-gray-100">
                                                                        <div className="font-medium text-sm mb-2">Restoration Model</div>
                                                                        <div className="text-xs">
                                                                            <strong>Model:</strong> {event.restorationModel || 'none'}
                                                                        </div>
                                                                    </div>
                                                                    
                                                                    {/* Supporting Information Preview */}
                                                                    {event.description && (
                                                                        <div className="border rounded p-3 bg-white">
                                                                            <div className="font-medium text-sm mb-2">Supporting Information</div>
                                                                            <div 
                                                                                className="text-xs rich-text-editor"
                                                                                style={{ minHeight: 'auto', maxHeight: '200px', overflowY: 'auto', padding: '8px', border: '1px solid #e5e7eb', borderRadius: '4px' }}
                                                                                dangerouslySetInnerHTML={{ __html: event.description }}
                                                                            />
                                                                        </div>
                                                                    )}
                                                                </div>
                                                            )}
                                                        </div>
                                                    )}
                                                </div>
                                            );
                                        })
                                    ) : (
                                        <div className="text-sm text-gray-500 text-center py-4">
                                            No applicable events added yet.
                                        </div>
                                    )}
                                </div>
                            </div>

                            {/* Status */}
                            <div className="mb-4 flex-shrink-0">
                                <label className="block text-sm font-medium mb-2">Evaluation Status:</label>
                                <select
                                    value={status}
                                    onChange={(e) => setStatus(e.target.value)}
                                    className="w-full border rounded px-3 py-2"
                                    disabled={isReadOnly || isEditingEvent}
                                >
                                    <option value="unanalyzed">Unanalyzed</option>
                                    <option value="included">Included in Scope</option>
                                    <option value="screened">Screened</option>
                                </select>
                            </div>

                            {/* Action Buttons */}
                            <div className="flex gap-3 justify-end border-t pt-3 flex-shrink-0">
                                <button
                                    onClick={onClose}
                                    className="px-4 py-2 border rounded hover:bg-gray-100 disabled:bg-gray-200 disabled:text-gray-400 disabled:cursor-not-allowed disabled:hover:bg-gray-200"
                                    disabled={isEditingEvent}
                                >
                                    Cancel
                                </button>
                                <button
                                    onClick={handleSave}
                                    className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed"
                                    disabled={isEditingEvent}
                                >
                                    Save
                                </button>
                            </div>
                        </div>
                    </div>

                    {/* Description Editor Modal */}
                    {editingDescription !== null && (
                        <RichTextEditor
                            value={applicableEvents[editingDescription].description}
                            onChange={(html) => {
                                handleEventChange(editingDescription, 'description', html);
                                setEditingDescription(null);
                            }}
                            onClose={() => setEditingDescription(null)}
                            title={`Edit Supporting Information for ${hazardName}`}
                        />
                    )}
                </div>
            );
        }

        // Modify Hazard List Component
        function ModifyHazardListModal({ hazardList, onSave, onClose }) {
            const [localList, setLocalList] = useState(JSON.parse(JSON.stringify(hazardList))); // Deep clone
            const [editingNode, setEditingNode] = useState(null);
            const [expandedNodes, setExpandedNodes] = useState(new Set());

            const toggleExpand = (nodeId) => {
                const newExpanded = new Set(expandedNodes);
                if (newExpanded.has(nodeId)) {
                    newExpanded.delete(nodeId);
                } else {
                    newExpanded.add(nodeId);
                }
                setExpandedNodes(newExpanded);
            };

            const findNodeById = (nodes, id) => {
                for (const node of nodes) {
                    if (node.id === id) return node;
                    if (node.children) {
                        const found = findNodeById(node.children, id);
                        if (found) return found;
                    }
                }
                return null;
            };

            const removeNode = (nodes, id) => {
                return nodes.filter(node => {
                    if (node.id === id) return false;
                    if (node.children) {
                        node.children = removeNode(node.children, id);
                    }
                    return true;
                });
            };

            const toggleHideNode = (nodes, id) => {
                return nodes.map(node => {
                    if (node.id === id) {
                        return { ...node, hidden: !node.hidden };
                    }
                    if (node.children) {
                        return { ...node, children: toggleHideNode(node.children, id) };
                    }
                    return node;
                });
            };

            const updateNodeName = (nodes, id, newName) => {
                return nodes.map(node => {
                    if (node.id === id) {
                        return { ...node, name: newName };
                    }
                    if (node.children) {
                        return { ...node, children: updateNodeName(node.children, id, newName) };
                    }
                    return node;
                });
            };

            const handleRemove = (nodeId) => {
                if (confirm('Remove this hazard and all its children?')) {
                    setLocalList(removeNode(localList, nodeId));
                }
            };

            const handleToggleHide = (nodeId) => {
                setLocalList(toggleHideNode(localList, nodeId));
            };

            const handleEdit = (nodeId) => {
                const node = findNodeById(localList, nodeId);
                if (node) {
                    setEditingNode({ id: nodeId, name: node.name });
                }
            };

            const handleSaveEdit = () => {
                if (editingNode && editingNode.name.trim()) {
                    setLocalList(updateNodeName(localList, editingNode.id, editingNode.name.trim()));
                    setEditingNode(null);
                }
            };

            const handleSave = () => {
                onSave(localList);
                onClose();
            };

            const renderNode = (node, level) => {
                const hasChildren = node.children && node.children.length > 0;
                const isExpanded = expandedNodes.has(node.id);
                const isEditing = editingNode && editingNode.id === node.id;

                return (
                    <div key={node.id}>
                        <div 
                            className="flex items-center gap-2 py-1 px-2 hover:bg-gray-100"
                            style={{ paddingLeft: `${level * 20 + 8}px`, opacity: node.hidden ? 0.5 : 1 }}
                        >
                            {hasChildren && (
                                <span 
                                    onClick={() => toggleExpand(node.id)}
                                    className="cursor-pointer select-none w-4"
                                >
                                    {isExpanded ? '\u25BC' : '\u25B6'}
                                </span>
                            )}
                            {!hasChildren && <span className="w-4"></span>}
                            
                            {isEditing ? (
                                <input
                                    type="text"
                                    value={editingNode.name}
                                    onChange={(e) => setEditingNode({ ...editingNode, name: e.target.value })}
                                    className="flex-1 border rounded px-2 py-1 text-sm"
                                    autoFocus
                                />
                            ) : (
                                <span className="flex-1">{node.name}</span>
                            )}
                            
                            <div className="flex gap-1">
                                {isEditing ? (
                                    <>
                                        <button
                                            onClick={handleSaveEdit}
                                            className="px-2 py-1 bg-green-600 text-white text-xs rounded hover:bg-green-700"
                                        >
                                            Save
                                        </button>
                                        <button
                                            onClick={() => setEditingNode(null)}
                                            className="px-2 py-1 bg-gray-600 text-white text-xs rounded hover:bg-gray-700"
                                        >
                                            Cancel
                                        </button>
                                    </>
                                ) : (
                                    <>
                                        <button
                                            onClick={() => handleEdit(node.id)}
                                            className="px-2 py-1 bg-blue-600 text-white text-xs rounded hover:bg-blue-700"
                                            title="Edit name"
                                        >
                                            Edit
                                        </button>
                                        <button
                                            onClick={() => handleToggleHide(node.id)}
                                            className="px-2 py-1 bg-yellow-600 text-white text-xs rounded hover:bg-yellow-700"
                                            title={node.hidden ? "Show" : "Hide"}
                                        >
                                            {node.hidden ? 'Show' : 'Hide'}
                                        </button>
                                        <button
                                            onClick={() => handleRemove(node.id)}
                                            className="px-2 py-1 bg-red-600 text-white text-xs rounded hover:bg-red-700"
                                            title="Remove"
                                        >
                                            Remove
                                        </button>
                                    </>
                                )}
                            </div>
                        </div>
                        {hasChildren && isExpanded && (
                            <div>
                                {node.children.map(child => renderNode(child, level + 1))}
                            </div>
                        )}
                    </div>
                );
            };

            return (
                <div className="modal-overlay">
                    <div className="modal-content" style={{ maxWidth: '800px', backgroundColor: '#ffffff', color: '#111827' }}>
                        <div className="p-4">
                            <h2 className="text-xl font-bold mb-4">Modify Hazard List</h2>
                            
                            <div className="mb-4 text-sm text-gray-600">
                                <p><strong>Edit:</strong> Change the hazard name</p>
                                <p><strong>Hide:</strong> Hide the hazard from the main view (can be shown later)</p>
                                <p><strong>Remove:</strong> Permanently delete the hazard and all its children</p>
                            </div>

                            <div className="border rounded p-2 max-h-[500px] overflow-y-auto mb-4">
                                {localList.length > 0 ? (
                                    localList.map(node => renderNode(node, 0))
                                ) : (
                                    <div className="text-center text-gray-500 py-4">
                                        No hazards in list
                                    </div>
                                )}
                            </div>

                            <div className="flex gap-3 justify-end">
                                <button
                                    onClick={onClose}
                                    className="px-4 py-2 border rounded hover:bg-gray-100"
                                >
                                    Cancel
                                </button>
                                <button
                                    onClick={handleSave}
                                    className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
                                >
                                    Save Changes
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        // Settings Modal Component
        function SettingsModal({ settings, onSave, onClose }) {
            const [localSettings, setLocalSettings] = useState(settings);

            const handleChange = (key, value) => {
                setLocalSettings(prev => ({ ...prev, [key]: value }));
            };

            const handleColorChange = (stateId, color) => {
                const newColors = { ...localSettings.stateColors, [stateId]: color };
                setLocalSettings(prev => ({ ...prev, stateColors: newColors }));
            };

            const handleSave = () => {
                onSave(localSettings);
                onClose();
            };

            return (
                <div className="modal-overlay">
                    <div className="modal-content" style={{ maxWidth: '600px', backgroundColor: '#ffffff', color: '#111827' }}>
                        <div className="p-4">
                            <h2 className="text-xl font-bold mb-4">Project Settings</h2>
                            
                            <div className="space-y-4 mb-6">
                                {/* Text Font Size */}
                                <div>
                                    <label className="block text-sm font-medium mb-2">Text Font Size:</label>
                                    <div className="flex gap-2">
                                        {[
                                            { value: 'small', label: 'Small' },
                                            { value: 'medium', label: 'Medium' },
                                            { value: 'large', label: 'Large' }
                                        ].map(size => (
                                            <button
                                                key={size.value}
                                                onClick={() => handleChange('fontSize', size.value)}
                                                className={`flex-1 px-4 py-2 rounded border ${
                                                    localSettings.fontSize === size.value
                                                        ? 'bg-blue-600 text-white border-blue-600'
                                                        : 'bg-white text-gray-700 border-gray-300 hover:bg-gray-100'
                                                }`}
                                            >
                                                {size.label}
                                            </button>
                                        ))}
                                    </div>
                                </div>

                                {/* Font Family */}
                                <div>
                                    <label className="block text-sm font-medium mb-2">Font Family:</label>
                                    <div className="flex gap-2">
                                        {[
                                            { value: 'sans-serif', label: 'Sans-serif' },
                                            { value: 'serif', label: 'Serif' },
                                            { value: 'monospace', label: 'Monospaced' }
                                        ].map(font => (
                                            <button
                                                key={font.value}
                                                onClick={() => handleChange('fontFamily', font.value)}
                                                className={`flex-1 px-4 py-2 rounded border ${
                                                    localSettings.fontFamily === font.value
                                                        ? 'bg-blue-600 text-white border-blue-600'
                                                        : 'bg-white text-gray-700 border-gray-300 hover:bg-gray-100'
                                                }`}
                                            >
                                                {font.label}
                                            </button>
                                        ))}
                                    </div>
                                </div>

                                {/* Background */}
                                <div>
                                    <label className="block text-sm font-medium mb-2">Background:</label>
                                    <div className="flex gap-2">
                                        {[
                                            { value: 'white', label: 'White' },
                                            { value: 'black', label: 'Black' },
                                            { value: 'grey', label: 'Grey' }
                                        ].map(bg => (
                                            <button
                                                key={bg.value}
                                                onClick={() => handleChange('background', bg.value)}
                                                className={`flex-1 px-4 py-2 rounded border ${
                                                    localSettings.background === bg.value
                                                        ? 'bg-blue-600 text-white border-blue-600'
                                                        : 'bg-white text-gray-700 border-gray-300 hover:bg-gray-100'
                                                }`}
                                            >
                                                {bg.label}
                                            </button>
                                        ))}
                                    </div>
                                </div>

                                {/* Show Digits */}
                                <div>
                                    <label className="block text-sm font-medium mb-2">Show Digits:</label>
                                    <div className="flex gap-2">
                                        {[
                                            { value: 0, label: '0 Digits' },
                                            { value: 1, label: '1 Digit' },
                                            { value: 2, label: '2 Digits' }
                                        ].map(option => (
                                            <button
                                                key={option.value}
                                                onClick={() => handleChange('frequencyDigits', option.value)}
                                                className={`flex-1 px-4 py-2 rounded border ${
                                                    localSettings.frequencyDigits === option.value
                                                        ? 'bg-blue-600 text-white border-blue-600'
                                                        : 'bg-white text-gray-700 border-gray-300 hover:bg-gray-100'
                                                }`}
                                            >
                                                {option.label}
                                            </button>
                                        ))}
                                    </div>
                                </div>

                                <div>
                                    <label className="block text-sm font-medium mb-2">Hazard Frequency Plot:</label>
                                    <div className="flex gap-4">
                                        <div className="flex-1">
                                            <label className="block text-xs text-gray-600 mb-1">Minimum Frequency (/yr):</label>
                                            <select
                                                value={localSettings.hazardPlot?.minFrequency || 1e-7}
                                                onChange={(e) => setLocalSettings(prev => ({
                                                    ...prev,
                                                    hazardPlot: {
                                                        ...prev.hazardPlot,
                                                        minFrequency: parseFloat(e.target.value)
                                                    }
                                                }))}
                                                className="w-full border rounded px-3 py-2"
                                            >
                                                <option value={1e0}>1E0</option>
                                                <option value={1e-1}>1E-1</option>
                                                <option value={1e-2}>1E-2</option>
                                                <option value={1e-3}>1E-3</option>
                                                <option value={1e-4}>1E-4</option>
                                                <option value={1e-5}>1E-5</option>
                                                <option value={1e-6}>1E-6</option>
                                                <option value={1e-7}>1E-7</option>
                                                <option value={1e-8}>1E-8</option>
                                            </select>
                                        </div>
                                        <div className="flex-1">
                                            <label className="block text-xs text-gray-600 mb-1">Maximum Frequency (/yr):</label>
                                            <select
                                                value={localSettings.hazardPlot?.maxFrequency || 1e0}
                                                onChange={(e) => setLocalSettings(prev => ({
                                                    ...prev,
                                                    hazardPlot: {
                                                        ...prev.hazardPlot,
                                                        maxFrequency: parseFloat(e.target.value)
                                                    }
                                                }))}
                                                className="w-full border rounded px-3 py-2"
                                            >
                                                <option value={1e0}>1E0</option>
                                                <option value={1e-1}>1E-1</option>
                                                <option value={1e-2}>1E-2</option>
                                                <option value={1e-3}>1E-3</option>
                                                <option value={1e-4}>1E-4</option>
                                                <option value={1e-5}>1E-5</option>
                                                <option value={1e-6}>1E-6</option>
                                                <option value={1e-7}>1E-7</option>
                                                <option value={1e-8}>1E-8</option>
                                            </select>
                                        </div>
                                    </div>
                                </div>

                                <div>
                                    <label className="block text-sm font-medium mb-2">Operating State Colors:</label>
                                    <div className="space-y-2">
                                        {DEFAULT_OPERATING_STATES.map(state => (
                                            <div key={state.id} className="flex items-center gap-3">
                                                <span className="text-sm font-medium w-32">{state.id}:</span>
                                                <input
                                                    type="color"
                                                    value={localSettings.stateColors?.[state.id] || state.color}
                                                    onChange={(e) => handleColorChange(state.id, e.target.value)}
                                                    className="w-16 h-8 border rounded cursor-pointer"
                                                />
                                                <span className="text-sm text-gray-600">{state.name}</span>
                                            </div>
                                        ))}
                                    </div>
                                </div>

                                {/* Hazard Categorization Settings */}
                                <div>
                                    <label className="block text-sm font-medium mb-2">Show Hazard Categorization:</label>
                                    <div className="flex gap-2 mb-3">
                                        {[
                                            { value: true, label: 'Yes' },
                                            { value: false, label: 'No' }
                                        ].map(option => (
                                            <button
                                                key={String(option.value)}
                                                onClick={() => handleChange('showHazardCategorization', option.value)}
                                                className={`flex-1 px-4 py-2 rounded border ${
                                                    localSettings.showHazardCategorization === option.value
                                                        ? 'bg-blue-600 text-white border-blue-600'
                                                        : 'bg-white text-gray-700 border-gray-300 hover:bg-gray-100'
                                                }`}
                                            >
                                                {option.label}
                                            </button>
                                        ))}
                                    </div>
                                    
                                    {localSettings.showHazardCategorization && (
                                        <div className="border rounded p-3 bg-gray-50">
                                            <label className="block text-xs font-medium mb-2 text-gray-600">Hazard Categories:</label>
                                            <div className="space-y-2">
                                                {(localSettings.hazardCategories || []).map((cat, index) => (
                                                    <div key={index} className="flex items-center gap-2 text-xs">
                                                        <input
                                                            type="text"
                                                            value={cat.name}
                                                            onChange={(e) => {
                                                                const newCats = [...localSettings.hazardCategories];
                                                                newCats[index] = { ...newCats[index], name: e.target.value };
                                                                handleChange('hazardCategories', newCats);
                                                            }}
                                                            className="flex-1 border rounded px-2 py-1"
                                                            placeholder="Category name"
                                                        />
                                                        <input
                                                            type="text"
                                                            value={cat.rangeText}
                                                            onChange={(e) => {
                                                                const newCats = [...localSettings.hazardCategories];
                                                                newCats[index] = { ...newCats[index], rangeText: e.target.value };
                                                                handleChange('hazardCategories', newCats);
                                                            }}
                                                            className="w-32 border rounded px-2 py-1"
                                                            placeholder="Range text"
                                                        />
                                                        <input
                                                            type="text"
                                                            value={cat.highBound === Infinity ? 'Infinity' : cat.highBound}
                                                            onChange={(e) => {
                                                                const newCats = [...localSettings.hazardCategories];
                                                                const val = e.target.value.toLowerCase() === 'infinity' ? Infinity : parseFloat(e.target.value);
                                                                newCats[index] = { ...newCats[index], highBound: val };
                                                                handleChange('hazardCategories', newCats);
                                                            }}
                                                            className="w-20 border rounded px-2 py-1"
                                                            placeholder="High"
                                                            title="High bound"
                                                        />
                                                        <span className="text-gray-500">to</span>
                                                        <input
                                                            type="text"
                                                            value={cat.lowBound}
                                                            onChange={(e) => {
                                                                const newCats = [...localSettings.hazardCategories];
                                                                newCats[index] = { ...newCats[index], lowBound: parseFloat(e.target.value) || 0 };
                                                                handleChange('hazardCategories', newCats);
                                                            }}
                                                            className="w-20 border rounded px-2 py-1"
                                                            placeholder="Low"
                                                            title="Low bound"
                                                        />
                                                        <button
                                                            onClick={() => {
                                                                const newCats = localSettings.hazardCategories.filter((_, i) => i !== index);
                                                                handleChange('hazardCategories', newCats);
                                                            }}
                                                            className="px-2 py-1 text-red-600 hover:bg-red-100 rounded"
                                                            title="Remove category"
                                                        >
                                                            \u2715
                                                        </button>
                                                    </div>
                                                ))}
                                                <button
                                                    onClick={() => {
                                                        const newCats = [...(localSettings.hazardCategories || []), 
                                                            { name: 'New Category', lowBound: 0, highBound: 1e-8, rangeText: '< 1E-8/yr' }
                                                        ];
                                                        handleChange('hazardCategories', newCats);
                                                    }}
                                                    className="text-xs text-blue-600 hover:text-blue-800"
                                                >
                                                    + Add Category
                                                </button>
                                            </div>
                                        </div>
                                    )}
                                </div>
                            </div>
                            
                            <div className="flex gap-3 justify-end">
                                <button
                                    onClick={onClose}
                                    className="px-4 py-2 border rounded hover:bg-gray-100"
                                >
                                    Cancel
                                </button>
                                <button
                                    onClick={handleSave}
                                    className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
                                >
                                    Save
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        // Tree Node Component
        function TreeNode({ node, level, hazardStates, onToggle, onStateChange }) {
            const [expanded, setExpanded] = useState(true);
            const hasChildren = node.children && node.children.length > 0;

            return (
                <div>
                    <div 
                        className="tree-node flex items-center"
                        style={{ paddingLeft: `${level * 20}px` }}
                    >
                        {hasChildren && (
                            <span 
                                onClick={() => setExpanded(!expanded)}
                                className="mr-2 cursor-pointer select-none"
                                style={{ width: '20px', display: 'inline-block' }}
                            >
                                {expanded ? '\u25BC' : '\u25B6'}
                            </span>
                        )}
                        {!hasChildren && <span style={{ width: '20px', display: 'inline-block' }}></span>}
                        <span className="font-medium">{node.name}</span>
                    </div>
                    
                    {expanded && hasChildren && (
                        <div>
                            {node.children.map((child, index) => (
                                <TreeNode
                                    key={index}
                                    node={child}
                                    level={level + 1}
                                    hazardStates={hazardStates}
                                    onToggle={onToggle}
                                    onStateChange={onStateChange}
                                />
                            ))}
                        </div>
                    )}
                </div>
            );
        }

        // Operating State Editor Modal Component
        function OperatingStateEditor({ stateId, stateData, defaultState, onSave, onClose }) {
            const editorRef = useRef(null);
            const [name, setName] = useState(stateData?.name || defaultState.name);
            const [description, setDescription] = useState(stateData?.description || defaultState.description);
            const [extendedDescription, setExtendedDescription] = useState(stateData?.extendedDescription || '');

            useEffect(() => {
                if (editorRef.current) {
                    editorRef.current.innerHTML = extendedDescription;
                }
            }, []);

            const execCommand = (command, value = null) => {
                if (editorRef.current) {
                    editorRef.current.focus();
                }
                
                if (command === 'formatBlock') {
                    document.execCommand('formatBlock', false, value);
                } else {
                    document.execCommand(command, false, value);
                }
                
                if (editorRef.current) {
                    setExtendedDescription(editorRef.current.innerHTML);
                }
            };

            const handleSave = () => {
                const editorContent = editorRef.current ? editorRef.current.innerHTML : extendedDescription;
                onSave(stateId, {
                    name,
                    description,
                    extendedDescription: editorContent
                });
                onClose();
            };

            return (
                <div className="modal-overlay">
                    <div className="modal-content" style={{ maxWidth: '700px', backgroundColor: '#ffffff', color: '#111827' }}>
                        <div className="p-4">
                            <h2 className="text-xl font-bold mb-4">Edit Operating State: {stateId}</h2>
                            
                            <div className="space-y-4">
                                <div>
                                    <label className="block text-sm font-medium mb-1">Name</label>
                                    <input
                                        type="text"
                                        value={name}
                                        onChange={(e) => setName(e.target.value)}
                                        className="w-full border rounded px-3 py-2"
                                        placeholder="Operating state name"
                                    />
                                </div>
                                
                                <div>
                                    <label className="block text-sm font-medium mb-1">Description</label>
                                    <textarea
                                        value={description}
                                        onChange={(e) => setDescription(e.target.value)}
                                        className="w-full border rounded px-3 py-2"
                                        rows={2}
                                        placeholder="Brief description of this operating state"
                                    />
                                </div>
                                
                                <div>
                                    <label className="block text-sm font-medium mb-1">Extended Description</label>
                                    <div className="border rounded">
                                        <div className="rich-text-toolbar">
                                            <button className="toolbar-button" onClick={() => execCommand('bold')} title="Bold">
                                                <strong>B</strong>
                                            </button>
                                            <button className="toolbar-button" onClick={() => execCommand('italic')} title="Italic">
                                                <em>I</em>
                                            </button>
                                            <button className="toolbar-button" onClick={() => execCommand('underline')} title="Underline">
                                                <u>U</u>
                                            </button>
                                            <button className="toolbar-button" onClick={() => execCommand('formatBlock', 'h1')} title="Heading 1">
                                                H1
                                            </button>
                                            <button className="toolbar-button" onClick={() => execCommand('formatBlock', 'h2')} title="Heading 2">
                                                H2
                                            </button>
                                            <button className="toolbar-button" onClick={() => execCommand('formatBlock', 'h3')} title="Heading 3">
                                                H3
                                            </button>
                                            <button className="toolbar-button" onClick={() => execCommand('formatBlock', 'p')} title="Paragraph">
                                                P
                                            </button>
                                            <button className="toolbar-button" onClick={() => execCommand('insertUnorderedList')} title="Bullet List">
                                                &#8226; List
                                            </button>
                                            <button className="toolbar-button" onClick={() => execCommand('insertOrderedList')} title="Numbered List">
                                                1. List
                                            </button>
                                        </div>
                                        <div
                                            ref={editorRef}
                                            contentEditable
                                            className="rich-text-editor"
                                            style={{ minHeight: '200px', maxHeight: '300px', overflowY: 'auto' }}
                                            onInput={(e) => setExtendedDescription(e.target.innerHTML)}
                                        />
                                    </div>
                                </div>
                            </div>
                            
                            <div className="flex gap-3 justify-end mt-6">
                                <button
                                    onClick={onClose}
                                    className="px-4 py-2 border rounded hover:bg-gray-100"
                                >
                                    Cancel
                                </button>
                                <button
                                    onClick={handleSave}
                                    className="px-4 py-2 bg-blue-600 text-white rounded hover:bg-blue-700"
                                >
                                    Save
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        // Main Application Component
        function App() {
            const [facilityName, setFacilityName] = useState('');
            const [extendedDescription, setExtendedDescription] = useState('');
            const [operatingSchedule, setOperatingSchedule] = useState({
                periodYears: 1,
                periods: [{ stateId: 'FOS-1', startDay: 0, endDay: 365 }]
            });
            const [hazardList, setHazardList] = useState([]);
            const [hazardStates, setHazardStates] = useState({});
            const [hazardAnalysisData, setHazardAnalysisData] = useState({}); // Stores detailed analysis for each hazard/state
            const [operatingStateData, setOperatingStateData] = useState({}); // Stores custom name, description, extendedDescription for each state
            const [editingHazard, setEditingHazard] = useState(null); // { hazardId, hazardName, stateId }
            const [editingOperatingState, setEditingOperatingState] = useState(null); // state id being edited
            const [showModifyHazardList, setShowModifyHazardList] = useState(false);
            const [showExportModal, setShowExportModal] = useState(false);
            const [loadedFileName, setLoadedFileName] = useState('');
            const [paneAHeight, setPaneAHeight] = useState(22);
            const [showDescEditor, setShowDescEditor] = useState(false);
            const [showScheduleEditor, setShowScheduleEditor] = useState(false);
            const [showSettings, setShowSettings] = useState(false);
            const [showHazardPlot, setShowHazardPlot] = useState(false);
            const [settings, setSettings] = useState({ 
                background: 'grey',
                fontSize: 'medium',
                fontFamily: 'sans-serif',
                frequencyDigits: 2,
                stateColors: {
                    'FOS-1': '#93c5fd',
                    'FOS-2': '#fca5a5',
                    'FOS-3': '#fde047',
                    'FOS-4': '#c4b5fd'
                },
                hazardPlot: {
                    minFrequency: 1e-7,
                    maxFrequency: 1e0
                },
                showHazardCategorization: true,
                hazardCategories: [
                    { name: 'Anticipated', lowBound: 1e-2, highBound: Infinity, rangeText: '> 1E-2/yr' },
                    { name: 'Unlikely', lowBound: 1e-4, highBound: 1e-2, rangeText: '1E-2 to 1E-4' },
                    { name: 'Extremely Unlikely', lowBound: 1e-6, highBound: 1e-4, rangeText: '1E-4 to 1E-6' },
                    { name: 'Beyond Extremely Unlikely', lowBound: 0, highBound: 1e-6, rangeText: '< 1E-6/yr' }
                ]
            });
            
            const resizerRef = useRef(null);
            const containerRef = useRef(null);

            // Check if any data has been entered (to enable/disable buttons)
            const hasData = facilityName.length > 0 || 
                           extendedDescription.length > 0 || 
                           hazardList.length > 0 || 
                           operatingSchedule.periods.length > 1 ||
                           (operatingSchedule.periods.length === 1 && operatingSchedule.periods[0].endDay !== 365);

            // Format frequency based on settings
            const formatFrequency = (value) => {
                if (value === null || value === undefined) return '';
                const digits = settings.frequencyDigits !== undefined ? settings.frequencyDigits : 2;
                return value.toExponential(digits);
            };

            // Load settings from localStorage on mount
            useEffect(() => {
                try {
                    const saved = localStorage.getItem('KUREAS_HA_settings');
                    if (saved) {
                        const loadedSettings = JSON.parse(saved);
                        // Default hazard categories
                        const defaultCategories = [
                            { name: 'Anticipated', lowBound: 1e-2, highBound: Infinity, rangeText: '> 1E-2/yr' },
                            { name: 'Unlikely', lowBound: 1e-4, highBound: 1e-2, rangeText: '1E-2 to 1E-4' },
                            { name: 'Extremely Unlikely', lowBound: 1e-6, highBound: 1e-4, rangeText: '1E-4 to 1E-6' },
                            { name: 'Beyond Extremely Unlikely', lowBound: 0, highBound: 1e-6, rangeText: '< 1E-6/yr' }
                        ];
                        // Ensure defaults are set for any missing values
                        setSettings({
                            fontSize: loadedSettings.fontSize || 'medium',
                            fontFamily: loadedSettings.fontFamily || 'sans-serif',
                            background: loadedSettings.background || 'grey',
                            frequencyDigits: loadedSettings.frequencyDigits !== undefined ? loadedSettings.frequencyDigits : 2,
                            stateColors: loadedSettings.stateColors || {
                                'FOS-1': '#93c5fd',
                                'FOS-2': '#fca5a5',
                                'FOS-3': '#fde047',
                                'FOS-4': '#c4b5fd'
                            },
                            hazardPlot: loadedSettings.hazardPlot || {
                                minFrequency: 1e-7,
                                maxFrequency: 1e0
                            },
                            showHazardCategorization: loadedSettings.showHazardCategorization !== undefined ? loadedSettings.showHazardCategorization : true,
                            hazardCategories: loadedSettings.hazardCategories || defaultCategories
                        });
                    }
                } catch (err) {
                    console.error('Failed to load settings:', err);
                }
            }, []);

            // Track if there are unsaved changes
            const [hasUnsavedChanges, setHasUnsavedChanges] = useState(false);
            const [lastSavedState, setLastSavedState] = useState('');

            // Update unsaved changes flag when data changes
            useEffect(() => {
                const currentState = JSON.stringify({
                    facilityName,
                    extendedDescription,
                    operatingSchedule,
                    operatingStateData,
                    hazardList,
                    hazardStates,
                    hazardAnalysisData
                });
                
                if (lastSavedState && currentState !== lastSavedState) {
                    setHasUnsavedChanges(true);
                } else if (!lastSavedState) {
                    setLastSavedState(currentState);
                }
            }, [facilityName, extendedDescription, operatingSchedule, operatingStateData, hazardList, hazardStates, hazardAnalysisData]);

            // Add beforeunload listener to warn about unsaved changes
            useEffect(() => {
                const handleBeforeUnload = (e) => {
                    if (hasUnsavedChanges) {
                        e.preventDefault();
                        e.returnValue = 'You have unsaved changes. Are you sure you want to leave?';
                        return e.returnValue;
                    }
                };

                window.addEventListener('beforeunload', handleBeforeUnload);

                return () => {
                    window.removeEventListener('beforeunload', handleBeforeUnload);
                };
            }, [hasUnsavedChanges]);

            const handleSaveSettings = (newSettings) => {
                setSettings(newSettings);
                try {
                    localStorage.setItem('KUREAS_HA_settings', JSON.stringify(newSettings));
                } catch (err) {
                    console.error('Failed to save settings:', err);
                }
            };

            // Get background style
            const getBackgroundStyle = () => {
                switch (settings.background) {
                    case 'black':
                        return { backgroundColor: '#1f2937', color: '#f9fafb' };
                    case 'grey':
                        return { backgroundColor: '#e5e7eb', color: '#111827' };
                    default:
                        return { backgroundColor: '#ffffff', color: '#111827' };
                }
            };

            const backgroundStyle = getBackgroundStyle();

            // Get font size class
            const getFontSizeClass = () => {
                switch (settings.fontSize) {
                    case 'small': return 'text-sm';
                    case 'large': return 'text-lg';
                    default: return 'text-base';
                }
            };

            // Get font family style
            const getFontFamily = () => {
                switch (settings.fontFamily) {
                    case 'serif': return 'Georgia, serif';
                    case 'monospace': return '"Courier New", monospace';
                    default: return '-apple-system, BlinkMacSystemFont, "Segoe UI", "Roboto", "Oxygen", "Ubuntu", "Cantarell", "Fira Sans", "Droid Sans", "Helvetica Neue", sans-serif';
                }
            };

            // Calculate the maximum text width needed for hazard names
            const calculateHazardColumnWidth = () => {
                if (hazardList.length === 0) return 300;
                
                let maxWidth = 200; // minimum width
                
                const measureText = (text, level) => {
                    // Rough estimation: each character is ~8px, plus indentation
                    const indentation = level * 20 + 8;
                    const textWidth = text.length * 8;
                    return indentation + textWidth;
                };
                
                const traverse = (nodes, level) => {
                    nodes.forEach(node => {
                        const width = measureText(node.name, level);
                        if (width > maxWidth) {
                            maxWidth = width;
                        }
                        if (node.children && node.children.length > 0) {
                            traverse(node.children, level + 1);
                        }
                    });
                };
                
                traverse(hazardList, 0);
                
                // Add margin
                return Math.min(maxWidth + 40, 600); // cap at 600px
            };

            const handleSaveModifiedHazardList = (modifiedList) => {
                setHazardList(modifiedList);
                window.currentHazardList = modifiedList;
            };

            // Filter out hidden hazards for display
            const getVisibleHazards = (nodes) => {
                return nodes.filter(node => !node.hidden).map(node => ({
                    ...node,
                    children: node.children ? getVisibleHazards(node.children) : []
                }));
            };

            const calculateHazardFrequency = (hazardId) => {
                const frequencies = [];
                let hasHazardCurve = false;
                let curveMin = Infinity;
                let curveMax = -Infinity;
                
                // Calculate operating periods per year for each state
                const getOperatingPeriodsPerYear = (stateId) => {
                    const totalDays = (operatingSchedule.periodYears || 1) * 365;
                    const periods = operatingSchedule.periods || [];
                    
                    // Count how many separate periods of this state exist
                    let periodCount = 0;
                    periods.forEach(period => {
                        if (period.stateId === stateId) {
                            periodCount++;
                        }
                    });
                    
                    // Scale to per-year basis
                    const periodsPerYear = periodCount / (operatingSchedule.periodYears || 1);
                    return periodsPerYear;
                };
                
                // Helper function to get the effective events for a state
                // (either its own events or events from a referenced state via useInfoFrom)
                const getEffectiveEvents = (stateId) => {
                    const key = `${hazardId}_${stateId}`;
                    const analysisData = hazardAnalysisData[key];
                    
                    if (!analysisData) return null;
                    
                    // Check if this state uses info from another state
                    if (analysisData.useInfoFrom && analysisData.useInfoFrom !== '') {
                        const sourceKey = `${hazardId}_${analysisData.useInfoFrom}`;
                        const sourceData = hazardAnalysisData[sourceKey];
                        return sourceData ? sourceData.applicableEvents : null;
                    }
                    
                    return analysisData.applicableEvents;
                };
                
                DEFAULT_OPERATING_STATES.forEach(state => {
                    const key = `${hazardId}_${state.id}`;
                    const stateValue = hazardStates[key];
                    const analysisData = hazardAnalysisData[key];
                    
                    // Only consider included states
                    if (stateValue === 'included') {
                        // Get the effective events (own or from referenced state)
                        const effectiveEvents = getEffectiveEvents(state.id);
                        
                        if (effectiveEvents && effectiveEvents.length > 0) {
                            effectiveEvents.forEach(event => {
                                if (event.occurrenceModel === 'frequency') {
                                    let freq = null;
                                    
                                    if (event.frequencyDistribution === 'point' && event.pointEstimate) {
                                        freq = parseFloat(event.pointEstimate);
                                    } else if (event.frequencyDistribution === 'gamma' && event.gammaShape && event.gammaScale) {
                                        // Mean of gamma = shape * scale
                                        freq = parseFloat(event.gammaShape) * parseFloat(event.gammaScale);
                                    } else if (event.frequencyDistribution === 'lognormal' && event.lognormalMean) {
                                        // Mean is directly specified for lognormal
                                        freq = parseFloat(event.lognormalMean);
                                    } else if (event.frequencyDistribution === 'cni' && event.cniMean) {
                                        // CNI: shape=0.5, scale=2*mean, so mean = 0.5 * 2*mean = mean
                                        freq = parseFloat(event.cniMean);
                                    }
                                    
                                    // Convert to /yr if needed
                                    if (freq !== null && event.frequencyUnits === '/hr') {
                                        freq = freq * 8760; // hours per year
                                    }
                                    
                                    if (freq !== null) {
                                        frequencies.push(freq);
                                    }
                                } else if (event.occurrenceModel === 'prob-per-opportunity') {
                                    // Handle Probability per Opportunity
                                    // frequency = (# opportunities per operating period) * (# operating periods per year for THIS state) * (probability mean)
                                    let prob = null;
                                    const dist = event.probabilityDistribution || 'cni';
                                    
                                    if (dist === 'point' && event.probPointEstimate) {
                                        prob = parseFloat(event.probPointEstimate);
                                    } else if (dist === 'beta' && event.betaShape && event.betaScale) {
                                        // Mean of beta = alpha / (alpha + beta)
                                        const alpha = parseFloat(event.betaShape);
                                        const beta = parseFloat(event.betaScale);
                                        prob = alpha / (alpha + beta);
                                    } else if (dist === 'lognormal' && event.probLognormalMean) {
                                        prob = parseFloat(event.probLognormalMean);
                                    } else if (dist === 'cni' && event.probCniMean) {
                                        prob = parseFloat(event.probCniMean);
                                    }
                                    
                                    const opportunitiesPerPeriod = parseInt(event.opportunitiesPerPeriod) || 0;
                                    // Use THIS state's operating periods per year, not the source state's
                                    const periodsPerYear = getOperatingPeriodsPerYear(state.id);
                                    
                                    if (prob !== null && opportunitiesPerPeriod > 0 && periodsPerYear > 0) {
                                        const freq = opportunitiesPerPeriod * periodsPerYear * prob;
                                        frequencies.push(freq);
                                    }
                                } else if (event.occurrenceModel === 'hazard-curve') {
                                    // Handle hazard curve
                                    hasHazardCurve = true;
                                    if (event.hazardCurveData && event.hazardCurveData.length > 0) {
                                        event.hazardCurveData.forEach(row => {
                                            if (row.frequency) {
                                                const freq = parseFloat(row.frequency);
                                                if (!isNaN(freq)) {
                                                    curveMin = Math.min(curveMin, freq);
                                                    curveMax = Math.max(curveMax, freq);
                                                }
                                            }
                                        });
                                    }
                                } else if (event.occurrenceModel === 'nureg-2169-fire') {
                                    // Handle NUREG-2169 Fire Ignition - sum of selected ignition sources divided by component count times propagation factor
                                    const selections = event.fireIgnitionSelections || {};
                                    const selectedItems = NUREG2169_FIRE_IGNITION_DATA.filter(item => selections[item.bin]);
                                    const totalTableMean = selectedItems.reduce((sum, item) => sum + item.mean, 0);
                                    const componentCount = event.fireIgnitionComponentCount || 1;
                                    const propagationFactor = parseFloat(event.fireIgnitionPropagationFactor) || 1;
                                    const finalMean = (totalTableMean / componentCount) * propagationFactor;
                                    if (finalMean > 0) {
                                        frequencies.push(finalMean);
                                    }
                                }
                            });
                        }
                    }
                });
                
                // If there's a hazard curve, return the range
                if (hasHazardCurve && curveMin !== Infinity && curveMax !== -Infinity) {
                    return { isRange: true, min: curveMin, max: curveMax };
                }
                
                // For probability per opportunity model, sum all frequencies (total across all states)
                // For other models, check if all frequencies are the same
                if (frequencies.length === 0) return null;
                
                // Sum all frequencies for the total
                const totalFrequency = frequencies.reduce((sum, f) => sum + f, 0);
                
                // Check if all frequencies are the same (within tolerance) - for display consistency
                const first = frequencies[0];
                const tolerance = first * 0.01; // 1% tolerance
                const allSame = frequencies.every(f => Math.abs(f - first) <= tolerance);
                
                return allSame ? first : totalFrequency;
            };

            const visibleHazardList = getVisibleHazards(hazardList);
            
            const hazardColumnWidth = calculateHazardColumnWidth();

            // Handle pane resizing
            useEffect(() => {
                const resizer = resizerRef.current;
                const container = containerRef.current;
                
                if (!resizer || !container) return;

                let isResizing = false;

                const handleMouseDown = (e) => {
                    isResizing = true;
                    e.preventDefault();
                };

                const handleMouseMove = (e) => {
                    if (!isResizing) return;
                    
                    const containerRect = container.getBoundingClientRect();
                    const newHeight = ((e.clientY - containerRect.top) / containerRect.height) * 100;
                    
                    if (newHeight >= 10 && newHeight <= 50) {
                        setPaneAHeight(newHeight);
                    }
                };

                const handleMouseUp = () => {
                    isResizing = false;
                };

                resizer.addEventListener('mousedown', handleMouseDown);
                document.addEventListener('mousemove', handleMouseMove);
                document.addEventListener('mouseup', handleMouseUp);

                return () => {
                    resizer.removeEventListener('mousedown', handleMouseDown);
                    document.removeEventListener('mousemove', handleMouseMove);
                    document.removeEventListener('mouseup', handleMouseUp);
                };
            }, []);

            // Check for duplicate hazards by name and merge hierarchies
            const checkForDuplicates = (newList, existingList) => {
                // Build a set of existing hazard paths (full hierarchy paths for accurate comparison)
                // Path format: "parent1/parent2/leafname" (all lowercase, trimmed)
                const existingPaths = new Set();
                
                const collectExistingPaths = (nodes, parentPath = '') => {
                    nodes.forEach(node => {
                        const nodeName = node.name.toLowerCase().trim();
                        const fullPath = parentPath ? `${parentPath}/${nodeName}` : nodeName;
                        existingPaths.add(fullPath);
                        if (node.children && node.children.length > 0) {
                            collectExistingPaths(node.children, fullPath);
                        }
                    });
                };
                
                collectExistingPaths(existingList);
                
                // Generate unique IDs for new nodes to avoid ID conflicts
                let maxExistingId = 0;
                const findMaxId = (nodes) => {
                    nodes.forEach(node => {
                        const match = node.id.match(/^HAZ-(\d+)$/);
                        if (match) {
                            const num = parseInt(match[1], 10);
                            if (num > maxExistingId) maxExistingId = num;
                        }
                        if (node.children && node.children.length > 0) {
                            findMaxId(node.children);
                        }
                    });
                };
                findMaxId(existingList);
                let nextId = maxExistingId + 1;
                
                // Filter new hazards - keep nodes whose full path doesn't exist
                const filterNew = (nodes, parentPath = '') => {
                    const result = [];
                    
                    nodes.forEach(node => {
                        const nodeName = node.name.toLowerCase().trim();
                        const fullPath = parentPath ? `${parentPath}/${nodeName}` : nodeName;
                        const isLeaf = !node.children || node.children.length === 0;
                        
                        if (isLeaf) {
                            // For leaf nodes, check if this exact path exists
                            if (!existingPaths.has(fullPath)) {
                                // This is a new leaf - add it with a new unique ID
                                const clonedNode = JSON.parse(JSON.stringify(node));
                                clonedNode.id = `HAZ-${nextId++}`;
                                result.push(clonedNode);
                            }
                        } else {
                            // For parent nodes, recursively filter children
                            const filteredChildren = filterNew(node.children, fullPath);
                            
                            if (filteredChildren.length > 0) {
                                // There are new children under this parent
                                // Check if this parent path already exists
                                if (existingPaths.has(fullPath)) {
                                    // Parent exists - just include the new children wrapped in a matching parent structure
                                    // The merge function will handle adding children to existing parent
                                    const clonedNode = JSON.parse(JSON.stringify(node));
                                    clonedNode.children = filteredChildren;
                                    // Keep original ID structure for merge matching
                                    result.push(clonedNode);
                                } else {
                                    // Parent is also new - include entire subtree with new IDs
                                    const clonedNode = JSON.parse(JSON.stringify(node));
                                    clonedNode.id = `HAZ-${nextId++}`;
                                    clonedNode.children = filteredChildren;
                                    result.push(clonedNode);
                                }
                            }
                            // If no new children and parent exists, skip entirely
                        }
                    });
                    
                    return result;
                };
                
                return filterNew(newList);
            };
            
            // Merge new hazards into existing list, handling hierarchical merges
            const mergeHazardLists = (existingList, newList) => {
                const result = JSON.parse(JSON.stringify(existingList)); // Deep clone existing
                
                const findNodeByName = (nodes, name) => {
                    for (const node of nodes) {
                        if (node.name.toLowerCase() === name.toLowerCase()) {
                            return node;
                        }
                    }
                    return null;
                };
                
                const mergeNodes = (targetList, newNodes) => {
                    newNodes.forEach(newNode => {
                        const existingNode = findNodeByName(targetList, newNode.name);
                        
                        if (existingNode && newNode.children && newNode.children.length > 0) {
                            // Merge children into existing node
                            if (!existingNode.children) {
                                existingNode.children = [];
                            }
                            mergeNodes(existingNode.children, newNode.children);
                        } else if (!existingNode) {
                            // Add as new node
                            targetList.push(newNode);
                        }
                        // If existingNode exists but newNode has no children, skip (it's a duplicate leaf)
                    });
                };
                
                mergeNodes(result, newList);
                return result;
            };

            const handleLoadHazardList = () => {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json,.KNOW,.md,.txt';
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const content = event.target.result;
                            let parsedList;

                            // Check if it's a JSON file
                            if (file.name.endsWith('.json') || file.name.endsWith('.KNOW')) {
                                const data = JSON.parse(content);
                                parsedList = data.hazardList || [];
                            } else {
                                // Parse as Markdown
                                parsedList = parseMarkdownHazardList(content);
                            }

                            if (parsedList && parsedList.length > 0) {
                                // Check for duplicates if there's an existing list
                                let finalList;
                                if (hazardList.length > 0) {
                                    // Count total hazards in new list (including nested)
                                    const countHazards = (nodes) => {
                                        let count = 0;
                                        nodes.forEach(node => {
                                            count++;
                                            if (node.children && node.children.length > 0) {
                                                count += countHazards(node.children);
                                            }
                                        });
                                        return count;
                                    };
                                    
                                    const originalNewCount = countHazards(parsedList);
                                    
                                    // Get filtered list (new hazards only)
                                    const filtered = checkForDuplicates(parsedList, hazardList);
                                    const filteredCount = countHazards(filtered);
                                    
                                    if (filteredCount === 0) {
                                        alert('All hazards in the file are already in the current list. No new hazards added.');
                                        return;
                                    }
                                    
                                    // Use merge function to properly combine hierarchies
                                    finalList = mergeHazardLists(hazardList, filtered);
                                    
                                    const skippedCount = originalNewCount - filteredCount;
                                    if (skippedCount > 0) {
                                        alert(`${skippedCount} duplicate hazard(s) were skipped. ${filteredCount} new hazard(s) added.`);
                                    } else {
                                        alert(`${filteredCount} new hazard(s) added successfully.`);
                                    }
                                } else {
                                    finalList = parsedList;
                                }
                                
                                setHazardList(finalList);
                                window.currentHazardList = finalList; // Store globally for breadcrumb
                                // Initialize hazard states
                                const states = {};
                                const initStates = (nodes) => {
                                    nodes.forEach(node => {
                                        if (!node.children || node.children.length === 0) {
                                            DEFAULT_OPERATING_STATES.forEach(state => {
                                                const key = `${node.id}_${state.id}`;
                                                // Only initialize if not already set
                                                if (!hazardStates[key]) {
                                                    states[key] = 'unanalyzed';
                                                }
                                            });
                                        }
                                        if (node.children) {
                                            initStates(node.children);
                                        }
                                    });
                                };
                                initStates(finalList);
                                setHazardStates(prev => ({ ...prev, ...states }));
                            } else {
                                alert('No hazards found in file');
                            }
                        } catch (err) {
                            alert('Error loading hazard list: ' + err.message);
                        }
                    };
                    reader.readAsText(file);
                };
                input.click();
            };

            const parseMarkdownHazardList = (content) => {
                // Remove HTML comments
                content = content.replace(/<!--[\s\S]*?-->/g, '');
                
                // Normalize line endings - convert \r\n to \n
                content = content.replace(/\r\n/g, '\n');
                content = content.replace(/\r/g, '\n');
                
                const lines = content.split('\n');
                const root = [];
                let idCounter = 1;

                // Stack to keep track of the hierarchy
                // Each element is { node, level }
                const stack = [];

                for (let line of lines) {
                    // Skip empty lines
                    const trimmedLine = line.trim();
                    if (!trimmedLine) continue;

                    // Match pattern: optional tabs, then "- ", then text
                    const match = line.match(/^(\t*)- (.+)$/);
                    if (!match) continue;

                    const tabs = match[1];
                    const level = tabs.length;
                    const text = match[2].trim();

                    if (!text) continue;

                    const node = {
                        id: `HAZ-${idCounter++}`,
                        name: text,
                        children: []
                    };

                    if (level === 0) {
                        // Top level - add directly to root
                        root.push(node);
                        stack.length = 0; // Clear stack
                        stack.push({ node, level });
                    } else {
                        // Find the correct parent by popping stack until we find parent level
                        while (stack.length > 0 && stack[stack.length - 1].level >= level) {
                            stack.pop();
                        }

                        if (stack.length > 0) {
                            // Add as child to the parent
                            stack[stack.length - 1].node.children.push(node);
                        } else {
                            // No parent found (shouldn't happen with valid data), add to root
                            root.push(node);
                        }

                        // Push current node to stack
                        stack.push({ node, level });
                    }
                }

                return root;
            };

            const handleLoadHA = () => {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.KNOW_HA';
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (!file) return;

                    const reader = new FileReader();
                    reader.onload = (event) => {
                        try {
                            const data = JSON.parse(event.target.result);
                            setFacilityName(data.facilityName || '');
                            setExtendedDescription(data.extendedDescription || '');
                            setOperatingSchedule(data.operatingSchedule || {
                                periodYears: 1,
                                periods: [{ stateId: 'FOS-1', startDay: 0, endDay: 365 }]
                            });
                            if (data.operatingStateData) {
                                setOperatingStateData(data.operatingStateData);
                            }
                            if (data.hazardList) {
                                setHazardList(data.hazardList);
                                window.currentHazardList = data.hazardList; // Store globally for breadcrumb
                            }
                            if (data.hazardStates) {
                                setHazardStates(data.hazardStates);
                            }
                            if (data.hazardAnalysisData) {
                                setHazardAnalysisData(data.hazardAnalysisData);
                            }
                            // Track loaded file name
                            setLoadedFileName(file.name);
                        } catch (err) {
                            alert('Error loading HA file: ' + err.message);
                        }
                    };
                    reader.readAsText(file);
                };
                input.click();
            };

            const handleSaveHA = () => {
                const data = {
                    facilityName,
                    extendedDescription,
                    operatingSchedule,
                    operatingStateData,
                    hazardList,
                    hazardStates,
                    hazardAnalysisData
                };

                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                const safeFileName = (facilityName || 'Facility').replace(/\s+/g, '_');
                a.download = `${safeFileName}.KNOW_HA`;
                a.click();
                URL.revokeObjectURL(url);
                
                // Reset unsaved changes flag
                setHasUnsavedChanges(false);
                setLastSavedState(JSON.stringify(data));
            };

            const handleStateChange = (hazardId, hazardName, stateId) => {
                setEditingHazard({ hazardId, hazardName, stateId });
            };

            const handleSaveHazardAnalysis = (key, data) => {
                // Parse the key to get hazardId and stateId
                const keyParts = key.split('_');
                const stateId = keyParts.pop();
                const hazardId = keyParts.join('_');
                
                // First, collect all the dependent states from the current data
                const dependentKeys = [];
                DEFAULT_OPERATING_STATES.forEach(otherState => {
                    if (otherState.id !== stateId) {
                        const otherKey = `${hazardId}_${otherState.id}`;
                        const otherData = hazardAnalysisData[otherKey];
                        
                        // If this other state uses info from the state we just saved
                        if (otherData && otherData.useInfoFrom === stateId) {
                            dependentKeys.push(otherKey);
                        }
                    }
                });
                
                setHazardAnalysisData(prev => {
                    const newData = {
                        ...prev,
                        [key]: data
                    };
                    
                    // Update dependent states' status to match the source
                    dependentKeys.forEach(depKey => {
                        if (prev[depKey]) {
                            newData[depKey] = {
                                ...prev[depKey],
                                status: data.status
                            };
                        }
                    });
                    
                    return newData;
                });
                
                // Update the button status for this key and any dependent states
                setHazardStates(prev => {
                    const newStates = {
                        ...prev,
                        [key]: data.status
                    };
                    
                    // Also update status for dependent states
                    dependentKeys.forEach(depKey => {
                        newStates[depKey] = data.status;
                    });
                    
                    return newStates;
                });
            };

            const renderHazardRow = (node, level) => {
                const hasChildren = node.children && node.children.length > 0;
                
                if (hasChildren) {
                    return (
                        <div key={node.id}>
                            <div className="flex border-b" style={{ backgroundColor: '#f9fafb' }}>
                                <div className="flex-shrink-0 py-1 px-2 font-semibold" style={{ width: `${hazardColumnWidth}px`, paddingLeft: `${level * 20 + 8}px` }}>
                                    {node.name}
                                </div>
                                <div className="w-32 py-1 px-2 border-l flex-shrink-0"></div>
                                {DEFAULT_OPERATING_STATES.map(state => (
                                    <div key={state.id} className="w-32 py-1 px-2 border-l flex-shrink-0"></div>
                                ))}
                                <div className="flex-1 min-w-48 py-1 px-2 border-l flex-shrink-0"></div>
                            </div>
                            {node.children.map(child => renderHazardRow(child, level + 1))}
                        </div>
                    );
                } else {
                    const frequency = calculateHazardFrequency(node.id);
                    
                    // Collect notes from hazard analysis data (supporting information)
                    const getHazardNotes = () => {
                        const notes = [];
                        DEFAULT_OPERATING_STATES.forEach(state => {
                            const key = `${node.id}_${state.id}`;
                            const stateValue = hazardStates[key];
                            const analysisData = hazardAnalysisData[key];
                            
                            if ((stateValue === 'included' || stateValue === 'screened') && analysisData && analysisData.applicableEvents) {
                                analysisData.applicableEvents.forEach(event => {
                                    if (event.description) {
                                        // Strip HTML tags for display, adding spaces between block elements
                                        const tempDiv = document.createElement('div');
                                        // Replace closing block tags with space before stripping
                                        const htmlWithSpaces = event.description
                                            .replace(/<\/(h1|h2|h3|h4|h5|h6|p|div|li|br)>/gi, ' ')
                                            .replace(/<br\s*\/?>/gi, ' ');
                                        tempDiv.innerHTML = htmlWithSpaces;
                                        const plainText = tempDiv.textContent || tempDiv.innerText || '';
                                        // Replace line returns and multiple spaces with single space
                                        const cleanedText = plainText.replace(/\n/g, ' ').replace(/\r/g, ' ').replace(/\s+/g, ' ').trim();
                                        if (cleanedText && !notes.includes(cleanedText)) {
                                            notes.push(cleanedText);
                                        }
                                    }
                                });
                            }
                        });
                        return notes.join('; ');
                    };
                    
                    const hazardNotes = getHazardNotes();
                    
                    return (
                        <div key={node.id} className="flex border-b hover:bg-gray-50">
                            <div className="flex-shrink-0 py-1 px-2" style={{ width: `${hazardColumnWidth}px`, paddingLeft: `${level * 20 + 8}px` }}>
                                {node.name}
                            </div>
                            <div className="w-32 py-1 px-2 border-l flex items-center justify-center flex-shrink-0 text-xs font-bold">
                                {frequency !== null ? (
                                    frequency.isRange ? 
                                        `(${formatFrequency(frequency.min)}, ${formatFrequency(frequency.max)})` :
                                        formatFrequency(frequency)
                                ) : ''}
                            </div>
                            {DEFAULT_OPERATING_STATES.map(state => {
                                const key = `${node.id}_${state.id}`;
                                const stateValue = hazardStates[key] || 'unanalyzed';
                                return (
                                    <div key={state.id} className="w-32 py-1 px-2 border-l flex items-center justify-center flex-shrink-0">
                                        <button
                                            className={`hazard-button ${stateValue}`}
                                            onClick={() => handleStateChange(node.id, node.name, state.id)}
                                        >
                                            {stateValue === 'unanalyzed' ? 'Unanalyzed' :
                                             stateValue === 'screened' ? 'Screened' : 'Included'}
                                        </button>
                                    </div>
                                );
                            })}
                            <div className="flex-1 min-w-48 py-1 px-2 border-l flex-shrink-0 text-xs text-gray-600 overflow-hidden" title={hazardNotes}>
                                <span className="line-clamp-2">{hazardNotes}</span>
                            </div>
                        </div>
                    );
                }
            };

            // Get list of available hazards with their frequencies for the plot sidebar
            const getAvailableHazards = () => {
                const hazardFreqs = {};
                const minFreqSetting = settings.hazardPlot?.minFrequency || 1e-7;
                const maxFreqSetting = settings.hazardPlot?.maxFrequency || 1e0;
                
                const collectLeafHazards = (nodes, list = [], path = []) => {
                    nodes.forEach(node => {
                        if (node.hidden) return; // Skip hidden hazards
                        const newPath = [...path, node.name];
                        if (node.children && node.children.length > 0) {
                            collectLeafHazards(node.children, list, newPath);
                        } else {
                            list.push({ hazard: node, path: newPath });
                        }
                    });
                    return list;
                };
                
                const leafHazards = collectLeafHazards(hazardList);
                
                // Helper to get effective events (handles useInfoFrom)
                const getEffectiveEvents = (hazardId, stateId) => {
                    const key = `${hazardId}_${stateId}`;
                    let analysisData = hazardAnalysisData[key];
                    
                    if (analysisData && analysisData.useInfoFrom) {
                        const sourceKey = `${hazardId}_${analysisData.useInfoFrom}`;
                        const sourceData = hazardAnalysisData[sourceKey];
                        if (sourceData) {
                            analysisData = sourceData;
                        }
                    }
                    
                    return analysisData;
                };
                
                // Helper to calculate frequency from event
                const getEventFrequency = (event, stateId) => {
                    if (event.occurrenceModel === 'frequency') {
                        let freq = null;
                        
                        if (event.frequencyDistribution === 'point' && event.pointEstimate) {
                            freq = parseFloat(event.pointEstimate);
                        } else if (event.frequencyDistribution === 'gamma' && event.gammaShape && event.gammaScale) {
                            freq = parseFloat(event.gammaShape) * parseFloat(event.gammaScale);
                        } else if (event.frequencyDistribution === 'lognormal' && event.lognormalMean) {
                            freq = parseFloat(event.lognormalMean);
                        } else if (event.frequencyDistribution === 'cni' && event.cniMean) {
                            freq = parseFloat(event.cniMean);
                        }
                        
                        if (freq !== null && freq > 0) {
                            if (event.frequencyUnits === '/hr') {
                                freq = freq * 8760;
                            }
                            return freq;
                        }
                    } else if (event.occurrenceModel === 'prob-per-opportunity') {
                        let prob = null;
                        const dist = event.probabilityDistribution || 'cni';
                        
                        if (dist === 'point' && event.probPointEstimate) {
                            prob = parseFloat(event.probPointEstimate);
                        } else if (dist === 'beta' && event.betaShape && event.betaScale) {
                            const alpha = parseFloat(event.betaShape);
                            const beta = parseFloat(event.betaScale);
                            prob = alpha / (alpha + beta);
                        } else if (dist === 'lognormal' && event.probLognormalMean) {
                            prob = parseFloat(event.probLognormalMean);
                        } else if (dist === 'cni' && event.probCniMean) {
                            prob = parseFloat(event.probCniMean);
                        }
                        
                        const opportunitiesPerPeriod = parseInt(event.opportunitiesPerPeriod) || 0;
                        const periods = operatingSchedule.periods || [];
                        let periodCount = 0;
                        periods.forEach(period => {
                            if (period.stateId === stateId) {
                                periodCount++;
                            }
                        });
                        const periodsPerYear = periodCount / (operatingSchedule.periodYears || 1);
                        
                        if (prob !== null && opportunitiesPerPeriod > 0 && periodsPerYear > 0) {
                            return opportunitiesPerPeriod * periodsPerYear * prob;
                        }
                    } else if (event.occurrenceModel === 'nureg-2169-fire') {
                        const selections = event.fireIgnitionSelections || {};
                        const selectedItems = NUREG2169_FIRE_IGNITION_DATA.filter(item => selections[item.bin]);
                        const totalTableMean = selectedItems.reduce((sum, item) => sum + item.mean, 0);
                        const componentCount = event.fireIgnitionComponentCount || 1;
                        const propagationFactor = parseFloat(event.fireIgnitionPropagationFactor) || 1;
                        const finalMean = (totalTableMean / componentCount) * propagationFactor;
                        if (finalMean > 0) {
                            return finalMean;
                        }
                    }
                    return null;
                };
                
                leafHazards.forEach(({ hazard, path }) => {
                    DEFAULT_OPERATING_STATES.forEach(state => {
                        const key = `${hazard.id}_${state.id}`;
                        const stateValue = hazardStates[key];
                        const analysisData = getEffectiveEvents(hazard.id, state.id);
                        
                        if (stateValue === 'included' && analysisData && analysisData.applicableEvents) {
                            analysisData.applicableEvents.forEach(event => {
                                const freq = getEventFrequency(event, state.id);
                                const eventName = event.name || path[path.length - 1];
                                
                                if (freq !== null && freq > 0) {
                                    if (!hazardFreqs[eventName]) {
                                        hazardFreqs[eventName] = {
                                            name: eventName,
                                            frequency: 0,
                                            maxFreq: 0
                                        };
                                    }
                                    hazardFreqs[eventName].frequency += freq;
                                    hazardFreqs[eventName].maxFreq = Math.max(hazardFreqs[eventName].maxFreq, freq);
                                }
                            });
                        }
                    });
                });
                
                // Convert to array and add out-of-range indicator
                return Object.values(hazardFreqs).map(h => ({
                    ...h,
                    isOutOfRange: h.maxFreq < minFreqSetting || h.maxFreq > maxFreqSetting
                })).sort((a, b) => b.frequency - a.frequency);
            };

            const createHazardPlot = (plotType = 'individual', selectedHazards = null) => {
                const canvas = document.createElement('canvas');
                canvas.width = 2400;  // Doubled for higher resolution
                canvas.height = 1800; // Doubled for higher resolution
                const ctx = canvas.getContext('2d');
                
                // White background
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // Define margins and plot area (increased right margin for labels)
                const margin = { top: 80, right: 250, bottom: 160, left: 160 };
                const plotWidth = canvas.width - margin.left - margin.right;
                const plotHeight = canvas.height - margin.top - margin.bottom;
                
                // Collect hazard data with frequencies
                const hazardData = [];
                const collectLeafHazards = (nodes, list = [], path = []) => {
                    nodes.forEach(node => {
                        if (node.hidden) return; // Skip hidden hazards
                        const newPath = [...path, node.name];
                        if (node.children && node.children.length > 0) {
                            collectLeafHazards(node.children, list, newPath);
                        } else {
                            list.push({ hazard: node, path: newPath });
                        }
                    });
                    return list;
                };
                
                const leafHazards = collectLeafHazards(hazardList);
                const totalDays = operatingSchedule.periodYears * 365;
                
                // Helper to get effective events (handles useInfoFrom)
                const getEffectiveEvents = (hazardId, stateId) => {
                    const key = `${hazardId}_${stateId}`;
                    let analysisData = hazardAnalysisData[key];
                    
                    if (analysisData && analysisData.useInfoFrom) {
                        const sourceKey = `${hazardId}_${analysisData.useInfoFrom}`;
                        const sourceData = hazardAnalysisData[sourceKey];
                        if (sourceData) {
                            analysisData = sourceData;
                        }
                    }
                    
                    return analysisData;
                };
                
                // Helper to calculate frequency from event
                const getEventFrequency = (event, stateId) => {
                    if (event.occurrenceModel === 'frequency') {
                        let freq = null;
                        
                        if (event.frequencyDistribution === 'point' && event.pointEstimate) {
                            freq = parseFloat(event.pointEstimate);
                        } else if (event.frequencyDistribution === 'gamma' && event.gammaShape && event.gammaScale) {
                            freq = parseFloat(event.gammaShape) * parseFloat(event.gammaScale);
                        } else if (event.frequencyDistribution === 'lognormal' && event.lognormalMean) {
                            freq = parseFloat(event.lognormalMean);
                        } else if (event.frequencyDistribution === 'cni' && event.cniMean) {
                            freq = parseFloat(event.cniMean);
                        }
                        
                        if (freq !== null && freq > 0) {
                            // Convert to /yr if needed
                            if (event.frequencyUnits === '/hr') {
                                freq = freq * 8760;
                            }
                            return freq;
                        }
                    } else if (event.occurrenceModel === 'prob-per-opportunity') {
                        let prob = null;
                        const dist = event.probabilityDistribution || 'cni';
                        
                        if (dist === 'point' && event.probPointEstimate) {
                            prob = parseFloat(event.probPointEstimate);
                        } else if (dist === 'beta' && event.betaShape && event.betaScale) {
                            const alpha = parseFloat(event.betaShape);
                            const beta = parseFloat(event.betaScale);
                            prob = alpha / (alpha + beta);
                        } else if (dist === 'lognormal' && event.probLognormalMean) {
                            prob = parseFloat(event.probLognormalMean);
                        } else if (dist === 'cni' && event.probCniMean) {
                            prob = parseFloat(event.probCniMean);
                        }
                        
                        const opportunitiesPerPeriod = parseInt(event.opportunitiesPerPeriod) || 0;
                        
                        // Calculate periods per year for this state
                        const periods = operatingSchedule.periods || [];
                        let periodCount = 0;
                        periods.forEach(period => {
                            if (period.stateId === stateId) {
                                periodCount++;
                            }
                        });
                        const periodsPerYear = periodCount / (operatingSchedule.periodYears || 1);
                        
                        if (prob !== null && opportunitiesPerPeriod > 0 && periodsPerYear > 0) {
                            return opportunitiesPerPeriod * periodsPerYear * prob;
                        }
                    } else if (event.occurrenceModel === 'nureg-2169-fire') {
                        const selections = event.fireIgnitionSelections || {};
                        const selectedItems = NUREG2169_FIRE_IGNITION_DATA.filter(item => selections[item.bin]);
                        const totalTableMean = selectedItems.reduce((sum, item) => sum + item.mean, 0);
                        const componentCount = event.fireIgnitionComponentCount || 1;
                        const propagationFactor = parseFloat(event.fireIgnitionPropagationFactor) || 1;
                        const finalMean = (totalTableMean / componentCount) * propagationFactor;
                        if (finalMean > 0) {
                            return finalMean;
                        }
                    }
                    return null;
                };
                
                leafHazards.forEach(({ hazard, path }) => {
                    DEFAULT_OPERATING_STATES.forEach(state => {
                        const key = `${hazard.id}_${state.id}`;
                        const stateValue = hazardStates[key];
                        const analysisData = getEffectiveEvents(hazard.id, state.id);
                        
                        if (stateValue === 'included' && analysisData && analysisData.applicableEvents) {
                            analysisData.applicableEvents.forEach(event => {
                                const freq = getEventFrequency(event, state.id);
                                const eventName = event.name || path[path.length - 1];
                                
                                // Filter by selected hazards if a selection is provided
                                if (selectedHazards && selectedHazards.size > 0 && !selectedHazards.has(eventName)) {
                                    return; // Skip this hazard
                                }
                                
                                if (freq !== null && freq > 0) {
                                    // Find periods for this state
                                    operatingSchedule.periods.forEach(period => {
                                        if (period.stateId === state.id) {
                                            hazardData.push({
                                                name: eventName,
                                                fullName: path.join(' > '),
                                                frequency: freq,
                                                startDay: period.startDay,
                                                endDay: period.endDay,
                                                stateId: state.id
                                            });
                                        }
                                    });
                                }
                            });
                        }
                    });
                });
                
                if (hazardData.length === 0) {
                    // No data to plot
                    ctx.fillStyle = '#000000';
                    ctx.font = '33px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('No frequency data available for plotting', canvas.width / 2, canvas.height / 2);
                    return canvas.toDataURL('image/png');
                }
                
                // For total plot, aggregate frequencies by period
                let plotData = hazardData;
                if (plotType === 'total') {
                    // Group by period (startDay, endDay)
                    const periodTotals = {};
                    hazardData.forEach(point => {
                        const periodKey = `${point.startDay}_${point.endDay}_${point.stateId}`;
                        if (!periodTotals[periodKey]) {
                            periodTotals[periodKey] = {
                                name: 'Total Hazard Frequency',
                                fullName: 'Sum of all hazard frequencies',
                                frequency: 0,
                                startDay: point.startDay,
                                endDay: point.endDay,
                                stateId: point.stateId
                            };
                        }
                        periodTotals[periodKey].frequency += point.frequency;
                    });
                    plotData = Object.values(periodTotals);
                }
                
                // Check if plotData is empty after aggregation
                if (plotData.length === 0) {
                    ctx.fillStyle = '#000000';
                    ctx.font = '33px Arial';
                    ctx.textAlign = 'center';
                    ctx.fillText('No frequency data available for plotting', canvas.width / 2, canvas.height / 2);
                    if (plotType === 'total') {
                        ctx.font = '24px Arial';
                        ctx.fillText(`(hazardData had ${hazardData.length} entries)`, canvas.width / 2, canvas.height / 2 + 40);
                    }
                    return canvas.toDataURL('image/png');
                }
                
                // Use settings for y-axis range
                const minFreqSetting = settings.hazardPlot?.minFrequency || 1e-7;
                const maxFreqSetting = settings.hazardPlot?.maxFrequency || 1e0;
                const logMin = Math.log10(minFreqSetting);
                const logMax = Math.log10(maxFreqSetting);
                
                // Draw axes
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(margin.left, margin.top);
                ctx.lineTo(margin.left, margin.top + plotHeight);
                ctx.lineTo(margin.left + plotWidth, margin.top + plotHeight);
                ctx.stroke();
                
                // Y-axis labels (logarithmic)
                ctx.fillStyle = '#000000';
                ctx.font = '21px Arial';
                ctx.textAlign = 'right';
                ctx.textBaseline = 'middle';
                
                const logRange = logMax - logMin;
                const numTicks = Math.abs(logRange) + 1;
                for (let i = 0; i < numTicks; i++) {
                    const logValue = logMin + i;
                    const freq = Math.pow(10, logValue);
                    const y = margin.top + plotHeight - (i / (numTicks - 1)) * plotHeight;
                    
                    ctx.fillText(freq.toExponential(0), margin.left - 20, y);
                    
                    // Grid line
                    ctx.strokeStyle = '#e0e0e0';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(margin.left, y);
                    ctx.lineTo(margin.left + plotWidth, y);
                    ctx.stroke();
                }
                
                // Y-axis label
                ctx.save();
                ctx.translate(40, margin.top + plotHeight / 2);
                ctx.rotate(-Math.PI / 2);
                ctx.textAlign = 'center';
                ctx.font = 'bold 25px Arial';
                ctx.fillStyle = '#000000';
                ctx.fillText('Hazard Frequency (/yr)', 0, 0);
                ctx.restore();
                
                // X-axis labels at period boundaries
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                ctx.font = '21px Arial';
                ctx.fillStyle = '#000000';
                
                // Get unique start days from periods
                const periodBoundaries = new Set();
                operatingSchedule.periods.forEach(period => {
                    periodBoundaries.add(Math.floor(period.startDay));
                    periodBoundaries.add(Math.floor(period.endDay));
                });
                
                const sortedBoundaries = Array.from(periodBoundaries).sort((a, b) => a - b);
                sortedBoundaries.forEach(day => {
                    const x = margin.left + (day / totalDays) * plotWidth;
                    ctx.fillText(`Day ${day}`, x, margin.top + plotHeight + 20);
                    
                    // Vertical grid line
                    ctx.strokeStyle = '#e0e0e0';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(x, margin.top);
                    ctx.lineTo(x, margin.top + plotHeight);
                    ctx.stroke();
                });
                
                // X-axis label
                ctx.font = 'bold 25px Arial';
                ctx.fillStyle = '#000000';
                ctx.fillText('Anticipated Schedule (Days)', margin.left + plotWidth / 2, canvas.height - 40);
                
                // Draw operating state labels above x-axis
                ctx.font = '21px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                
                // Get operating state colors
                const getStateColor = (stateId) => {
                    if (settings.stateColors && settings.stateColors[stateId]) {
                        return settings.stateColors[stateId];
                    }
                    const state = DEFAULT_OPERATING_STATES.find(s => s.id === stateId);
                    return state ? state.color : '#e5e7eb';
                };
                
                // Draw colored boxes for each operating period
                operatingSchedule.periods.forEach(period => {
                    const x1 = margin.left + (period.startDay / totalDays) * plotWidth;
                    const x2 = margin.left + (period.endDay / totalDays) * plotWidth;
                    const boxWidth = x2 - x1;
                    const boxHeight = 40;
                    const boxY = margin.top + plotHeight + 60;
                    
                    // Draw colored box
                    ctx.fillStyle = getStateColor(period.stateId);
                    ctx.fillRect(x1, boxY, boxWidth, boxHeight);
                    
                    // Draw border
                    ctx.strokeStyle = '#333333';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x1, boxY, boxWidth, boxHeight);
                    
                    // Draw state label if there's enough space
                    if (boxWidth > 60) {
                        ctx.fillStyle = '#000000';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(period.stateId, x1 + boxWidth / 2, boxY + boxHeight / 2);
                    }
                });
                
                // Add title for total plot
                if (plotType === 'total') {
                    ctx.fillStyle = '#000000';
                    ctx.font = 'bold 30px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'top';
                    ctx.fillText('Total Hazard Frequency (Sum of All Hazards)', canvas.width / 2, 20);
                }
                
                // Group hazards by name and add small random offset to overlapping frequencies
                const hazardGroups = {};
                plotData.forEach(point => {
                    if (!hazardGroups[point.name]) {
                        hazardGroups[point.name] = [];
                    }
                    hazardGroups[point.name].push(point);
                });
                
                // Create offset map for overlapping frequencies
                const offsetMap = new Map();
                const offsetRange = 0.03; // 3% of log range
                
                Object.keys(hazardGroups).forEach((hazardName) => {
                    hazardGroups[hazardName].forEach(point => {
                        const logFreq = Math.log10(point.frequency);
                        const key = `${logFreq.toFixed(3)}_${point.startDay}_${point.endDay}`;
                        
                        if (!offsetMap.has(key)) {
                            offsetMap.set(key, []);
                        }
                        offsetMap.get(key).push({ hazardName, point });
                    });
                });
                
                // Assign offsets to overlapping lines
                offsetMap.forEach((overlapping) => {
                    if (overlapping.length > 1) {
                        overlapping.forEach((item, index) => {
                            const offset = ((index - (overlapping.length - 1) / 2) * offsetRange * (logMax - logMin)) / overlapping.length;
                            item.offset = offset;
                        });
                    } else {
                        overlapping[0].offset = 0;
                    }
                });
                
                // Plot hazard lines
                const colors = plotType === 'total' ? ['#2563eb'] : ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6', '#1abc9c', '#e67e22', '#34495e'];
                const lineStyles = ['solid', 'dashed', 'dotted'];
                const uniqueHazards = Object.keys(hazardGroups);
                
                // Track rightmost point for each hazard for label placement
                const hazardLabelPositions = {};
                
                uniqueHazards.forEach((hazardName, index) => {
                    const color = colors[index % colors.length];
                    const lineStyle = plotType === 'total' ? 'solid' : lineStyles[Math.floor(index / colors.length) % lineStyles.length];
                    const hazardPoints = hazardGroups[hazardName];
                    
                    let maxX2 = -Infinity;
                    let labelY = 0;
                    
                    hazardPoints.forEach(point => {
                        const logFreq = Math.log10(point.frequency);
                        const key = `${logFreq.toFixed(3)}_${point.startDay}_${point.endDay}`;
                        const offsetItems = offsetMap.get(key);
                        const offsetItem = offsetItems ? offsetItems.find(item => item.hazardName === hazardName) : null;
                        const offset = offsetItem ? offsetItem.offset : 0;
                        
                        // Calculate y position, clamping to plot area
                        const yNorm = (logFreq + offset - logMin) / (logMax - logMin);
                        const yNormClamped = Math.max(0, Math.min(1, yNorm));
                        const y = margin.top + plotHeight - yNormClamped * plotHeight;
                        const x1 = margin.left + (point.startDay / totalDays) * plotWidth;
                        const x2 = margin.left + (point.endDay / totalDays) * plotWidth;
                        
                        // Track rightmost position
                        if (x2 > maxX2) {
                            maxX2 = x2;
                            labelY = y;
                        }
                        
                        ctx.strokeStyle = color;
                        ctx.lineWidth = plotType === 'total' ? 6 : 4;
                        
                        if (lineStyle === 'dashed') {
                            ctx.setLineDash([10, 10]);
                        } else if (lineStyle === 'dotted') {
                            ctx.setLineDash([4, 4]);
                        } else {
                            ctx.setLineDash([]);
                        }
                        
                        ctx.beginPath();
                        ctx.moveTo(x1, y);
                        ctx.lineTo(x2, y);
                        ctx.stroke();
                        
                        // If frequency is outside visible range, add indicator
                        if (yNorm > 1) {
                            // Frequency above max - draw arrow at top
                            ctx.fillStyle = color;
                            ctx.beginPath();
                            ctx.moveTo((x1 + x2) / 2, margin.top + 5);
                            ctx.lineTo((x1 + x2) / 2 - 8, margin.top + 20);
                            ctx.lineTo((x1 + x2) / 2 + 8, margin.top + 20);
                            ctx.closePath();
                            ctx.fill();
                        } else if (yNorm < 0) {
                            // Frequency below min - draw arrow at bottom
                            ctx.fillStyle = color;
                            ctx.beginPath();
                            ctx.moveTo((x1 + x2) / 2, margin.top + plotHeight - 5);
                            ctx.lineTo((x1 + x2) / 2 - 8, margin.top + plotHeight - 20);
                            ctx.lineTo((x1 + x2) / 2 + 8, margin.top + plotHeight - 20);
                            ctx.closePath();
                            ctx.fill();
                        }
                    });
                    
                    // Store label position
                    if (maxX2 > -Infinity) {
                        hazardLabelPositions[hazardName] = { x: maxX2, y: labelY, color, lineStyle };
                    }
                });
                
                // Draw labels at the end of lines
                ctx.setLineDash([]);
                ctx.font = plotType === 'total' ? 'bold 21px Arial' : '19px Arial';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'middle';
                
                Object.keys(hazardLabelPositions).forEach(hazardName => {
                    const pos = hazardLabelPositions[hazardName];
                    
                    // Draw label text with extended space to the right
                    ctx.fillStyle = pos.color;
                    ctx.fillText(hazardName, pos.x + 10, pos.y);
                });
                
                
                return canvas.toDataURL('image/png');
            };

            const generateReport = async () => {
                if (!facilityName) {
                    alert('Please enter a facility name before generating the report.');
                    return;
                }

                // Helper function to strip font-family styles from HTML content
                const stripFontFamily = (html) => {
                    if (!html) return html;
                    // Remove font-family from inline styles
                    return html.replace(/font-family\s*:\s*[^;"']+[;]?/gi, '');
                };

                // Helper function to create operating state information section
                const createOperatingStateInfoHTML = () => {
                    let stateInfoHTML = '<div style="margin: 6px 0;">';
                    
                    DEFAULT_OPERATING_STATES.forEach(state => {
                        const customData = operatingStateData[state.id];
                        const displayName = customData?.name || state.name;
                        const displayDescription = customData?.description || state.description;
                        const displayExtended = stripFontFamily(customData?.extendedDescription || '');
                        const stateColor = settings.stateColors?.[state.id] || state.color;
                        
                        stateInfoHTML += `<div style="margin-bottom: 15px; padding: 10px; border-left: 4px solid ${stateColor}; background-color: #f9fafb;">`;
                        stateInfoHTML += `<h3 style="margin: 0 0 5px 0;">${state.id}: ${displayName}</h3>`;
                        stateInfoHTML += `<p style="margin: 0 0 5px 0;"><strong>Description:</strong> ${displayDescription}</p>`;
                        if (displayExtended) {
                            stateInfoHTML += `<div style="margin-top: 10px;"><strong>Extended Description:</strong><div style="margin-top: 5px;">${displayExtended}</div></div>`;
                        }
                        stateInfoHTML += `</div>`;
                    });
                    
                    stateInfoHTML += '</div>';
                    return stateInfoHTML;
                };

                // Helper function to create timeline visualization
                const createTimelineHTML = () => {
                    const totalDays = operatingSchedule.periodYears * 365;
                    let timelineHTML = '<div style="margin: 6px 0; line-height: 1.8;">';
                    
                    operatingSchedule.periods.forEach((period, index) => {
                        const state = DEFAULT_OPERATING_STATES.find(s => s.id === period.stateId);
                        const startDay = Math.floor(period.startDay);
                        const endDay = Math.floor(period.endDay);
                        
                        timelineHTML += `<div style="margin: 5px 0; padding: 8px; background-color: ${state.color}; border: 1px solid #999; border-radius: 3px;">`;
                        timelineHTML += `<strong>Day ${startDay} - Day ${endDay}:</strong> ${state.id} -- ${state.name}: ${state.description}`;
                        timelineHTML += '</div>';
                    });
                    
                    timelineHTML += '</div>';
                    return timelineHTML;
                };

                // Helper function to lighten a color for table cells
                const lightenColor = (color, percent = 40) => {
                    // Convert hex to RGB
                    const hex = color.replace('#', '');
                    const r = parseInt(hex.substr(0, 2), 16);
                    const g = parseInt(hex.substr(2, 2), 16);
                    const b = parseInt(hex.substr(4, 2), 16);
                    
                    // Lighten by moving towards white
                    const newR = Math.round(r + (255 - r) * (percent / 100));
                    const newG = Math.round(g + (255 - g) * (percent / 100));
                    const newB = Math.round(b + (255 - b) * (percent / 100));
                    
                    // Convert back to hex
                    return '#' + [newR, newG, newB].map(x => {
                        const hex = x.toString(16);
                        return hex.length === 1 ? '0' + hex : hex;
                    }).join('');
                };

                // Helper function to create hazard summary table
                const createHazardTableHTML = () => {
                    // Helper function to get category for a frequency
                    const getHazardCategory = (frequency) => {
                        if (frequency === null || frequency === undefined) return '';
                        const categories = settings.hazardCategories || [];
                        for (const cat of categories) {
                            const low = cat.lowBound || 0;
                            const high = cat.highBound === Infinity ? Number.MAX_VALUE : (cat.highBound || 0);
                            if (frequency > low && frequency <= high) {
                                return cat.name;
                            }
                            // Handle edge case for lowest category (frequency exactly at low bound)
                            if (frequency === low && low === 0) {
                                return cat.name;
                            }
                        }
                        // Check if frequency is higher than highest category
                        const highestCat = categories.find(c => c.highBound === Infinity);
                        if (highestCat && frequency > highestCat.lowBound) {
                            return highestCat.name;
                        }
                        return '';
                    };

                    let tableHTML = '<table><thead><tr>';
                    tableHTML += '<th>Potential Hazards</th>';
                    tableHTML += '<th>Frequency</th>';
                    if (settings.showHazardCategorization) {
                        tableHTML += '<th>Categorization</th>';
                    }
                    DEFAULT_OPERATING_STATES.forEach(state => {
                        tableHTML += `<th>${state.name}</th>`;
                    });
                    tableHTML += '</tr></thead><tbody>';

                    const collectLeafHazards = (nodes, list = []) => {
                        nodes.forEach(node => {
                            if (node.hidden) return; // Skip hidden hazards
                            if (node.children && node.children.length > 0) {
                                collectLeafHazards(node.children, list);
                            } else {
                                list.push(node);
                            }
                        });
                        return list;
                    };

                    const leafHazards = collectLeafHazards(hazardList);
                    
                    leafHazards.forEach(hazard => {
                        let hasIncluded = false;
                        DEFAULT_OPERATING_STATES.forEach(state => {
                            const key = `${hazard.id}_${state.id}`;
                            if (hazardStates[key] === 'included') {
                                hasIncluded = true;
                            }
                        });

                        if (hasIncluded) {
                            // Check if any event has hazard curve
                            let hasHazardCurve = false;
                            let hazardCurveHTML = '';
                            
                            DEFAULT_OPERATING_STATES.forEach(state => {
                                const key = `${hazard.id}_${state.id}`;
                                const analysisData = hazardAnalysisData[key];
                                
                                if (analysisData && analysisData.applicableEvents) {
                                    analysisData.applicableEvents.forEach(event => {
                                        if (event.occurrenceModel === 'hazard-curve' && event.hazardCurveData && event.hazardCurveData.length > 0) {
                                            hasHazardCurve = true;
                                            if (!hazardCurveHTML) {
                                                // Create embedded hazard curve table
                                                hazardCurveHTML = '<table style="width: 90%; font-size: 8pt; margin: 0;"><thead><tr><th style="padding: 2px; text-align: center;">Magnitude</th><th style="padding: 2px; text-align: center;">Frequency (/yr)</th></tr></thead><tbody>';
                                                event.hazardCurveData.forEach(row => {
                                                    if (row.magnitude || row.frequency) {
                                                        hazardCurveHTML += `<tr><td style="padding: 2px;">${row.magnitude || ''}</td><td style="padding: 2px;">${row.frequency || ''}</td></tr>`;
                                                    }
                                                });
                                                hazardCurveHTML += '</tbody></table>';
                                            }
                                        }
                                    });
                                }
                            });
                            
                            const frequency = calculateHazardFrequency(hazard.id);
                            tableHTML += '<tr>';
                            tableHTML += `<td>${hazard.name}</td>`;
                            
                            // Insert hazard curve table or frequency
                            if (hasHazardCurve) {
                                tableHTML += `<td style="padding: 2px;">${hazardCurveHTML}</td>`;
                                // For hazard curves, show categorization based on highest frequency if enabled
                                if (settings.showHazardCategorization) {
                                    let maxFreq = 0;
                                    DEFAULT_OPERATING_STATES.forEach(state => {
                                        const key = `${hazard.id}_${state.id}`;
                                        const analysisData = hazardAnalysisData[key];
                                        if (analysisData && analysisData.applicableEvents) {
                                            analysisData.applicableEvents.forEach(event => {
                                                if (event.occurrenceModel === 'hazard-curve' && event.hazardCurveData) {
                                                    event.hazardCurveData.forEach(row => {
                                                        const freq = parseFloat(row.frequency);
                                                        if (!isNaN(freq) && freq > maxFreq) maxFreq = freq;
                                                    });
                                                }
                                            });
                                        }
                                    });
                                    tableHTML += `<td style="text-align: center;">${getHazardCategory(maxFreq)}</td>`;
                                }
                            } else {
                                tableHTML += `<td>${frequency !== null ? formatFrequency(frequency) : ''}</td>`;
                                // Add categorization column if enabled
                                if (settings.showHazardCategorization) {
                                    const category = getHazardCategory(frequency);
                                    tableHTML += `<td style="text-align: center;">${category}</td>`;
                                }
                            }
                            
                            DEFAULT_OPERATING_STATES.forEach(state => {
                                const key = `${hazard.id}_${state.id}`;
                                const stateValue = hazardStates[key] || 'unanalyzed';
                                
                                // Use GUI button colors
                                let baseColor;
                                if (stateValue === 'screened') {
                                    baseColor = '#6b7280'; // gray
                                } else if (stateValue === 'unanalyzed') {
                                    baseColor = '#3b82f6'; // blue
                                } else if (stateValue === 'included') {
                                    baseColor = '#10b981'; // green
                                } else {
                                    baseColor = '#cccccc';
                                }
                                
                                const lighterColor = lightenColor(baseColor, 40);
                                tableHTML += `<td style="background-color: ${lighterColor}; text-align: center;">${stateValue}</td>`;
                            });
                            tableHTML += '</tr>';
                        }
                    });

                    tableHTML += '</tbody></table>';
                    return tableHTML;
                };

                // Helper function to create hazard details section
                const createHazardDetailsHTML = () => {
                    let detailsHTML = '<div class="hazard-details">';
                    
                    const collectLeafHazards = (nodes, list = [], path = []) => {
                        nodes.forEach(node => {
                            if (node.hidden) return; // Skip hidden hazards
                            const newPath = [...path, node.name];
                            if (node.children && node.children.length > 0) {
                                collectLeafHazards(node.children, list, newPath);
                            } else {
                                list.push({ hazard: node, path: newPath });
                            }
                        });
                        return list;
                    };

                    const leafHazards = collectLeafHazards(hazardList);

                    // Helper function to render event details
                    const renderEventDetails = (event) => {
                        let eventHTML = '<div style="margin: 10px 0; padding: 10px; background: #f9fafb; border: 1px solid #e5e7eb;">';
                        eventHTML += `<p><strong>${event.name}</strong></p>`;
                        if (event.eventDescription) {
                            eventHTML += `<p><em>${event.eventDescription}</em></p>`;
                        }
                        
                        if (event.occurrenceModel === 'frequency') {
                            eventHTML += '<p><strong>Occurrence:</strong> ';
                            if (event.frequencyDistribution === 'point' && event.pointEstimate) {
                                eventHTML += `${formatFrequency(parseFloat(event.pointEstimate))} ${event.frequencyUnits || '/yr'}`;
                            } else if (event.frequencyDistribution === 'gamma' && event.gammaShape && event.gammaScale) {
                                const mean = parseFloat(event.gammaShape) * parseFloat(event.gammaScale);
                                eventHTML += `${formatFrequency(mean)} ${event.frequencyUnits || '/yr'} (Gamma: \u03B1=${event.gammaShape}, \u03B8=${event.gammaScale})`;
                            } else if (event.frequencyDistribution === 'lognormal' && event.lognormalMean) {
                                eventHTML += `${formatFrequency(parseFloat(event.lognormalMean))} ${event.frequencyUnits || '/yr'} (Lognormal: Mean=${event.lognormalMean}, EF=${event.lognormalEF || 'N/A'})`;
                            } else if (event.frequencyDistribution === 'cni' && event.cniMean) {
                                eventHTML += `${formatFrequency(parseFloat(event.cniMean))} ${event.frequencyUnits || '/yr'} (CNI: Mean=${event.cniMean})`;
                            }
                            eventHTML += '</p>';
                        } else if (event.occurrenceModel === 'nureg-2169-fire') {
                            const selections = event.fireIgnitionSelections || {};
                            const selectedItems = NUREG2169_FIRE_IGNITION_DATA.filter(item => selections[item.bin]);
                            const totalTableMean = selectedItems.reduce((sum, item) => sum + item.mean, 0);
                            const componentCount = event.fireIgnitionComponentCount || 1;
                            const propagationFactor = parseFloat(event.fireIgnitionPropagationFactor) || 1;
                            const finalMean = (totalTableMean / componentCount) * propagationFactor;
                            const componentInfo = componentCount > 1 ? `, ${componentCount} components` : '';
                            const propInfo = propagationFactor !== 1 ? `, prop. factor ${propagationFactor}` : '';
                            eventHTML += `<p><strong>Occurrence:</strong> NUREG-2169 Fire Ignition - ${formatFrequency(finalMean)} /yr (${selectedItems.length} ignition sources selected${componentInfo}${propInfo})</p>`;
                        } else {
                            eventHTML += `<p><strong>Occurrence:</strong> ${event.occurrenceModel}</p>`;
                        }

                        if (event.description) {
                            // Strip out all header tags from supporting information and remove font-family
                            const cleanedDescription = stripFontFamily(event.description)
                                .replace(/<h1[^>]*>/gi, '<p><strong>')
                                .replace(/<\/h1>/gi, '</strong></p>')
                                .replace(/<h2[^>]*>/gi, '<p><strong>')
                                .replace(/<\/h2>/gi, '</strong></p>')
                                .replace(/<h3[^>]*>/gi, '<p><strong>')
                                .replace(/<\/h3>/gi, '</strong></p>')
                                .replace(/<h4[^>]*>/gi, '<p><strong>')
                                .replace(/<\/h4>/gi, '</strong></p>')
                                .replace(/<h5[^>]*>/gi, '<p><strong>')
                                .replace(/<\/h5>/gi, '</strong></p>')
                                .replace(/<h6[^>]*>/gi, '<p><strong>')
                                .replace(/<\/h6>/gi, '</strong></p>');
                            eventHTML += `<div style="margin-top: 10px;"><strong>Supporting Information:</strong><div>${cleanedDescription}</div></div>`;
                        }
                        eventHTML += '</div>';
                        return eventHTML;
                    };

                    leafHazards.forEach(({ hazard, path }) => {
                        // Group states by their source of information
                        // Key: source state ID (or 'self' for states with their own data)
                        // Value: { sourceStateId, stateIds: [], analysisData }
                        const infoGroups = {};
                        
                        DEFAULT_OPERATING_STATES.forEach(state => {
                            const key = `${hazard.id}_${state.id}`;
                            const stateValue = hazardStates[key];
                            const analysisData = hazardAnalysisData[key];
                            
                            if (stateValue === 'included' && analysisData) {
                                // Determine the source of information
                                const sourceStateId = analysisData.useInfoFrom || state.id;
                                
                                if (!infoGroups[sourceStateId]) {
                                    // Get the actual analysis data from the source
                                    let sourceData = analysisData;
                                    if (analysisData.useInfoFrom) {
                                        const sourceKey = `${hazard.id}_${analysisData.useInfoFrom}`;
                                        sourceData = hazardAnalysisData[sourceKey] || analysisData;
                                    }
                                    
                                    infoGroups[sourceStateId] = {
                                        sourceStateId: sourceStateId,
                                        stateIds: [],
                                        analysisData: sourceData
                                    };
                                }
                                infoGroups[sourceStateId].stateIds.push(state.id);
                            }
                        });
                        
                        // Render each group
                        Object.values(infoGroups).forEach(group => {
                            const { sourceStateId, stateIds, analysisData } = group;
                            
                            // Get state names for display
                            const stateNames = stateIds.map(sid => {
                                const state = DEFAULT_OPERATING_STATES.find(s => s.id === sid);
                                const customData = operatingStateData[sid];
                                return customData?.name || state?.name || sid;
                            });
                            
                            detailsHTML += '<div style="margin: 6px 0; border: 1px solid #ccc; padding: 6px; page-break-inside: avoid;">';
                            detailsHTML += `<h3 style="color: #2c3e50;">${path.join(' > ')}</h3>`;
                            
                            // Show which operating states use this information
                            if (stateIds.length > 1) {
                                detailsHTML += `<p><strong>Operating States:</strong> ${stateNames.join(', ')}</p>`;
                                detailsHTML += `<p style="font-style: italic; color: #666;">(Information shared across these operating states)</p>`;
                            } else {
                                detailsHTML += `<p><strong>Operating State:</strong> ${stateNames[0]}</p>`;
                            }

                            if (analysisData.applicableEvents && analysisData.applicableEvents.length > 0) {
                                detailsHTML += '<h4>Applicable Events:</h4>';
                                analysisData.applicableEvents.forEach(event => {
                                    detailsHTML += renderEventDetails(event);
                                });
                            }

                            detailsHTML += '</div>';
                        });
                    });

                    detailsHTML += '</div>';
                    return detailsHTML;
                };

                // Helper function to create screened hazards list
                const createScreenedHazardsHTML = () => {
                    let screenedHTML = '<ul>';
                    
                    const collectLeafHazards = (nodes, list = [], path = []) => {
                        nodes.forEach(node => {
                            if (node.hidden) return; // Skip hidden hazards
                            const newPath = [...path, node.name];
                            if (node.children && node.children.length > 0) {
                                collectLeafHazards(node.children, list, newPath);
                            } else {
                                list.push({ hazard: node, path: newPath });
                            }
                        });
                        return list;
                    };

                    const leafHazards = collectLeafHazards(hazardList);
                    let hasScreened = false;

                    // Helper to get screening type text
                    const getScreeningTypeText = (occurrenceModel) => {
                        switch (occurrenceModel) {
                            case 'screened-low-freq': return 'Screened due to low frequency';
                            case 'screened-low-consequence': return 'Screened due to low consequence';
                            case 'screened-not-applicable': return 'Screened due to not being applicable';
                            default: return 'Screened';
                        }
                    };

                    leafHazards.forEach(({ hazard, path }) => {
                        let allScreened = true;
                        DEFAULT_OPERATING_STATES.forEach(state => {
                            const key = `${hazard.id}_${state.id}`;
                            if (hazardStates[key] !== 'screened') {
                                allScreened = false;
                            }
                        });

                        if (allScreened) {
                            hasScreened = true;
                            screenedHTML += `<li>${path.join(' > ')}`;
                            
                            // Collect screening info from any state (they should all be screened)
                            let screeningDetails = [];
                            DEFAULT_OPERATING_STATES.forEach(state => {
                                const key = `${hazard.id}_${state.id}`;
                                const analysisData = hazardAnalysisData[key];
                                if (analysisData && analysisData.applicableEvents) {
                                    analysisData.applicableEvents.forEach(event => {
                                        const screeningType = getScreeningTypeText(event.occurrenceModel);
                                        const supportingInfo = event.description || '';
                                        // Only add if we haven't added this exact info already
                                        const infoKey = `${screeningType}|${supportingInfo}`;
                                        if (!screeningDetails.find(d => `${d.type}|${d.info}` === infoKey)) {
                                            screeningDetails.push({ type: screeningType, info: supportingInfo });
                                        }
                                    });
                                }
                            });
                            
                            if (screeningDetails.length > 0) {
                                screenedHTML += '<ul>';
                                screeningDetails.forEach(detail => {
                                    screenedHTML += `<li><strong>${detail.type}</strong>`;
                                    if (detail.info) {
                                        // Strip out all header tags from supporting information
                                        const cleanedInfo = detail.info
                                            .replace(/<h1[^>]*>/gi, '<p><strong>')
                                            .replace(/<\/h1>/gi, '</strong></p>')
                                            .replace(/<h2[^>]*>/gi, '<p><strong>')
                                            .replace(/<\/h2>/gi, '</strong></p>')
                                            .replace(/<h3[^>]*>/gi, '<p><strong>')
                                            .replace(/<\/h3>/gi, '</strong></p>')
                                            .replace(/<h4[^>]*>/gi, '<p><strong>')
                                            .replace(/<\/h4>/gi, '</strong></p>')
                                            .replace(/<h5[^>]*>/gi, '<p><strong>')
                                            .replace(/<\/h5>/gi, '</strong></p>')
                                            .replace(/<h6[^>]*>/gi, '<p><strong>')
                                            .replace(/<\/h6>/gi, '</strong></p>');
                                        screenedHTML += `<br/><span style="margin-left: 10px;">${cleanedInfo}</span>`;
                                    }
                                    screenedHTML += '</li>';
                                });
                                screenedHTML += '</ul>';
                            }
                            
                            screenedHTML += '</li>';
                        }
                    });

                    if (!hasScreened) {
                        screenedHTML += '<li><em>None</em></li>';
                    }
                    screenedHTML += '</ul>';
                    return screenedHTML;
                };

                // Helper function to create unanalyzed hazards list
                const createUnanalyzedHazardsHTML = () => {
                    let unanalyzedHTML = '<ul>';
                    
                    const collectLeafHazards = (nodes, list = [], path = []) => {
                        nodes.forEach(node => {
                            if (node.hidden) return; // Skip hidden hazards
                            const newPath = [...path, node.name];
                            if (node.children && node.children.length > 0) {
                                collectLeafHazards(node.children, list, newPath);
                            } else {
                                list.push({ hazard: node, path: newPath });
                            }
                        });
                        return list;
                    };

                    const leafHazards = collectLeafHazards(hazardList);
                    let hasUnanalyzed = false;

                    leafHazards.forEach(({ hazard, path }) => {
                        DEFAULT_OPERATING_STATES.forEach(state => {
                            const key = `${hazard.id}_${state.id}`;
                            if (!hazardStates[key] || hazardStates[key] === 'unanalyzed') {
                                hasUnanalyzed = true;
                                unanalyzedHTML += `<li>${path.join(' > ')} - ${state.name}</li>`;
                            }
                        });
                    });

                    if (!hasUnanalyzed) {
                        unanalyzedHTML += '<li><em>None</em></li>';
                    }
                    unanalyzedHTML += '</ul>';
                    return unanalyzedHTML;
                };

                // Helper function to create hazard curves section
                const createHazardCurvesHTML = () => {
                    let curvesHTML = '';
                    
                    const collectLeafHazards = (nodes, list = [], path = []) => {
                        nodes.forEach(node => {
                            if (node.hidden) return; // Skip hidden hazards
                            const newPath = [...path, node.name];
                            if (node.children && node.children.length > 0) {
                                collectLeafHazards(node.children, list, newPath);
                            } else {
                                list.push({ hazard: node, path: newPath });
                            }
                        });
                        return list;
                    };

                    const leafHazards = collectLeafHazards(hazardList);
                    let hasCurves = false;
                    
                    leafHazards.forEach(({ hazard, path }) => {
                        // Group states by their source of information
                        const infoGroups = {};
                        
                        DEFAULT_OPERATING_STATES.forEach(state => {
                            const key = `${hazard.id}_${state.id}`;
                            const stateValue = hazardStates[key];
                            const analysisData = hazardAnalysisData[key];
                            
                            if (stateValue === 'included' && analysisData) {
                                // Determine the source of information
                                const sourceStateId = analysisData.useInfoFrom || state.id;
                                
                                if (!infoGroups[sourceStateId]) {
                                    // Get the actual analysis data from the source
                                    let sourceData = analysisData;
                                    if (analysisData.useInfoFrom) {
                                        const sourceKey = `${hazard.id}_${analysisData.useInfoFrom}`;
                                        sourceData = hazardAnalysisData[sourceKey] || analysisData;
                                    }
                                    
                                    infoGroups[sourceStateId] = {
                                        sourceStateId: sourceStateId,
                                        stateIds: [],
                                        analysisData: sourceData
                                    };
                                }
                                infoGroups[sourceStateId].stateIds.push(state.id);
                            }
                        });
                        
                        // Process each group
                        Object.values(infoGroups).forEach(group => {
                            const { stateIds, analysisData } = group;
                            
                            if (analysisData && analysisData.applicableEvents) {
                                analysisData.applicableEvents.forEach(event => {
                                    if (event.occurrenceModel === 'hazard-curve' && event.hazardCurveData && event.hazardCurveData.length > 0) {
                                        hasCurves = true;
                                        
                                        // Filter valid data
                                        const validData = event.hazardCurveData.filter(row => 
                                            row.magnitude && row.frequency && 
                                            !isNaN(parseFloat(row.magnitude)) && !isNaN(parseFloat(row.frequency))
                                        );
                                        
                                        if (validData.length > 0) {
                                            // Get state names for display
                                            const stateNames = stateIds.map(sid => {
                                                const state = DEFAULT_OPERATING_STATES.find(s => s.id === sid);
                                                const customData = operatingStateData[sid];
                                                return customData?.name || state?.name || sid;
                                            });
                                            
                                            curvesHTML += `<div style="margin: 6px 0; page-break-inside: avoid;">`;
                                            curvesHTML += `<h3>${path.join(' > ')} - ${event.name || hazard.name}</h3>`;
                                            
                                            // Show which operating states use this information
                                            if (stateIds.length > 1) {
                                                curvesHTML += `<p><strong>Operating States:</strong> ${stateNames.join(', ')}</p>`;
                                                curvesHTML += `<p style="font-style: italic; color: #666;">(Information shared across these operating states)</p>`;
                                            } else {
                                                curvesHTML += `<p><strong>Operating State:</strong> ${stateNames[0]}</p>`;
                                            }
                                            
                                            // Create canvas for the graph with higher resolution
                                            const canvas = document.createElement('canvas');
                                            const width = 1200;  // Doubled for higher resolution
                                            const height = 800;  // Doubled for higher resolution
                                            canvas.width = width;
                                            canvas.height = height;
                                            const ctx = canvas.getContext('2d');
                                            
                                            const margin = { top: 40, right: 60, bottom: 120, left: 160 };
                                            const plotWidth = width - margin.left - margin.right;
                                            const plotHeight = height - margin.top - margin.bottom;
                                            
                                            // White background
                                            ctx.fillStyle = '#ffffff';
                                            ctx.fillRect(0, 0, width, height);
                                            
                                            // Find data ranges
                                            const magnitudes = validData.map(d => parseFloat(d.magnitude));
                                            const frequencies = validData.map(d => parseFloat(d.frequency));
                                            const minMag = Math.min(...magnitudes);
                                            const maxMag = Math.max(...magnitudes);
                                            const minFreq = Math.min(...frequencies);
                                            const maxFreq = Math.max(...frequencies);
                                            
                                            // Always use log scale for frequency (standard for hazard curves)
                                            const useLogScale = true;
                                            
                                            // Calculate nice axis ranges
                                            // Y-axis: round to powers of 10
                                            const logMin = Math.floor(Math.log10(minFreq));
                                            const logMax = Math.ceil(Math.log10(maxFreq));
                                            const yAxisMin = Math.pow(10, logMin);
                                            const yAxisMax = Math.pow(10, logMax);
                                            
                                            // X-axis: try to use integer values
                                            const xAxisMin = Math.floor(minMag);
                                            const xAxisMax = Math.ceil(maxMag);
                                            const xRange = xAxisMax - xAxisMin;
                                            const xTickCount = Math.min(Math.max(5, xRange), 10);
                                            
                                            // Draw major grid lines (light grey)
                                            ctx.strokeStyle = '#d3d3d3';
                                            ctx.lineWidth = 1;
                                            
                                            // Y-axis major grid lines (powers of 10)
                                            for (let i = logMin; i <= logMax; i++) {
                                                const freq = Math.pow(10, i);
                                                const logFreq = Math.log10(freq);
                                                const y = margin.top + plotHeight - ((logFreq - logMin) / (logMax - logMin)) * plotHeight;
                                                ctx.beginPath();
                                                ctx.moveTo(margin.left, y);
                                                ctx.lineTo(margin.left + plotWidth, y);
                                                ctx.stroke();
                                            }
                                            
                                            // Y-axis minor grid lines (between powers of 10)
                                            ctx.strokeStyle = '#e8e8e8';
                                            ctx.lineWidth = 0.5;
                                            for (let i = logMin; i < logMax; i++) {
                                                for (let j = 2; j <= 9; j++) {
                                                    const freq = j * Math.pow(10, i);
                                                    if (freq > yAxisMin && freq < yAxisMax) {
                                                        const logFreq = Math.log10(freq);
                                                        const y = margin.top + plotHeight - ((logFreq - logMin) / (logMax - logMin)) * plotHeight;
                                                        ctx.beginPath();
                                                        ctx.moveTo(margin.left, y);
                                                        ctx.lineTo(margin.left + plotWidth, y);
                                                        ctx.stroke();
                                                    }
                                                }
                                            }
                                            
                                            // X-axis major grid lines
                                            ctx.strokeStyle = '#d3d3d3';
                                            ctx.lineWidth = 1;
                                            for (let i = 0; i <= xTickCount; i++) {
                                                const mag = xAxisMin + (xAxisMax - xAxisMin) * i / xTickCount;
                                                const x = margin.left + ((mag - xAxisMin) / (xAxisMax - xAxisMin)) * plotWidth;
                                                ctx.beginPath();
                                                ctx.moveTo(x, margin.top);
                                                ctx.lineTo(x, margin.top + plotHeight);
                                                ctx.stroke();
                                            }
                                            
                                            // Draw plot border
                                            ctx.strokeStyle = '#000';
                                            ctx.lineWidth = 2;
                                            ctx.strokeRect(margin.left, margin.top, plotWidth, plotHeight);
                                            
                                            // Plot dotted line between points
                                            ctx.strokeStyle = 'blue';
                                            ctx.lineWidth = 3;
                                            ctx.setLineDash([5, 5]);  // Dotted line pattern
                                            ctx.beginPath();
                                            validData.forEach((d, i) => {
                                                const mag = parseFloat(d.magnitude);
                                                const x = margin.left + ((mag - xAxisMin) / (xAxisMax - xAxisMin)) * plotWidth;
                                                const freq = parseFloat(d.frequency);
                                                const logFreq = Math.log10(freq);
                                                const y = margin.top + plotHeight - ((logFreq - logMin) / (logMax - logMin)) * plotHeight;
                                                
                                                if (i === 0) {
                                                    ctx.moveTo(x, y);
                                                } else {
                                                    ctx.lineTo(x, y);
                                                }
                                            });
                                            ctx.stroke();
                                            ctx.setLineDash([]);  // Reset to solid line
                                            
                                            // Plot data points (solid circles)
                                            validData.forEach((d, i) => {
                                                const mag = parseFloat(d.magnitude);
                                                const x = margin.left + ((mag - xAxisMin) / (xAxisMax - xAxisMin)) * plotWidth;
                                                const freq = parseFloat(d.frequency);
                                                const logFreq = Math.log10(freq);
                                                const y = margin.top + plotHeight - ((logFreq - logMin) / (logMax - logMin)) * plotHeight;
                                                
                                                // Draw point
                                                ctx.fillStyle = 'blue';
                                                ctx.beginPath();
                                                ctx.arc(x, y, 6, 0, 2 * Math.PI);
                                                ctx.fill();
                                            });
                                            
                                            // X-axis label
                                            ctx.fillStyle = '#000';
                                            ctx.font = 'bold 24px Arial';
                                            ctx.textAlign = 'center';
                                            ctx.fillText(event.hazardMagnitudeUnits || 'Magnitude', margin.left + plotWidth/2, height - 20);
                                            
                                            // Y-axis label (rotated)
                                            ctx.save();
                                            ctx.translate(30, margin.top + plotHeight/2);
                                            ctx.rotate(-Math.PI/2);
                                            ctx.textAlign = 'center';
                                            ctx.font = 'bold 24px Arial';
                                            ctx.fillText(`Frequency (${event.hazardFrequencyUnits || '/yr'})`, 0, 0);
                                            ctx.restore();
                                            
                                            // X-axis ticks and labels
                                            ctx.font = '20px Arial';
                                            ctx.textAlign = 'center';
                                            for (let i = 0; i <= xTickCount; i++) {
                                                const mag = xAxisMin + (xAxisMax - xAxisMin) * i / xTickCount;
                                                const x = margin.left + ((mag - xAxisMin) / (xAxisMax - xAxisMin)) * plotWidth;
                                                
                                                // Tick mark
                                                ctx.strokeStyle = '#000';
                                                ctx.lineWidth = 2;
                                                ctx.beginPath();
                                                ctx.moveTo(x, margin.top + plotHeight);
                                                ctx.lineTo(x, margin.top + plotHeight + 10);
                                                ctx.stroke();
                                                
                                                // Label
                                                ctx.fillStyle = '#000';
                                                ctx.fillText(Math.round(mag).toString(), x, margin.top + plotHeight + 40);
                                            }
                                            
                                            // Y-axis ticks and labels (powers of 10)
                                            ctx.textAlign = 'right';
                                            ctx.textBaseline = 'middle';
                                            for (let i = logMin; i <= logMax; i++) {
                                                const freq = Math.pow(10, i);
                                                const logFreq = Math.log10(freq);
                                                const y = margin.top + plotHeight - ((logFreq - logMin) / (logMax - logMin)) * plotHeight;
                                                
                                                // Tick mark
                                                ctx.strokeStyle = '#000';
                                                ctx.lineWidth = 2;
                                                ctx.beginPath();
                                                ctx.moveTo(margin.left - 10, y);
                                                ctx.lineTo(margin.left, y);
                                                ctx.stroke();
                                                
                                                // Label
                                                ctx.fillStyle = '#000';
                                                ctx.fillText(freq.toExponential(0), margin.left - 20, y);
                                            }
                                            
                                            // Convert canvas to data URL
                                            const imageData = canvas.toDataURL('image/png');
                                            curvesHTML += `<div style="text-align: center;"><img src="${imageData}" alt="Hazard Curve" width="600"></div>`;
                                            curvesHTML += `</div>`;
                                        }
                                    }
                                });
                            }
                        });
                    });
                    
                    if (!hasCurves) {
                        curvesHTML = '<p><em>No hazard curves defined.</em></p>';
                    }
                    
                    return curvesHTML;
                };

                // Helper function to create fire hazards section
                const createFireHazardsHTML = () => {
                    let fireHTML = '';
                    
                    const collectLeafHazards = (nodes, list = [], path = []) => {
                        nodes.forEach(node => {
                            if (node.hidden) return; // Skip hidden hazards
                            const newPath = [...path, node.name];
                            if (node.children && node.children.length > 0) {
                                collectLeafHazards(node.children, list, newPath);
                            } else {
                                list.push({ hazard: node, path: newPath });
                            }
                        });
                        return list;
                    };

                    const leafHazards = collectLeafHazards(hazardList);
                    let hasFireHazards = false;
                    
                    leafHazards.forEach(({ hazard, path }) => {
                        // Group states by their source of information
                        const infoGroups = {};
                        
                        DEFAULT_OPERATING_STATES.forEach(state => {
                            const key = `${hazard.id}_${state.id}`;
                            const stateValue = hazardStates[key];
                            const analysisData = hazardAnalysisData[key];
                            
                            if (stateValue === 'included' && analysisData) {
                                // Determine the source of information
                                const sourceStateId = analysisData.useInfoFrom || state.id;
                                
                                if (!infoGroups[sourceStateId]) {
                                    // Get the actual analysis data from the source
                                    let sourceData = analysisData;
                                    if (analysisData.useInfoFrom) {
                                        const sourceKey = `${hazard.id}_${analysisData.useInfoFrom}`;
                                        sourceData = hazardAnalysisData[sourceKey] || analysisData;
                                    }
                                    
                                    infoGroups[sourceStateId] = {
                                        sourceStateId: sourceStateId,
                                        stateIds: [],
                                        analysisData: sourceData
                                    };
                                }
                                infoGroups[sourceStateId].stateIds.push(state.id);
                            }
                        });
                        
                        // Process each group
                        Object.values(infoGroups).forEach(group => {
                            const { stateIds, analysisData } = group;
                            
                            if (analysisData && analysisData.applicableEvents) {
                                analysisData.applicableEvents.forEach(event => {
                                    if (event.occurrenceModel === 'nureg-2169-fire') {
                                        const selections = event.fireIgnitionSelections || {};
                                        const selectedItems = NUREG2169_FIRE_IGNITION_DATA.filter(item => selections[item.bin]);
                                        
                                        if (selectedItems.length > 0) {
                                            hasFireHazards = true;
                                            const totalTableMean = selectedItems.reduce((sum, item) => sum + item.mean, 0);
                                            const componentCount = event.fireIgnitionComponentCount || 1;
                                            const propagationFactor = parseFloat(event.fireIgnitionPropagationFactor) || 1;
                                            const finalMean = (totalTableMean / componentCount) * propagationFactor;
                                            
                                            // Get state names for display
                                            const stateNames = stateIds.map(sid => {
                                                const state = DEFAULT_OPERATING_STATES.find(s => s.id === sid);
                                                const customData = operatingStateData[sid];
                                                return customData?.name || state?.name || sid;
                                            });
                                            
                                            fireHTML += '<div style="margin: 6px 0; page-break-inside: avoid; border: 1px solid #ccc; padding: 6px;">';
                                            fireHTML += '<h3 style="color: #c2410c;">' + path.join(' > ') + ' - ' + (event.name || hazard.name) + '</h3>';
                                            
                                            // Show which operating states use this information
                                            if (stateIds.length > 1) {
                                                fireHTML += '<p><strong>Operating States:</strong> ' + stateNames.join(', ') + '</p>';
                                                fireHTML += '<p style="font-style: italic; color: #666;">(Information shared across these operating states)</p>';
                                            } else {
                                                fireHTML += '<p><strong>Operating State:</strong> ' + stateNames[0] + '</p>';
                                            }
                                            
                                            fireHTML += '<p><strong>Number of Components:</strong> ' + componentCount + '</p>';
                                            fireHTML += '<p><strong>Propagation Factor:</strong> ' + propagationFactor + '</p>';
                                            fireHTML += '<p><strong>Table Frequency:</strong> ' + totalTableMean.toExponential(2) + ' /yr</p>';
                                            fireHTML += '<p><strong>Final Frequency:</strong> ' + finalMean.toExponential(2) + ' /yr (Table  ' + componentCount + '  ' + propagationFactor + ')</p>';
                                            fireHTML += '<p><strong>Number of Selected Ignition Sources:</strong> ' + selectedItems.length + '</p>';
                                            
                                            // Create table of selected fire ignition sources
                                            fireHTML += '<table style="font-size: 8pt; margin-top: 10px;">';
                                            fireHTML += '<thead><tr style="background-color: #fb923c; color: white;">';
                                            fireHTML += '<th style="padding: 2px; text-align: center;">Bin</th>';
                                            fireHTML += '<th style="padding: 2px; text-align: center;">Location</th>';
                                            fireHTML += '<th style="padding: 2px; text-align: center;">Ignition Source</th>';
                                            fireHTML += '<th style="padding: 2px; text-align: center;">Mean (/yr)</th>';
                                            fireHTML += '<th style="padding: 2px; text-align: center;">EF</th>';
                                            fireHTML += '</tr></thead><tbody>';
                                            
                                            selectedItems.forEach(item => {
                                                fireHTML += '<tr>';
                                                fireHTML += '<td style="padding: 2px;">' + item.bin + '</td>';
                                                fireHTML += '<td style="padding: 2px;">' + item.location + '</td>';
                                                fireHTML += '<td style="padding: 2px;">' + item.ignitionSource + '</td>';
                                                fireHTML += '<td style="padding: 2px; text-align: right;">' + item.mean.toExponential(2) + '</td>';
                                                fireHTML += '<td style="padding: 2px; text-align: right;">' + item.ef.toFixed(2) + '</td>';
                                                fireHTML += '</tr>';
                                            });
                                            
                                            fireHTML += '</tbody></table>';
                                            fireHTML += '<p style="font-size: 8pt; margin-top: 10px; color: #666;"><em>Fire ignition frequencies are lognormally distributed. EF = Error Factor (95th/50th percentile ratio). Source: NUREG-2169 Table 4-4.</em></p>';
                                            fireHTML += '</div>';
                                        }
                                    }
                                });
                            }
                        });
                    });
                    
                    if (!hasFireHazards) {
                        fireHTML = '<p><em>No NUREG-2169 fire ignition hazards defined.</em></p>';
                    }
                    
                    return fireHTML;
                };

                // Helper function to create hazard probabilities table
                const createHazardProbabilitiesHTML = () => {
                    let tableHTML = '<table><thead><tr>';
                    tableHTML += '<th>Potential Hazards</th>';
                    DEFAULT_OPERATING_STATES.forEach(state => {
                        const customData = operatingStateData[state.id];
                        const displayName = customData?.name || state.name;
                        tableHTML += `<th>${state.id}<br/>${displayName}</th>`;
                    });
                    tableHTML += '</tr></thead><tbody>';

                    const collectLeafHazards = (nodes, list = []) => {
                        nodes.forEach(node => {
                            if (node.hidden) return; // Skip hidden hazards
                            if (node.children && node.children.length > 0) {
                                collectLeafHazards(node.children, list);
                            } else {
                                list.push(node);
                            }
                        });
                        return list;
                    };

                    const leafHazards = collectLeafHazards(hazardList);
                    
                    // Calculate total duration for each operating state
                    const stateDurations = {};
                    // Count number of periods for each operating state
                    const statePeriodCounts = {};
                    DEFAULT_OPERATING_STATES.forEach(state => {
                        stateDurations[state.id] = 0;
                        statePeriodCounts[state.id] = 0;
                    });
                    
                    if (operatingSchedule.periods) {
                        operatingSchedule.periods.forEach(period => {
                            const duration = period.endDay - period.startDay;
                            stateDurations[period.stateId] = (stateDurations[period.stateId] || 0) + duration;
                            statePeriodCounts[period.stateId] = (statePeriodCounts[period.stateId] || 0) + 1;
                        });
                    }
                    
                    leafHazards.forEach(hazard => {
                        let hasIncluded = false;
                        DEFAULT_OPERATING_STATES.forEach(state => {
                            const key = `${hazard.id}_${state.id}`;
                            if (hazardStates[key] === 'included') {
                                hasIncluded = true;
                            }
                        });

                        if (hasIncluded) {
                            tableHTML += '<tr>';
                            tableHTML += `<td>${hazard.name}</td>`;
                            
                            DEFAULT_OPERATING_STATES.forEach(state => {
                                const key = `${hazard.id}_${state.id}`;
                                const stateValue = hazardStates[key];
                                let analysisData = hazardAnalysisData[key];
                                
                                // If this state uses info from another state, get that data
                                if (analysisData && analysisData.useInfoFrom) {
                                    const sourceKey = `${hazard.id}_${analysisData.useInfoFrom}`;
                                    const sourceData = hazardAnalysisData[sourceKey];
                                    if (sourceData) {
                                        analysisData = sourceData;
                                    }
                                }
                                
                                // Only process if this state is included and has analysis data
                                if (stateValue === 'included' && analysisData && analysisData.applicableEvents) {
                                    // Calculate probability for this state
                                    let freq = null;
                                    let freqUnits = '/yr';
                                    let probPerOppResult = null; // For probability per opportunity model
                                    let hazardCurveData = null; // For hazard curve model
                                    
                                    analysisData.applicableEvents.forEach(event => {
                                        if (event.occurrenceModel === 'frequency') {
                                            if (event.frequencyDistribution === 'point' && event.pointEstimate) {
                                                freq = parseFloat(event.pointEstimate);
                                            } else if (event.frequencyDistribution === 'gamma' && event.gammaShape && event.gammaScale) {
                                                freq = parseFloat(event.gammaShape) * parseFloat(event.gammaScale);
                                            } else if (event.frequencyDistribution === 'lognormal' && event.lognormalMean) {
                                                freq = parseFloat(event.lognormalMean);
                                            } else if (event.frequencyDistribution === 'cni' && event.cniMean) {
                                                freq = parseFloat(event.cniMean);
                                            }
                                            freqUnits = event.frequencyUnits || '/yr';
                                        } else if (event.occurrenceModel === 'nureg-2169-fire') {
                                            // Handle NUREG-2169 Fire Ignition
                                            const selections = event.fireIgnitionSelections || {};
                                            const selectedItems = NUREG2169_FIRE_IGNITION_DATA.filter(item => selections[item.bin]);
                                            const totalTableMean = selectedItems.reduce((sum, item) => sum + item.mean, 0);
                                            const componentCount = event.fireIgnitionComponentCount || 1;
                                            const propagationFactor = parseFloat(event.fireIgnitionPropagationFactor) || 1;
                                            const finalMean = (totalTableMean / componentCount) * propagationFactor;
                                            if (finalMean > 0) {
                                                freq = finalMean;
                                                freqUnits = '/yr';
                                            }
                                        } else if (event.occurrenceModel === 'prob-per-opportunity') {
                                            // Handle Probability per Opportunity
                                            // Overall Probability = (Probability per Opportunity) * (Opportunities per Period) * (# Periods of that State)
                                            const dist = event.probabilityDistribution || 'cni';
                                            let prob = null;
                                            
                                            if (dist === 'beta' && event.betaAlpha && event.betaBeta) {
                                                // Beta mean = alpha / (alpha + beta)
                                                prob = parseFloat(event.betaAlpha) / (parseFloat(event.betaAlpha) + parseFloat(event.betaBeta));
                                            } else if (dist === 'lognormal' && event.probLognormalMean) {
                                                prob = parseFloat(event.probLognormalMean);
                                            } else if (dist === 'cni' && event.probCniMean) {
                                                prob = parseFloat(event.probCniMean);
                                            } else if (dist === 'point' && event.probPointEstimate) {
                                                prob = parseFloat(event.probPointEstimate);
                                            }
                                            
                                            const opportunitiesPerPeriod = parseInt(event.opportunitiesPerPeriod) || 0;
                                            const periodCount = statePeriodCounts[state.id] || 0;
                                            
                                            if (prob !== null && opportunitiesPerPeriod > 0 && periodCount > 0) {
                                                probPerOppResult = prob * opportunitiesPerPeriod * periodCount;
                                            }
                                        } else if (event.occurrenceModel === 'hazard-curve') {
                                            // Handle Hazard Curve - calculate probability for each magnitude bin
                                            if (event.hazardCurveData && event.hazardCurveData.length > 0) {
                                                const validData = event.hazardCurveData.filter(row => 
                                                    row.magnitude && row.frequency && 
                                                    !isNaN(parseFloat(row.magnitude)) && !isNaN(parseFloat(row.frequency))
                                                );
                                                if (validData.length > 0) {
                                                    hazardCurveData = validData;
                                                }
                                            }
                                        }
                                    });
                                    
                                    if (hazardCurveData !== null) {
                                        // Create a sub-table for hazard curve probabilities
                                        const durationDays = stateDurations[state.id] || 0;
                                        const digits = settings.frequencyDigits !== undefined ? settings.frequencyDigits : 2;
                                        
                                        let subTableHTML = '<table style="width: 100%; font-size: 7pt; margin: 0; border-collapse: collapse;">';
                                        subTableHTML += '<thead><tr style="background-color: #e5e7eb;">';
                                        subTableHTML += '<th style="padding: 1px 2px; text-align: center; border: 1px solid #ccc;">Mag</th>';
                                        subTableHTML += '<th style="padding: 1px 2px; text-align: center; border: 1px solid #ccc;">Prob</th>';
                                        subTableHTML += '</tr></thead><tbody>';
                                        
                                        hazardCurveData.forEach(row => {
                                            const magnitude = parseFloat(row.magnitude);
                                            const freqPerYr = parseFloat(row.frequency);
                                            const freqPerDay = freqPerYr / 365.0;
                                            const probability = 1 - Math.exp(-freqPerDay * durationDays);
                                            
                                            subTableHTML += '<tr>';
                                            subTableHTML += `<td style="padding: 1px 2px; text-align: center; border: 1px solid #ccc;">${magnitude}</td>`;
                                            subTableHTML += `<td style="padding: 1px 2px; text-align: center; border: 1px solid #ccc;">${probability.toExponential(digits)}</td>`;
                                            subTableHTML += '</tr>';
                                        });
                                        
                                        subTableHTML += '</tbody></table>';
                                        tableHTML += `<td style="padding: 2px;">${subTableHTML}</td>`;
                                    } else if (probPerOppResult !== null) {
                                        // Use probability per opportunity result directly
                                        const digits = settings.frequencyDigits !== undefined ? settings.frequencyDigits : 2;
                                        tableHTML += `<td style="text-align: center;">${probPerOppResult.toExponential(digits)}</td>`;
                                    } else if (freq !== null) {
                                        // Convert frequency to per day
                                        let freqPerDay = freq;
                                        if (freqUnits === '/yr' || freqUnits === '/y') {
                                            freqPerDay = freq / 365.0;
                                        } else if (freqUnits === '/hr' || freqUnits === '/h') {
                                            freqPerDay = freq * 24.0;
                                        }
                                        
                                        // Get duration in days for this state
                                        const durationDays = stateDurations[state.id] || 0;
                                        
                                        // Calculate probability: P = 1 - exp(-frequency * duration)
                                        const probability = 1 - Math.exp(-freqPerDay * durationDays);
                                        const digits = settings.frequencyDigits !== undefined ? settings.frequencyDigits : 2;
                                        
                                        tableHTML += `<td style="text-align: center;">${probability.toExponential(digits)}</td>`;
                                    } else {
                                        tableHTML += '<td style="text-align: center;">-</td>';
                                    }
                                } else {
                                    tableHTML += '<td style="text-align: center;">-</td>';
                                }
                            });
                            
                            tableHTML += '</tr>';
                        }
                    });

                    tableHTML += '</tbody></table>';
                    return tableHTML;
                };

                const hazardPlotImage = createHazardPlot();

                // Generate report HTML
                const reportFontFamily = getFontFamily();
                const reportHTML = `
<!DOCTYPE html>
<html xmlns:o='urn:schemas-microsoft-com:office:office' xmlns:w='urn:schemas-microsoft-com:office:word' xmlns='http://www.w3.org/TR/REC-html40'>
<head>
    <meta charset='utf-8'>
    <title>Hazard Analysis for ${facilityName}</title>
    <style>
        body {
            font-family: ${reportFontFamily};
            margin: 40px;
            line-height: 1.6;
            font-size: 10pt;
        }
        /* Styles for extended description and supporting information */
        body > div:first-of-type {
            font-size: 8pt;
            line-height: 1.0;
            margin: 6px;
        }
        body > div:first-of-type h1 {
            font-size: 14pt;
        }
        body > div:first-of-type h2 {
            font-size: 11pt;
        }
        body > div:first-of-type h3 {
            font-size: 9pt;
        }
        .hazard-details div[style*="Supporting Information"] {
            font-size: 8pt;
            line-height: 1.0;
            margin: 6px;
        }
        .hazard-details div[style*="Supporting Information"] h1 {
            font-size: 14pt;
        }
        .hazard-details div[style*="Supporting Information"] h2 {
            font-size: 11pt;
        }
        .hazard-details div[style*="Supporting Information"] h3 {
            font-size: 9pt;
        }
        h1 {
            color: #2c3e50;
            text-align: center;
            margin-bottom: 30px;
            border-bottom: 3px solid #667eea;
            padding-bottom: 10px;
            font-size: 16pt;
        }
        h2 {
            color: #2c3e50;
            margin-top: 30px;
            margin-bottom: 15px;
            border-bottom: 2px solid #667eea;
            padding-bottom: 5px;
            font-size: 13pt;
        }
        h3 {
            color: #34495e;
            margin-top: 20px;
            font-size: 11pt;
        }
        h4 {
            color: #34495e;
            margin-top: 15px;
            font-size: 10pt;
        }
        table {
            border-collapse: collapse;
            width: 90%;
            margin: 6px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 2px;
            text-align: left;
            font-size: 9pt;
        }
        th {
            background-color: #667eea;
            color: white;
            font-weight: bold;
            text-align: center;
        }
        tr:nth-child(even) {
            background-color: #f9fafb;
        }
        ul {
            margin: 10px 0;
        }
        li {
            margin: 5px 0;
        }
        img {
            max-width: 100%;
            height: auto;
        }
        .hazard-details {
            font-size: 7pt;
            line-height: 1.0;
        }
        .hazard-details h3 {
            font-size: 8pt;
        }
        .hazard-details h4 {
            font-size: 7pt;
        }
        .hazard-details h2 {
            font-size: 6pt;
        }
        .hazard-details p {
            font-size: 7pt;
            line-height: 1.0;
        }
        .hazard-details div {
            line-height: 1.0;
            margin: 10px;
        }
        .hazard-details div h1 {
            font-size: 7pt;
        }
        .hazard-details div h2 {
            font-size: 6.5pt;
        }
        .hazard-details div h3 {
            font-size: 6pt;
        }
        .footer {
            margin-top: 40px;
            text-align: center;
            font-size: 9pt;
            color: #666;
            border-top: 1px solid #ddd;
            padding-top: 20px;
        }
    </style>
</head>
<body>
    <h1>Hazard Analysis for ${facilityName}</h1>
    
    ${extendedDescription ? `<div style="margin: 6px 0;">${stripFontFamily(extendedDescription)}</div>` : ''}
    
    <h2>Operating State Information</h2>
    ${createOperatingStateInfoHTML()}
    
    <h2>Anticipated Schedule</h2>
    ${createTimelineHTML()}
    
    <h2>Hazard Summary Table</h2>
    ${createHazardTableHTML()}
    
    <h2>Hazard Probabilities</h2>
    <p>Probabilities calculated using P = 1 - exp(-Hazard_Frequency * Duration), where duration is the total time in each operating state.</p>
    ${createHazardProbabilitiesHTML()}
    
    <h2>Hazard Details</h2>
    ${createHazardDetailsHTML()}
    
    <h2>Hazard Plot</h2>
    <div style="text-align: center; margin: 6px 0;">
        <img src="${hazardPlotImage}" alt="Hazard Plot" width="468">
    </div>
    
    <h2>Hazard Curves</h2>
    ${createHazardCurvesHTML()}
    
    <h2>Fire Hazards</h2>
    ${createFireHazardsHTML()}
    
    <h2>Screened Hazards</h2>
    ${createScreenedHazardsHTML()}
    
    <h2>Unanalyzed Hazards</h2>
    ${createUnanalyzedHazardsHTML()}
    
    <div class="footer">
        <p><strong>KUREAS-HA v1.0</strong> | Hazard Analysis</p>
        <p>Curtis Lee Smith - ${new Date().getFullYear()}</p>
        <p>Generated: ${new Date().toLocaleString()}</p>
    </div>
</body>
</html>`;

                // Create blob and download
                const blob = new Blob(['\ufeff', reportHTML], {
                    type: 'application/msword'
                });
                
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.download = `Hazard-Analysis-${facilityName.replace(/\s+/g, '-')}.doc`;
                link.href = url;
                link.click();
                URL.revokeObjectURL(url);
            };

            // Export to Markdown
            const exportToMarkdown = () => {
                if (!facilityName) {
                    alert('Please enter a facility name before exporting.');
                    return;
                }

                let markdown = `# Hazard Analysis for ${facilityName}\n\n`;
                
                if (extendedDescription) {
                    // Strip HTML tags for markdown
                    const tempDiv = document.createElement('div');
                    tempDiv.innerHTML = extendedDescription;
                    markdown += `## Facility Description\n\n${tempDiv.textContent}\n\n`;
                }

                // Operating States Section
                markdown += `## Facility Operating States\n\n`;
                DEFAULT_OPERATING_STATES.forEach(state => {
                    const customData = operatingStateData[state.id];
                    const displayName = customData?.name || state.name;
                    const displayDescription = customData?.description || state.description;
                    const displayExtended = customData?.extendedDescription || '';
                    
                    markdown += `### ${state.id}: ${displayName}\n\n`;
                    markdown += `**Description:** ${displayDescription}\n\n`;
                    
                    if (displayExtended) {
                        // Strip HTML tags for markdown
                        const tempDiv = document.createElement('div');
                        tempDiv.innerHTML = displayExtended;
                        const extendedText = tempDiv.textContent.trim();
                        if (extendedText) {
                            markdown += `${extendedText}\n\n`;
                        }
                    }
                });

                // Anticipated Schedule Section
                markdown += `## Anticipated Operating Schedule\n\n`;
                markdown += `**Period:** ${operatingSchedule.periodYears} year(s)\n\n`;
                if (operatingSchedule.periods && operatingSchedule.periods.length > 0) {
                    markdown += `| Start Day | End Day | Operating State |\n`;
                    markdown += `|-----------|---------|----------------|\n`;
                    operatingSchedule.periods.forEach(period => {
                        const state = DEFAULT_OPERATING_STATES.find(s => s.id === period.stateId);
                        const customData = operatingStateData[period.stateId];
                        const stateName = customData?.name || (state ? state.name : period.stateId);
                        markdown += `| ${period.startDay} | ${period.endDay} | ${period.stateId} - ${stateName} |\n`;
                    });
                    markdown += `\n`;
                }

                markdown += `## Hazard Summary\n\n`;
                markdown += `| Hazard | Status |\n`;
                markdown += `|--------|--------|\n`;

                const collectLeafHazards = (nodes, list = [], path = []) => {
                    nodes.forEach(node => {
                        if (node.hidden) return; // Skip hidden hazards
                        const newPath = [...path, node.name];
                        if (node.children && node.children.length > 0) {
                            collectLeafHazards(node.children, list, newPath);
                        } else {
                            list.push({ hazard: node, path: newPath });
                        }
                    });
                    return list;
                };

                const leafHazards = collectLeafHazards(hazardList);
                
                leafHazards.forEach(({ hazard, path }) => {
                    let hasIncluded = false;
                    DEFAULT_OPERATING_STATES.forEach(state => {
                        const key = `${hazard.id}_${state.id}`;
                        if (hazardStates[key] === 'included') {
                            hasIncluded = true;
                        }
                    });
                    
                    if (hasIncluded) {
                        markdown += `| ${path.join(' > ')} | Included |\n`;
                    }
                });

                markdown += `\n## Detailed Information\n\n`;

                leafHazards.forEach(({ hazard, path }) => {
                    DEFAULT_OPERATING_STATES.forEach(state => {
                        const key = `${hazard.id}_${state.id}`;
                        const stateValue = hazardStates[key];
                        const analysisData = hazardAnalysisData[key];

                        if (stateValue === 'included' && analysisData) {
                            markdown += `### ${path.join(' > ')} - ${state.name}\n\n`;
                            
                            if (analysisData.applicableEvents && analysisData.applicableEvents.length > 0) {
                                analysisData.applicableEvents.forEach(event => {
                                    markdown += `**Event:** ${event.name}\n\n`;
                                    if (event.eventDescription) {
                                        markdown += `*Description:* ${event.eventDescription}\n\n`;
                                    }
                                    
                                    if (event.occurrenceModel === 'frequency') {
                                        markdown += `**Occurrence Model:** Frequency\n\n`;
                                        if (event.frequencyDistribution === 'point') {
                                            markdown += `- Point Estimate: ${event.pointEstimate} ${event.frequencyUnits || '/yr'}\n\n`;
                                        } else if (event.frequencyDistribution === 'gamma') {
                                            markdown += `- Distribution: Gamma\n`;
                                            markdown += `- Shape (\u03B1): ${event.gammaShape}\n`;
                                            markdown += `- Scale (\u03B8): ${event.gammaScale}\n\n`;
                                        } else if (event.frequencyDistribution === 'lognormal') {
                                            markdown += `- Distribution: Lognormal\n`;
                                            markdown += `- Mean: ${event.lognormalMean}\n`;
                                            markdown += `- Error Factor: ${event.lognormalEF}\n\n`;
                                        } else if (event.frequencyDistribution === 'cni') {
                                            markdown += `- Distribution: Constrained Non-Informative\n`;
                                            markdown += `- Mean: ${event.cniMean}\n\n`;
                                        }
                                    }
                                    markdown += `---\n\n`;
                                });
                            }
                        }
                    });
                });

                const blob = new Blob([markdown], { type: 'text/markdown' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.download = `Hazard-Analysis-${facilityName.replace(/\s+/g, '-')}.md`;
                link.href = url;
                link.click();
                URL.revokeObjectURL(url);
                setShowExportModal(false);
            };

            // Export to SAPHIRE files
            const exportToSAPHIRE = () => {
                if (!facilityName) {
                    alert('Please enter a facility name before exporting.');
                    return;
                }

                // Helper function to sanitize names for SAPHIRE (no spaces, no commas, uppercase, max 48 chars)
                const sanitizeSaphireName = (name) => {
                    return name
                        .replace(/,/g, '')      // Remove commas
                        .replace(/\s+/g, '_')   // Replace spaces with underscores
                        .toUpperCase()          // Convert to uppercase
                        .substring(0, 48);      // Limit to 48 characters
                };

                // Create sanitized project name (no spaces for SAPHIRE compatibility)
                const sanitizedProjectName = facilityName.replace(/\s+/g, '-');

                // Collect all included hazards with frequency data
                const includedEvents = [];
                
                const collectLeafHazards = (nodes, list = [], path = []) => {
                    nodes.forEach(node => {
                        if (node.hidden) return; // Skip hidden hazards
                        const newPath = [...path, node.name];
                        if (node.children && node.children.length > 0) {
                            collectLeafHazards(node.children, list, newPath);
                        } else {
                            list.push({ hazard: node, path: newPath });
                        }
                    });
                    return list;
                };

                const leafHazards = collectLeafHazards(hazardList);
                
                leafHazards.forEach(({ hazard, path }) => {
                    DEFAULT_OPERATING_STATES.forEach(state => {
                        const key = `${hazard.id}_${state.id}`;
                        const stateValue = hazardStates[key];
                        const analysisData = hazardAnalysisData[key];

                        if (stateValue === 'included' && analysisData && analysisData.applicableEvents) {
                            analysisData.applicableEvents.forEach(event => {
                                if (event.occurrenceModel === 'frequency') {
                                    let meanFreq = null;
                                    let udT = '';
                                    let udValue = '';

                                    if (event.frequencyDistribution === 'point' && event.pointEstimate) {
                                        meanFreq = parseFloat(event.pointEstimate);
                                        udT = '';
                                        udValue = '';
                                    } else if (event.frequencyDistribution === 'gamma' && event.gammaShape && event.gammaScale) {
                                        meanFreq = parseFloat(event.gammaShape) * parseFloat(event.gammaScale);
                                        udT = 'G';
                                        udValue = event.gammaShape;
                                    } else if (event.frequencyDistribution === 'lognormal' && event.lognormalMean) {
                                        meanFreq = parseFloat(event.lognormalMean);
                                        udT = 'L';
                                        udValue = event.lognormalEF || '';
                                    } else if (event.frequencyDistribution === 'cni' && event.cniMean) {
                                        meanFreq = parseFloat(event.cniMean);
                                        udT = 'O';
                                        udValue = '';
                                    }

                                    if (meanFreq !== null) {
                                        includedEvents.push({
                                            name: sanitizeSaphireName(event.name || hazard.name),
                                            description: event.eventDescription || path.join(' > '),
                                            freq: meanFreq,
                                            udT: udT,
                                            udValue: udValue,
                                            hazardId: hazard.id,
                                            hazardPath: path
                                        });
                                    }
                                }
                            });
                        }
                    });
                });

                if (includedEvents.length === 0) {
                    alert('No hazards with frequency data found to export.');
                    return;
                }

                // Create BEI file (names already sanitized to 48 characters)
                let beiContent = `${sanitizedProjectName}       =\n`;
                beiContent += `* Name         ,FdT,UdC       ,UdT,  UdValue   ,  Prob     ,     Lambda,        Tau,    Mission,Init,PF,  UdValue2, Calc. Prob, Freq, Analysis Type , Phase Type      , Project\n`;
                
                includedEvents.forEach(event => {
                    const name = event.name.padEnd(48);
                    const prob = event.freq.toExponential(3).padStart(11);
                    const udValue = event.udValue ? parseFloat(event.udValue).toExponential(3).padStart(11) : '0.000E+000'.padStart(11);
                    
                    beiContent += `${name}, N,             , ${event.udT},${udValue},${prob}, 0.000E+000, 0.000E+000, 0.000E+000, I,    ,0.000E+000,${prob}, Y, RANDOM           , CD              , ${sanitizedProjectName}\n`;
                });

                // Create BED file (names already sanitized to 48 characters)
                let bedContent = `*KUREAS-HA Export\n`;
                bedContent += `${sanitizedProjectName}       =\n`;
                bedContent += `* Name         , Descriptions                                                      , Project\n`;
                
                includedEvents.forEach(event => {
                    const name = event.name.padEnd(48);
                    const desc = event.description.substring(0, 70).padEnd(70);
                    bedContent += `${name}, ${desc}, ${sanitizedProjectName}\n`;
                });

                // Create FTL file with overall tree and group trees
                let ftlContent = '';
                
                // Build hierarchical structure to identify groups and their children
                const buildGroupTrees = (nodes, parentPath = []) => {
                    const trees = [];
                    
                    nodes.forEach(node => {
                        if (node.hidden) return; // Skip hidden hazards
                        const currentPath = [...parentPath, node.name];
                        const hasChildren = node.children && node.children.length > 0;
                        
                        if (hasChildren) {
                            // This is a group - collect all events from leaf hazards under it
                            const groupEventNames = new Set();
                            
                            const collectLeavesFromNode = (n) => {
                                if (n.hidden) return; // Skip hidden hazards
                                if (n.children && n.children.length > 0) {
                                    n.children.forEach(child => collectLeavesFromNode(child));
                                } else {
                                    // This is a leaf hazard - find its events in includedEvents
                                    includedEvents.forEach(evt => {
                                        if (evt.hazardId === n.id) {
                                            groupEventNames.add(evt.name);
                                        }
                                    });
                                }
                            };
                            
                            collectLeavesFromNode(node);
                            
                            // Only add this group if it has included events with frequencies
                            if (groupEventNames.size > 0) {
                                // Create safe gate name using sanitizeSaphireName (no spaces, max 48 chars)
                                const gateName = sanitizeSaphireName(
                                    node.name
                                        .replace(/[^A-Za-z0-9\s\-_]/g, '')
                                        .toUpperCase()
                                );
                                    
                                trees.push({
                                    name: gateName,
                                    displayName: node.name,
                                    events: Array.from(groupEventNames)
                                });
                            }
                            
                            // Recursively process child groups
                            const childTrees = buildGroupTrees(node.children, currentPath);
                            trees.push(...childTrees);
                        }
                    });
                    
                    return trees;
                };
                
                // Build group trees from hazard list
                const groupTrees = buildGroupTrees(hazardList);
                
                // Create individual fault trees for each hazard group (only those with frequencies)
                groupTrees.forEach(group => {
                    ftlContent += `${sanitizedProjectName}, ${group.name} =\r\n`;
                    // Event names are already sanitized (no spaces, max 48 chars)
                    ftlContent += `${group.name.padEnd(16)} OR ${group.events.join(' ')}\r\n`;
                    ftlContent += `^EOS\r\n`;
                });

                // Download BEI file (with Windows line endings)
                const beiContentWindows = beiContent.replace(/\n/g, '\r\n');
                const beiBlob = new Blob([beiContentWindows], { type: 'text/plain' });
                const beiUrl = URL.createObjectURL(beiBlob);
                const beiLink = document.createElement('a');
                beiLink.download = `${facilityName.replace(/\s+/g, '-')}.BEI`;
                beiLink.href = beiUrl;
                beiLink.click();
                URL.revokeObjectURL(beiUrl);

                // Download BED file (with Windows line endings)
                const bedContentWindows = bedContent.replace(/\n/g, '\r\n');
                const bedBlob = new Blob([bedContentWindows], { type: 'text/plain' });
                const bedUrl = URL.createObjectURL(bedBlob);
                const bedLink = document.createElement('a');
                bedLink.download = `${facilityName.replace(/\s+/g, '-')}.BED`;
                bedLink.href = bedUrl;
                bedLink.click();
                URL.revokeObjectURL(bedUrl);

                // Download FTL file (already has Windows line endings)
                const ftlBlob = new Blob([ftlContent], { type: 'text/plain' });
                const ftlUrl = URL.createObjectURL(ftlBlob);
                const ftlLink = document.createElement('a');
                ftlLink.download = `${facilityName.replace(/\s+/g, '-')}.FTL`;
                ftlLink.href = ftlUrl;
                ftlLink.click();
                URL.revokeObjectURL(ftlUrl);

                setShowExportModal(false);
                alert(`Exported ${includedEvents.length} hazards to SAPHIRE files.`);
            };

            // Export Hazard Summary Table to Excel-compatible CSV
            const exportHazardSummaryToExcel = () => {
                // Helper function to get category for a frequency
                const getHazardCategory = (frequency) => {
                    if (frequency === null || frequency === undefined) return '';
                    const categories = settings.hazardCategories || [];
                    for (const cat of categories) {
                        const low = cat.lowBound || 0;
                        const high = cat.highBound === Infinity ? Number.MAX_VALUE : (cat.highBound || 0);
                        if (frequency > low && frequency <= high) {
                            return cat.name;
                        }
                        if (frequency === low && low === 0) {
                            return cat.name;
                        }
                    }
                    const highestCat = categories.find(c => c.highBound === Infinity);
                    if (highestCat && frequency > highestCat.lowBound) {
                        return highestCat.name;
                    }
                    return '';
                };

                const collectLeafHazards = (nodes, list = []) => {
                    nodes.forEach(node => {
                        if (node.hidden) return;
                        if (node.children && node.children.length > 0) {
                            collectLeafHazards(node.children, list);
                        } else {
                            list.push(node);
                        }
                    });
                    return list;
                };

                const leafHazards = collectLeafHazards(hazardList);
                
                // Build header row
                let headers = ['Potential Hazards', 'Frequency (/yr)'];
                if (settings.showHazardCategorization) {
                    headers.push('Categorization');
                }
                DEFAULT_OPERATING_STATES.forEach(state => {
                    const customData = operatingStateData[state.id];
                    const displayName = customData?.name || state.name;
                    headers.push(`${state.id} - ${displayName}`);
                });
                
                // Build data rows
                const rows = [];
                leafHazards.forEach(hazard => {
                    let hasIncluded = false;
                    DEFAULT_OPERATING_STATES.forEach(state => {
                        const key = `${hazard.id}_${state.id}`;
                        if (hazardStates[key] === 'included') {
                            hasIncluded = true;
                        }
                    });

                    if (hasIncluded) {
                        const frequency = calculateHazardFrequency(hazard.id);
                        const row = [hazard.name];
                        
                        // Check for hazard curve
                        let hasHazardCurve = false;
                        let maxFreq = 0;
                        DEFAULT_OPERATING_STATES.forEach(state => {
                            const key = `${hazard.id}_${state.id}`;
                            const analysisData = hazardAnalysisData[key];
                            if (analysisData && analysisData.applicableEvents) {
                                analysisData.applicableEvents.forEach(event => {
                                    if (event.occurrenceModel === 'hazard-curve' && event.hazardCurveData && event.hazardCurveData.length > 0) {
                                        hasHazardCurve = true;
                                        event.hazardCurveData.forEach(r => {
                                            const freq = parseFloat(r.frequency);
                                            if (!isNaN(freq) && freq > maxFreq) maxFreq = freq;
                                        });
                                    }
                                });
                            }
                        });
                        
                        if (hasHazardCurve) {
                            row.push('See Hazard Curve');
                            if (settings.showHazardCategorization) {
                                row.push(getHazardCategory(maxFreq));
                            }
                        } else {
                            row.push(frequency !== null ? frequency.toExponential(2) : '');
                            if (settings.showHazardCategorization) {
                                row.push(getHazardCategory(frequency));
                            }
                        }
                        
                        DEFAULT_OPERATING_STATES.forEach(state => {
                            const key = `${hazard.id}_${state.id}`;
                            const stateValue = hazardStates[key] || 'unanalyzed';
                            row.push(stateValue);
                        });
                        
                        rows.push(row);
                    }
                });
                
                // Convert to CSV with proper escaping
                const escapeCSV = (value) => {
                    const str = String(value);
                    if (str.includes(',') || str.includes('"') || str.includes('\n')) {
                        return '"' + str.replace(/"/g, '""') + '"';
                    }
                    return str;
                };
                
                let csvContent = headers.map(escapeCSV).join(',') + '\n';
                rows.forEach(row => {
                    csvContent += row.map(escapeCSV).join(',') + '\n';
                });
                
                // Add BOM for Excel UTF-8 compatibility
                const BOM = '\uFEFF';
                const blob = new Blob([BOM + csvContent], { type: 'text/csv;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.download = `${facilityName.replace(/\s+/g, '-')}-Hazard-Summary.csv`;
                link.href = url;
                link.click();
                URL.revokeObjectURL(url);
                
                setShowExportModal(false);
            };

            return (
                <div 
                    ref={containerRef} 
                    className={`flex flex-col ${getFontSizeClass()}`}
                    style={{
                        ...backgroundStyle,
                        fontFamily: getFontFamily(),
                        height: 'calc(100vh - 24px)'
                    }}
                >
                    {/* Header */}
                    <div className="bg-blue-600 text-white p-2 flex items-center justify-between">
                        <h1 className="text-lg font-bold">KUREAS-HA</h1><span className="text-sm opacity-90"> v1.0 Knowledgebase with Uncertainty for Risk Engineering Analysis of Systems: <strong>Hazard Analysis Module</strong></span>
                        <div className="flex gap-2">
                            <button
                                onClick={handleLoadHA}
                                className="px-3 py-1 bg-blue-900 text-white text-sm rounded hover:bg-blue-800"
                            >
                                Load <strong>HA</strong>
                            </button>
                            <button
                                onClick={handleSaveHA}
                                className="px-3 py-1 bg-blue-900 text-white text-sm rounded hover:bg-blue-800 disabled:opacity-50 disabled:cursor-not-allowed"
                                disabled={!hasData}
                            >
                                Save HA
                            </button>
                            <button
                                onClick={generateReport}
                                className="px-3 py-1 bg-blue-900 text-white text-sm rounded hover:bg-blue-800 disabled:opacity-50 disabled:cursor-not-allowed"
                                disabled={!hasData}
                            >
                                Report
                            </button>
                            <button
                                onClick={() => setShowExportModal(true)}
                                className="px-3 py-1 bg-blue-900 text-white text-sm rounded hover:bg-blue-800 disabled:opacity-50 disabled:cursor-not-allowed"
                                title="Export Hazard Data"
                                disabled={!hasData}
                            >
                                Export
                            </button>
                            <button
                                onClick={() => setShowHazardPlot(true)}
                                className="px-3 py-1 bg-blue-900 text-white text-sm rounded hover:bg-blue-800 disabled:opacity-50 disabled:cursor-not-allowed"
                                title="View Hazard Plot"
                                disabled={!hasData}
                            >
                                Hazard Plot
                            </button>
                            <button
                                onClick={() => setShowSettings(true)}
                                className="p-2 bg-blue-900 text-white rounded hover:bg-blue-800"
                                title="Project Settings"
                            >
                                <SettingsIcon />
                            </button>
                        </div>
                    </div>

                    {/* Pane A - Facility Information */}
                    <div 
                        className="border-b overflow-y-auto"
                        style={{ height: `${paneAHeight}vh` }}
                    >
                        <div className="p-4 space-y-3">
                            <div className="flex gap-4">
                                {/* Facility Name - 20% width */}
                                <div style={{ width: '20%' }}>
                                    <label className="block text-sm font-medium mb-1">Facility Name:</label>
                                    <input
                                        type="text"
                                        value={facilityName}
                                        onChange={(e) => setFacilityName(e.target.value)}
                                        className="w-full border rounded px-3 py-2"
                                        placeholder="Enter facility name"
                                    />
                                </div>

                                {/* Extended Description - remaining width */}
                                <div className="flex-1">
                                    <label className="block text-sm font-medium mb-1">Extended Description:</label>
                                    <div 
                                        className="border rounded p-3 bg-gray-50 cursor-pointer hover:bg-gray-100 overflow-y-auto"
                                        style={{ height: '80px' }}
                                        onClick={() => setShowDescEditor(true)}
                                        dangerouslySetInnerHTML={{ __html: extendedDescription || '<p class="text-gray-400">Click to edit description</p>' }}
                                    />
                                </div>
                            </div>

                            <div className="pb-2">
                                <div className="flex items-center gap-2 mb-1">
                                    <label className="text-sm font-medium">Anticipated Schedule:</label>
                                    <button
                                        onClick={() => setShowScheduleEditor(true)}
                                        className="px-2 py-0.5 bg-blue-600 text-white text-xs rounded hover:bg-blue-700"
                                    >
                                        Edit
                                    </button>
                                </div>
                                <OperatingScheduleDisplay 
                                    schedule={operatingSchedule} 
                                    stateColors={settings.stateColors}
                                />
                            </div>
                        </div>
                    </div>

                    {/* Resizer */}
                    <div ref={resizerRef} className="resizer-horizontal"></div>

                    {/* Pane B - Hazard Analysis */}
                    <div 
                        className="flex-1 overflow-hidden flex flex-col"
                        style={{ height: `${100 - paneAHeight}vh` }}
                    >
                        <div className="p-2 border-b bg-gray-50">
                            <div className="flex gap-2">
                                <button
                                    onClick={handleLoadHazardList}
                                    className="px-2 py-1 bg-blue-600 text-white rounded hover:bg-blue-700"
                                    style={{ fontSize: '0.75rem' }}
                                >
                                    Load Hazard List
                                </button>
                                <button
                                    onClick={() => setShowModifyHazardList(true)}
                                    className="px-2 py-1 bg-purple-600 text-white rounded hover:bg-purple-700 disabled:opacity-50 disabled:cursor-not-allowed"
                                    style={{ fontSize: '0.75rem' }}
                                    disabled={!hasData}
                                >
                                    Modify Hazard List
                                </button>
                            </div>
                        </div>

                        <div className="flex-1 overflow-auto" style={{ lineHeight: '1.3' }}>{/* Removed text-sm to inherit font size */}
                            {visibleHazardList.length === 0 ? (
                                <div className="p-8 text-center text-gray-500">
                                    To begin, either (1) load a Hazard Assessment project file (click 'Load HA') or (2) load a hazard list (click 'Load Hazard List').
                                </div>
                            ) : (
                                <div>
                                    {/* Header Row */}
                                    <div className="flex border-b font-semibold sticky top-0">
                                        <div className="flex-shrink-0 py-1 px-2 bg-blue-100" style={{ width: `${hazardColumnWidth}px` }}>
                                            Potential Hazards
                                        </div>
                                        <div className="w-32 py-1 px-2 border-l text-center flex-shrink-0 bg-yellow-100">
                                            Frequency
                                            <div className="text-xs font-normal">(/yr)</div>
                                        </div>
                                        {DEFAULT_OPERATING_STATES.map(state => {
                                            const stateColor = settings.stateColors?.[state.id] || state.color;
                                            const customData = operatingStateData[state.id];
                                            const displayName = customData?.name || state.name;
                                            const displayDescription = customData?.description || state.description;
                                            return (
                                                <div 
                                                    key={state.id} 
                                                    className="w-32 py-1 px-2 border-l text-center flex-shrink-0 cursor-pointer hover:opacity-80"
                                                    style={{ backgroundColor: stateColor }}
                                                    title={`${displayDescription}\n\nClick to edit`}
                                                    onClick={() => setEditingOperatingState(state.id)}
                                                >
                                                    {state.id}
                                                    <div className="text-xs font-normal">{displayName}</div>
                                                </div>
                                            );
                                        })}
                                        <div className="flex-1 min-w-48 py-1 px-2 border-l text-center flex-shrink-0 bg-gray-100">
                                            Notes
                                        </div>
                                    </div>

                                    {/* Hazard Rows */}
                                    {visibleHazardList.map(node => renderHazardRow(node, 0))}
                                </div>
                            )}
                        </div>
                    </div>

                    {/* Modals */}
                    {showDescEditor && (
                        <RichTextEditor
                            value={extendedDescription}
                            onChange={setExtendedDescription}
                            onClose={() => setShowDescEditor(false)}
                            title={`Edit Extended Description for ${facilityName || 'Facility'}`}
                        />
                    )}

                    {showScheduleEditor && (
                        <OperatingScheduleEditor
                            schedule={operatingSchedule}
                            onSave={setOperatingSchedule}
                            onClose={() => setShowScheduleEditor(false)}
                        />
                    )}

                    {showSettings && (
                        <SettingsModal 
                            settings={settings}
                            onSave={handleSaveSettings}
                            onClose={() => setShowSettings(false)} 
                        />
                    )}

                    {showModifyHazardList && (
                        <ModifyHazardListModal
                            hazardList={hazardList}
                            onSave={handleSaveModifiedHazardList}
                            onClose={() => setShowModifyHazardList(false)}
                        />
                    )}

                    {editingHazard && (
                        <HazardEditor
                            hazard={editingHazard}
                            onSave={handleSaveHazardAnalysis}
                            onClose={() => setEditingHazard(null)}
                            allAnalysisData={hazardAnalysisData}
                            allStates={hazardStates}
                            settings={settings}
                        />
                    )}

                    {editingOperatingState && (
                        <OperatingStateEditor
                            stateId={editingOperatingState}
                            stateData={operatingStateData[editingOperatingState]}
                            defaultState={DEFAULT_OPERATING_STATES.find(s => s.id === editingOperatingState)}
                            onSave={(stateId, data) => {
                                setOperatingStateData(prev => ({
                                    ...prev,
                                    [stateId]: data
                                }));
                            }}
                            onClose={() => setEditingOperatingState(null)}
                        />
                    )}

                    {showHazardPlot && (
                        <HazardPlotModal 
                            createHazardPlot={createHazardPlot}
                            getAvailableHazards={getAvailableHazards}
                            onClose={() => setShowHazardPlot(false)}
                        />
                    )}

                    {showExportModal && (
                        <div className="modal-overlay">
                            <div className="modal-content" style={{ maxWidth: '500px', backgroundColor: '#ffffff', color: '#111827' }}>
                                <div className="p-4">
                                    <h2 className="text-xl font-bold mb-4">Export Hazard Data</h2>
                                    
                                    <div className="space-y-3 mb-6">
                                        <button
                                            onClick={exportToMarkdown}
                                            className="w-full px-4 py-3 bg-blue-600 text-white rounded hover:bg-blue-700 text-left"
                                        >
                                            <div className="font-semibold">Export to Markdown File</div>
                                            <div className="text-sm text-blue-100 mt-1">
                                                Creates a .md file with hazard summary and details
                                            </div>
                                        </button>
                                        
                                        <button
                                            onClick={exportToSAPHIRE}
                                            className="w-full px-4 py-3 bg-green-600 text-white rounded hover:bg-green-700 text-left"
                                        >
                                            <div className="font-semibold">Export to SAPHIRE Files</div>
                                            <div className="text-sm text-green-100 mt-1">
                                                Creates .BEI, .BED, and .FTL files for SAPHIRE analysis
                                            </div>
                                        </button>
                                        
                                        <button
                                            onClick={exportHazardSummaryToExcel}
                                            className="w-full px-4 py-3 bg-orange-600 text-white rounded hover:bg-orange-700 text-left"
                                        >
                                            <div className="font-semibold">Export Hazard Summary to Excel</div>
                                            <div className="text-sm text-orange-100 mt-1">
                                                Creates a .CSV file of the Hazard Summary Table (Excel-compatible)
                                            </div>
                                        </button>
                                    </div>
                                    
                                    <div className="flex gap-3 justify-end">
                                        <button
                                            onClick={() => setShowExportModal(false)}
                                            className="px-4 py-2 border rounded hover:bg-gray-100"
                                        >
                                            Cancel
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Status Bar */}
                    <div style={{
                        position: 'fixed',
                        bottom: 0,
                        left: 0,
                        right: 0,
                        height: '24px',
                        backgroundColor: '#000000',
                        color: '#ffffff',
                        display: 'flex',
                        alignItems: 'center',
                        paddingLeft: '12px',
                        fontSize: '12px',
                        zIndex: 1000
                    }}>
                        {loadedFileName ? `Loaded File: ${loadedFileName}` : 'No file loaded'}
                    </div>
                </div>
            );
        }

        // Render the application
        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>
