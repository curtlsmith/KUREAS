<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KUREAS-FTL - Fault Tree Logic Visualizer</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
	 <link rel="icon" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAEzUlEQVR4AcRXSUxUWRQ9r4oZmZpBpGkGATdudKUrh5hoXLgEosbExKEdAJV2ionzEDXRxKgxNmgjLETAGIdoTEx04caliImhAYONAgKFNHSoiaq+99f313/1XxVVHZP+4f733rn3vnv+rffvv9jwP18agcrKSv+PliraUyXmOPzsGgGetLW1gaW1uRl/HDmCxj170FhXBx6bz59HW2urpmebiEJ2zRcuoKGmBg27d+P3Xbs04XXTmTPGHhyTxSDAC/j9cH/+jD+3bkXnsmXoXL4c71auxJdr1+BzuTSTiLeZGTieP8c73bdzxQrNv2vVKvQSIe/4uMVdJsBqIgGfD5IwxrpI4vXC8ewZerdtg2tgIGhpsyF18WJUUGbTliwJ4vrMSkBXxDTowXu2b4eLMmj4UvD0pUux4M4dzFm0yIDNEysBIcz6wDxSBjj406fg4O7BwYA93yl4Jv0UC5qakLJwISNKsRJQmqlBPwUfe/IE3XRm3ENDQSMKnrV6Ncpv30ZSRUUQV8wkAn4yEELOgD/M0/s8How9fKg9uXdkhDz1Pwr+07p1KG9oQFJpqQ6GHyQC4c1kjRb8wQP07tgBT0jw3MpKlN+4gcTCQtkpzEoiIIQAZ8Fsy/kwZ4HT7rh/H730fntGRw1TQU+et2kT5l+9ioR58wx8tolEYDZjP6V9lApWz86d8I6NBc0peD69fvMvXUJ8bm4Qj2JmISCEnAV+ei0LHPzePe3Jvd++GVsLux0FtbUopuoXl51t4NFOLARUjn63G19bWtBDafdOTARNiGze5s0oPnUKcRkZQTyGmZUAbSoEP7O+C70Fw1RI+vbuxczkpA7qA+n+fv0azo8fdSD2wUpAsYdvehp8+BQqOLu78enkSfltUBmGwaIiEMZXg/mMOB4/xtDNm+CfSgNjuMVEwJaUhNLLl1HR2Ah7aqoRhrPzhfBx+hLyF9VQRDGJmgAHL6G+oIC+8TlVVZi7ZYu0vYc+tf1Hj2L6wwcJn21hJWA+gLq3FvzcOeRT5RMJCbCnpaGADmXo5/Wft2/x6fRpeB0ORHtZCSg88zZuxFz64NgSEw1tUkkJiujwxefkGBhPRjs6MNzUFPV5UBMIyYJITgao4HAAQ8gmgzqegn37IOLiDJir5cDFi5h49Qp+bmwMjXqiJqC2taCckXzKTNbatZLOMzyM/mPH4Orrk3DVwqYCLRgVHGEBA0B8Xh6K6PAll5UFAP0++eYN/qJMzJgrp64zD9ERMHso5tzz/Xz4MOwpKZJ2pKUFX+/ehY9KuaQwLX4IAT4DufRq5qxfD9DZgH75nE4MnD2LKcoGKIs6LA1qArSJEHLSueJJniELe3o6Cg8exBzqgM0kuEPuP34czv5+qPZQE8B/u5LLy/ELnYe4zExpg4mXLzF45Qp8U1MSzgslASHUPQE7RBRqTLLWrAkULHo1uUsCYSxDt25hjNo4SoO0hYWAPTNT26D4xAkUsVCxyaYmkyug5BlmYaOaUVhfj7Lr17U+gYsVS+GhQ2AioW4GgSo6RCwbqLWqpf9w9nd14cD79zhA46/UXldTNWR9NLKBGpe6Fy9QT6V5f2cnWH6jec2jR6iqrgbv8Z2IRqC9vV1I0tEh2gj7LpKO8FjWkWyZxL8AAAD//4MEZNkAAAAGSURBVAMAE0k4X2fO1c4AAAAASUVORK5CYII=" type="image/png">
    <style>
        body {
            margin: 0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue', sans-serif;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        canvas {
            cursor: grab;
        }
        canvas:active {
            cursor: grabbing;
        }
        canvas.pointer {
            cursor: pointer !important;
        }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // Icon Components
        const UploadIcon = () => (
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                <polyline points="17 8 12 3 7 8"></polyline>
                <line x1="12" y1="3" x2="12" y2="15"></line>
            </svg>
        );

        const DatabaseIcon = () => (
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <ellipse cx="12" cy="5" rx="9" ry="3"></ellipse>
                <path d="M21 12c0 1.66-4 3-9 3s-9-1.34-9-3"></path>
                <path d="M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5"></path>
            </svg>
        );

        const SettingsIcon = () => (
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M12.22 2h-.44a2 2 0 0 0-2 2v.18a2 2 0 0 1-1 1.73l-.43.25a2 2 0 0 1-2 0l-.15-.08a2 2 0 0 0-2.73.73l-.22.38a2 2 0 0 0 .73 2.73l.15.1a2 2 0 0 1 1 1.72v.51a2 2 0 0 1-1 1.74l-.15.09a2 2 0 0 0-.73 2.73l.22.38a2 2 0 0 0 2.73.73l.15-.08a2 2 0 0 1 2 0l.43.25a2 2 0 0 1 1 1.73V20a2 2 0 0 0 2 2h.44a2 2 0 0 0 2-2v-.18a2 2 0 0 1 1-1.73l.43-.25a2 2 0 0 1 2 0l.15.08a2 2 0 0 0 2.73-.73l.22-.39a2 2 0 0 0-.73-2.73l-.15-.08a2 2 0 0 1-1-1.74v-.5a2 2 0 0 1 1-1.74l.15-.09a2 2 0 0 0 .73-2.73l-.22-.38a2 2 0 0 0-2.73-.73l-.15.08a2 2 0 0 1-2 0l-.43-.25a2 2 0 0 1-1-1.73V4a2 2 0 0 0-2-2z"></path>
                <circle cx="12" cy="12" r="3"></circle>
            </svg>
        );

        const TrashIcon = () => (
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <polyline points="3 6 5 6 21 6"></polyline>
                <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
            </svg>
        );

        const ZoomInIcon = () => (
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <circle cx="11" cy="11" r="8"></circle>
                <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                <line x1="11" y1="8" x2="11" y2="14"></line>
                <line x1="8" y1="11" x2="14" y2="11"></line>
            </svg>
        );

        const ZoomOutIcon = () => (
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <circle cx="11" cy="11" r="8"></circle>
                <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                <line x1="8" y1="11" x2="14" y2="11"></line>
            </svg>
        );

        const RefreshIcon = () => (
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <polyline points="23 4 23 10 17 10"></polyline>
                <polyline points="1 20 1 14 7 14"></polyline>
                <path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path>
            </svg>
        );

        const CopyIcon = () => (
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect>
                <path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path>
            </svg>
        );

        const DownloadIcon = () => (
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                <polyline points="7 10 12 15 17 10"></polyline>
                <line x1="12" y1="15" x2="12" y2="3"></line>
            </svg>
        );

        const ReportIcon = () => (
            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
                <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
                <polyline points="14 2 14 8 20 8"></polyline>
                <line x1="16" y1="13" x2="8" y2="13"></line>
                <line x1="16" y1="17" x2="8" y2="17"></line>
                <polyline points="10 9 9 9 8 9"></polyline>
            </svg>
        );

        // Settings Management
        const DEFAULT_SETTINGS = {
            fontSize: 'small',         // small, medium, large
            nodeSize: 'medium',        // small, medium, large
            colorMode: 'color',        // color, grayscale, single-color
            singleColor: '#3b82f6',    // Color for single-color mode (default blue)
            fontFamily: 'sans-serif',  // serif, sans-serif
            arrows: 'arrows',          // arrows, no-arrows, dotted
            background: 'light',       // dark, light, grid, engineering
            lineStyle: 'curved',       // straight, curved
            showProbability: '0',      // hide, 0, 1, 2 (digits after decimal) - changed from 'hide' to '0'
            defaultViewStyle: 'fit',   // fit, 100
            boxType: 'circle',         // box-only, circle, gate-symbol
            treeSpacing: 'medium'      // small, medium, large
        };

        class SettingsManager {
            static STORAGE_KEY = 'KUREAS_FTL_settings';
            
            static load() {
                try {
                    const saved = localStorage.getItem(this.STORAGE_KEY);
                    return saved ? { ...DEFAULT_SETTINGS, ...JSON.parse(saved) } : { ...DEFAULT_SETTINGS };
                } catch (err) {
                    console.error('Failed to load settings:', err);
                    return { ...DEFAULT_SETTINGS };
                }
            }
            
            static save(settings) {
                try {
                    localStorage.setItem(this.STORAGE_KEY, JSON.stringify(settings));
                    return true;
                } catch (err) {
                    console.error('Failed to save settings:', err);
                    return false;
                }
            }
            
            static reset() {
                localStorage.removeItem(this.STORAGE_KEY);
                return { ...DEFAULT_SETTINGS };
            }
        }

        // Get font size multiplier based on setting
        function getFontSizeMultiplier(setting) {
            switch(setting) {
                case 'small': return 0.8;
                case 'large': return 1.2;
                default: return 1.0;
            }
        }

        // Get node size multiplier based on setting
        function getNodeSizeMultiplier(setting) {
            switch(setting) {
                case 'small': return 0.8;
                case 'large': return 1.2;
                default: return 1.0;
            }
        }

        // Get font family based on setting
        function getFontFamily(setting) {
            if (setting === 'serif') {
                return 'Georgia, serif';
            } else if (setting === 'monospace') {
                return 'Courier New, monospace';
            } else {
                return 'Arial, sans-serif';
            }
        }

        // Get tree spacing multiplier based on setting
        function getTreeSpacingMultiplier(setting) {
            switch(setting) {
                case 'small': return 0.85;
                case 'large': return 1.5;
                default: return 1.0; // medium
            }
        }

        // Get background style based on setting
        function getBackgroundStyle(setting) {
            switch(setting) {
                case 'dark':
                    return { backgroundColor: '#000000', color: '#ffffff' };
                case 'light':
                    return { backgroundColor: '#ffffff', color: '#000000' };
                case 'grid':
                    return { 
                        backgroundColor: '#ffffff', 
                        backgroundImage: 'linear-gradient(#add8e6 1px, transparent 1px), linear-gradient(90deg, #add8e6 1px, transparent 1px)',
                        backgroundSize: '20px 20px',
                        color: '#000000'
                    };
                case 'engineering':
                    return { 
                        backgroundColor: '#e3fce3', 
                        backgroundImage: 'linear-gradient(#7CA37C 1px, transparent 1px), linear-gradient(90deg, #7CA37C 1px, transparent 1px)',
                        backgroundSize: '20px 20px',
                        color: '#000000'
                    };
                default:
                    return { backgroundColor: '#ffffff', color: '#000000' };
            }
        }

        // Format probability in scientific notation
        function formatProbability(prob, digits) {
            if (!prob || prob === 0) return '0.0E+0';
            
            const exponent = Math.floor(Math.log10(Math.abs(prob)));
            const mantissa = prob / Math.pow(10, exponent);
            
            if (digits === '0') {
                return `${Math.round(mantissa)}.E${exponent >= 0 ? '+' : ''}${exponent}`;
            } else if (digits === '1') {
                return `${mantissa.toFixed(1)}E${exponent >= 0 ? '+' : ''}${exponent}`;
            } else if (digits === '2') {
                return `${mantissa.toFixed(2)}E${exponent >= 0 ? '+' : ''}${exponent}`;
            }
            return '';
        }

        // IndexedDB Database Class
        class TreeDB {
            constructor() {
                this.dbName = 'SaphireFaultTreeDB';
                this.version = 1;
                this.db = null;
            }

            init() {
                return new Promise((resolve, reject) => {
                    const request = indexedDB.open(this.dbName, this.version);

                    request.onerror = () => reject(request.error);
                    request.onsuccess = () => {
                        this.db = request.result;
                        resolve(this.db);
                    };

                    request.onupgradeneeded = (event) => {
                        const db = event.target.result;
                        if (!db.objectStoreNames.contains('faulttrees')) {
                            db.createObjectStore('faulttrees', { keyPath: 'id', autoIncrement: true });
                        }
                    };
                });
            }

            saveTree(treeData) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['faulttrees'], 'readwrite');
                    const store = transaction.objectStore('faulttrees');
                    const data = {
                        ...treeData,
                        timestamp: new Date().toISOString()
                    };
                    const request = store.add(data);

                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            }

            getAllTrees() {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['faulttrees'], 'readonly');
                    const store = transaction.objectStore('faulttrees');
                    const request = store.getAll();

                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });
            }

            deleteTree(id) {
                return new Promise((resolve, reject) => {
                    const transaction = this.db.transaction(['faulttrees'], 'readwrite');
                    const store = transaction.objectStore('faulttrees');
                    const request = store.delete(id);

                    request.onsuccess = () => resolve();
                    request.onerror = () => reject(request.error);
                });
            }
        }

        // Parser Functions
        function parseFTLStructure(text) {
            const sections = text.split('^EOS').filter(s => s.trim());
            const faultTrees = [];
            let projectName = '';

            sections.forEach((section, index) => {
                const tree = parseSingleFaultTree(section.trim());
                if (tree) {
                    if (index === 0) {
                        projectName = tree.projectName;
                    }
                    faultTrees.push(tree);
                }
            });

            return {
                projectName,
                faultTrees
            };
        }

        function parseSingleFaultTree(text) {
            const lines = text.split('\n').filter(line => line.trim());
            if (lines.length === 0) return null;

            // Parse header
            const header = lines[0].replace(/=$/, '').split(',');
            const projectName = header[0].trim();
            // Remove '=' and spaces from tree name
            const treeName = header[1] ? header[1].trim().replace(/=/g, '').replace(/\s+/g, '') : 'UnnamedTree';

            // Build gate map from all lines (can be in any order)
            const gateMap = {};
            const allNodes = new Set();

            for (let i = 1; i < lines.length; i++) {
                const parts = lines[i].trim().split(/\s+/);
                if (parts.length >= 1) {
                    const nodeName = parts[0];
                    allNodes.add(nodeName);
                    
                    if (parts.length >= 2) {
                        const gateType = parts[1];
                        const inputs = parts.slice(2);

                        gateMap[nodeName] = {
                            type: gateType,
                            inputs: inputs
                        };
                        
                        // Add all inputs to the set of known nodes
                        inputs.forEach(input => allNodes.add(input));
                    }
                }
            }

            // Find root gate - it's a gate that is not an input to any other gate
            let rootGateName = null;
            const inputNodes = new Set();
            
            // Collect all nodes that are inputs to other gates
            Object.values(gateMap).forEach(gate => {
                gate.inputs.forEach(input => inputNodes.add(input));
            });
            
            // Root is a gate that is not in the input set
            for (const nodeName of Object.keys(gateMap)) {
                if (!inputNodes.has(nodeName)) {
                    rootGateName = nodeName;
                    break;
                }
            }
            
            // If no root found, use first gate defined
            if (!rootGateName && Object.keys(gateMap).length > 0) {
                rootGateName = Object.keys(gateMap)[0];
            }

            if (!rootGateName) return null;

            // Build tree structure recursively
            function buildTree(nodeName, path = []) {
                // Cycle detection
                if (path.includes(nodeName)) {
                    return {
                        name: nodeName,
                        type: 'EVENT',
                        description: '(cycle)',
                        children: []
                    };
                }

                if (gateMap[nodeName]) {
                    const gate = gateMap[nodeName];
                    const newPath = [...path, nodeName];
                    
                    // For TRAN gates (transfer gates), store the transfer reference
                    if (gate.type === 'TRAN') {
                        let transferTarget = '';
                        
                        // If inputs are provided, use the first input as transfer target
                        if (gate.inputs.length > 0) {
                            transferTarget = gate.inputs[0];
                        } else {
                            // If no inputs, the gate name IS the transfer target
                            transferTarget = nodeName;
                        }
                        
                        return {
                            name: nodeName,
                            type: 'TRAN',
                            transferTo: transferTarget,
                            children: []
                        };
                    }
                    
                    return {
                        name: nodeName,
                        type: gate.type,
                        children: gate.inputs.map(input => buildTree(input, newPath))
                    };
                } else {
                    return {
                        name: nodeName,
                        type: 'EVENT',
                        description: '',
                        children: []
                    };
                }
            }

            const rootNode = buildTree(rootGateName);

            return {
                projectName,
                treeName,
                rootNode
            };
        }

        function parseEventDescriptions(text) {
            const descriptions = {};
            const lines = text.split('\n').filter(line => line.trim());

            lines.forEach(line => {
                // Split by comma - format is: Name, Description, Project
                const parts = line.split(',');
                
                if (parts.length >= 2) {
                    const eventName = parts[0].trim();
                    const description = parts[1].trim();
                    // parts[2] would be project name, which we ignore
                    
                    descriptions[eventName] = description;
                }
            });

            return descriptions;
        }

        // Parse SAPHIRE Gate Description (GTD) file
        // Format: GATE_NAME,GATE_DESCRIPTION,ALTERNATIVE_FLAG,PROJECT_NAME
        // We only use GATE_NAME and GATE_DESCRIPTION (ignore ALTERNATIVE_FLAG and PROJECT_NAME)
        function parseGateDescriptions(text) {
            const descriptions = {};
            const lines = text.split('\n').filter(line => line.trim());

            lines.forEach(line => {
                // Split by comma - format is: Gate Name, Gate Description, Alternative Flag, Project Name
                const parts = line.split(',');
                
                if (parts.length >= 2) {
                    const gateName = parts[0].trim();
                    const description = parts[1].trim();
                    // parts[2] would be alternative flag (A=ALTERNATIVE), which we ignore
                    // parts[3] would be project name, which we ignore
                    
                    descriptions[gateName] = description;
                }
            });

            return descriptions;
        }

        // Parse SAPHIRE Basic Event Information (BEI) file
        // Format: Name,FdT,UdC,UdT,UdValue,Prob,Lambda,Tau,Mission,Init,PF,UdValue2,Calc_Prob,Freq,Model_Type,Phase_Type,Project
        function parseBEI(text) {
            const eventInfo = {};
            const lines = text.split('\n').filter(line => line.trim());

            lines.forEach(line => {
                // Split by comma
                const parts = line.split(',');
                
                if (parts.length >= 3) { // At minimum need Name, FdT, and Calc_Prob
                    const name = parts[0] ? parts[0].trim() : '';
                    
                    if (name) {
                        eventInfo[name] = {
                            Name: name,
                            FdT: parts[1] ? parts[1].trim() : '',
                            UdC: parts[2] ? parts[2].trim() : '',
                            UdT: parts[3] ? parts[3].trim() : '',
                            UdValue: parts[4] ? parseFloat(parts[4].trim()) || 0 : 0,
                            Prob: parts[5] ? parseFloat(parts[5].trim()) || 0 : 0,
                            Lambda: parts[6] ? parseFloat(parts[6].trim()) || 0 : 0,
                            Tau: parts[7] ? parseFloat(parts[7].trim()) || 0 : 0,
                            Mission: parts[8] ? parseFloat(parts[8].trim()) || 0 : 0,
                            Init: parts[9] ? parts[9].trim().toUpperCase() === 'T' || parts[9].trim() === '1' : false,
                            PF: parts[10] ? parts[10].trim() : ' ',
                            UdValue2: parts[11] ? parseFloat(parts[11].trim()) || 0 : 0,
                            Calc_Prob: parts[12] ? parseFloat(parts[12].trim()) || 0 : 0,
                            Freq: parts[13] ? parts[13].trim() : ' ',
                            Model_Type: parts[14] ? parts[14].trim() : '',
                            Phase_Type: parts[15] ? parts[15].trim() : '',
                            Project: parts[16] ? parts[16].trim() : ''
                        };
                    }
                }
            });

            return eventInfo;
        }

        // Parse SAPHIRE Fault Tree Cut Set (FTC) file
        // Format: Project, Fault_Tree, ModelType/Phase
        //         =
        //         Eventname * Eventname +
        //         Eventname * Eventname * Eventname +
        //         Eventname +
        //         Eventname * Eventname.
        //         ^EOS
        // Lines starting with '*' are comments and should be ignored
        // Note: The last tree in the file may not have ^EOS at the end
        function parseFTC(text) {
            const cutSetsByTree = {};
            
            // Split by ^EOS, but keep content after last ^EOS (or entire file if no ^EOS)
            const sections = [];
            const parts = text.split('^EOS');
            
            // Add all parts that have content
            for (let i = 0; i < parts.length; i++) {
                const trimmed = parts[i].trim();
                if (trimmed.length > 0) {
                    sections.push(trimmed);
                }
            }

            sections.forEach((section, sectionIndex) => {
                // Split into lines and trim, but keep all lines initially
                const allLines = section.split('\n').map(l => l.trim());
                
                // Filter out comment lines (starting with *) and empty lines
                const lines = allLines.filter(l => l && !l.startsWith('*'));
                
                if (lines.length < 2) {
                    return;
                }

                // Parse header: Project, Fault_Tree, ModelType/Phase
                const headerLine = lines[0];
                const headerParts = headerLine.split(',').map(p => p.trim());
                
                if (headerParts.length < 2) {
                    return;
                }

                const project = headerParts[0];
                const faultTree = headerParts[1];
                const modelPhase = headerParts[2] || '';

                // Look for '=' line
                let startIndex = -1;
                for (let i = 0; i < lines.length; i++) {
                    if (lines[i] === '=') {
                        startIndex = i + 1;
                        break;
                    }
                }

                if (startIndex === -1 || startIndex >= lines.length) {
                    // Still create entry but with 0 cut sets
                    cutSetsByTree[faultTree] = {
                        project: project,
                        faultTree: faultTree,
                        modelPhase: modelPhase,
                        cutSets: []
                    };
                    return;
                }

                // Parse cut sets
                const cutSets = [];
                
                for (let i = startIndex; i < lines.length; i++) {
                    const line = lines[i];
                    if (!line || line === '^EOS') {
                        continue;
                    }

                    // Remove trailing + or .
                    let cutSetLine = line.replace(/[+.]$/, '').trim();
                    
                    // Split by * to get events
                    const events = cutSetLine.split('*').map(e => e.trim()).filter(e => e);
                    
                    // Parse each event (check for complement /)
                    const parsedEvents = events.map(event => {
                        if (event.startsWith('/')) {
                            return {
                                name: event.substring(1).trim(),
                                complement: true
                            };
                        } else {
                            return {
                                name: event.trim(),
                                complement: false
                            };
                        }
                    });

                    if (parsedEvents.length > 0) {
                        cutSets.push(parsedEvents);
                    }
                }

                cutSetsByTree[faultTree] = {
                    project: project,
                    faultTree: faultTree,
                    modelPhase: modelPhase,
                    cutSets: cutSets
                };
            });

            return cutSetsByTree;
        }

        // Compact Layout Algorithm - minimal spacing between siblings
        function calculateLayout(node, nodeMultiplier = 1, spacingMultiplier = 1) {
            const nodeWidth = 160 * nodeMultiplier;
            const nodeHeight = 80 * nodeMultiplier;
            const levelHeight = 150 * nodeMultiplier * spacingMultiplier;
            
            // Minimal gap between siblings (just enough to see separation)
            const minGap = 5 * nodeMultiplier * spacingMultiplier;

            // Calculate subtree widths bottom-up
            function calculateWidths(node) {
                if (!node.children || node.children.length === 0) {
                    node.subtreeWidth = nodeWidth;
                    return;
                }

                // Recursively calculate children first
                node.children.forEach(child => calculateWidths(child));

                // Total width is sum of children's subtree widths plus minimal gaps
                let totalWidth = 0;
                node.children.forEach((child, i) => {
                    totalWidth += child.subtreeWidth;
                    if (i < node.children.length - 1) {
                        totalWidth += minGap;
                    }
                });

                node.subtreeWidth = Math.max(totalWidth, nodeWidth);
            }

            // Position nodes using calculated widths
            function assignPositions(node, x = 0, y = 0) {
                node.x = x;
                node.y = y;

                if (!node.children || node.children.length === 0) {
                    return;
                }

                // Calculate total width of all children
                let totalWidth = 0;
                node.children.forEach((child, i) => {
                    totalWidth += child.subtreeWidth;
                    if (i < node.children.length - 1) {
                        totalWidth += minGap;
                    }
                });

                // Start from left edge, centered under parent
                let currentX = x - totalWidth / 2;

                // Position each child
                node.children.forEach((child, i) => {
                    // Center child in its allocated subtree space
                    const childX = currentX + child.subtreeWidth / 2;
                    assignPositions(child, childX, y + levelHeight);
                    
                    // Move to next position
                    currentX += child.subtreeWidth;
                    if (i < node.children.length - 1) {
                        currentX += minGap;
                    }
                });
            }

            calculateWidths(node);
            assignPositions(node, 0, 0);
        }

        // Get bounding box of tree for auto-fit
        function getTreeBounds(node, nodeMultiplier = 1) {
            let minX = Infinity, maxX = -Infinity;
            let minY = Infinity, maxY = -Infinity;
            const nodeWidth = 160 * nodeMultiplier;
            const nodeHeight = 80 * nodeMultiplier;

            function traverse(node) {
                if (!node) return;
                
                minX = Math.min(minX, node.x - nodeWidth / 2);
                maxX = Math.max(maxX, node.x + nodeWidth / 2);
                minY = Math.min(minY, node.y - nodeHeight / 2);
                maxY = Math.max(maxY, node.y + nodeHeight / 2);

                if (node.children) {
                    node.children.forEach(child => traverse(child));
                }
            }

            traverse(node);

            return {
                minX,
                maxX,
                minY,
                maxY,
                width: maxX - minX,
                height: maxY - minY
            };
        }

        // Tree Canvas Component
        function TreeCanvas({ tree, eventDescriptions, gateDescriptions, eventInfo, project, settings }) {
            const canvasRef = useRef(null);
            const containerRef = useRef(null);
            const processedTreeRef = useRef(null);
            const [scale, setScale] = useState(1);
            const [offset, setOffset] = useState({ x: 0, y: 0 });
            const [isDragging, setIsDragging] = useState(false);
            const [dragStart, setDragStart] = useState({ x: 0, y: 0 });
            const [isInitialized, setIsInitialized] = useState(false);
            const [expandedTransNodes, setExpandedTransNodes] = useState(new Set());

            // Get multipliers and styles from settings
            const fontMultiplier = getFontSizeMultiplier(settings.fontSize);
            const nodeMultiplier = getNodeSizeMultiplier(settings.nodeSize);
            const spacingMultiplier = getTreeSpacingMultiplier(settings.treeSpacing);
            const fontFamily = getFontFamily(settings.fontFamily);
            const backgroundStyle = getBackgroundStyle(settings.background);
            
            // Combine event and gate descriptions into one object for passing to draw functions
            const descriptions = {
                events: eventDescriptions || {},
                gates: gateDescriptions || {},
                eventInfo: eventInfo || {}
            };

            useEffect(() => {
                if (!tree || !canvasRef.current) return;

                const canvas = canvasRef.current;
                const ctx = canvas.getContext('2d');
                const container = containerRef.current;

                // Set canvas size
                canvas.width = container.clientWidth;
                canvas.height = container.clientHeight;

                // Process tree to expand TRAN nodes
                const processedTree = processTreeForExpansion(tree.rootNode);
                processedTreeRef.current = processedTree;

                // Calculate layout with node size and spacing multipliers
                calculateLayout(processedTree, nodeMultiplier, spacingMultiplier);

                // Auto-fit tree on first load based on settings
                if (!isInitialized) {
                    const defaultView = settings.defaultViewStyle || 'fit';
                    
                    if (defaultView === 'fit') {
                        // Fit to Window
                        const bounds = getTreeBounds(processedTree, nodeMultiplier);
                        const padding = 100;
                        const scaleX = (canvas.width - padding * 2) / bounds.width;
                        const scaleY = (canvas.height - padding * 2) / bounds.height;
                        const autoScale = Math.min(scaleX, scaleY, 1); // Don't scale up beyond 1
                        setScale(autoScale);
                        setOffset({ x: 0, y: 0 });
                    } else if (defaultView === '150') {
                        // 150% - adjust vertical offset to position tree lower
                        setScale(1.5);
                        setOffset({ x: 0, y: 50 }); // Push tree down by 50px
                    } else {
                        // 100%
                        setScale(1.0);
                        setOffset({ x: 0, y: 0 });
                    }
                    
                    setIsInitialized(true);
                    return; // Will re-render with new scale
                }

                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Save context state
                ctx.save();

                // Apply transformations
                ctx.translate(canvas.width / 2 + offset.x, 50 + offset.y);
                ctx.scale(scale, scale);

                // Draw tree with all settings
                drawTree(ctx, processedTree, descriptions, project, expandedTransNodes, settings, fontMultiplier, nodeMultiplier, fontFamily);

                // Restore context state
                ctx.restore();
            }, [tree, scale, offset, descriptions, isInitialized, expandedTransNodes, settings, fontMultiplier, nodeMultiplier, fontFamily]);

            // Set up wheel event listener with passive: false to allow preventDefault
            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;

                const handleWheel = (e) => {
                    e.preventDefault();
                    const delta = e.deltaY > 0 ? -0.1 : 0.1;
                    setScale(prev => Math.max(0.1, Math.min(2, prev + delta)));
                };

                canvas.addEventListener('wheel', handleWheel, { passive: false });

                return () => {
                    canvas.removeEventListener('wheel', handleWheel);
                };
            }, []);

            // Reset initialization when tree changes
            useEffect(() => {
                setIsInitialized(false);
                setExpandedTransNodes(new Set()); // Reset expanded nodes when tree changes
            }, [tree]);

            // Recursively process tree to expand TRAN nodes
            function processTreeForExpansion(node, depth = 0) {
                if (!node) return null;

                const isTransGate = node.type === 'TRAN' || node.transferTo;
                
                if (isTransGate && node.transferTo) {
                    const nodeId = `${node.name}_${node.transferTo}`;
                    
                    // Check if this TRAN node should be expanded
                    if (expandedTransNodes.has(nodeId)) {
                        // Find the referenced tree
                        const referencedTree = project?.faultTrees?.find(tree => 
                            tree.treeName === node.transferTo || 
                            tree.rootNode.name === node.transferTo
                        );
                        
                        if (referencedTree && referencedTree.rootNode) {
                            // Create a deep copy of the referenced tree's root node
                            const expandedChild = JSON.parse(JSON.stringify(referencedTree.rootNode));
                            
                            // Keep the TRAN node, but add the referenced tree as its child
                            return {
                                ...node,
                                type: 'TRAN',
                                transferTo: node.transferTo,
                                children: [processTreeForExpansion(expandedChild, depth + 1)],
                                isExpanded: true // Mark as expanded for coloring
                            };
                        }
                    }
                    // Not expanded, return the TRAN node as-is with no children
                    return { 
                        ...node, 
                        children: [],
                        type: 'TRAN',
                        transferTo: node.transferTo 
                    };
                }

                // If it's a TRAN type but no transferTo, try to look it up from gate map
                if (node.type === 'TRAN' && !node.transferTo) {
                    // Look up from original tree
                    const original = findOriginalTranNode(tree.rootNode, node.name);
                    if (original && original.transferTo) {
                        return processTreeForExpansion({ ...node, transferTo: original.transferTo }, depth);
                    }
                }

                // For non-TRAN nodes, recursively process children
                const processedNode = { ...node };
                if (node.children && node.children.length > 0) {
                    processedNode.children = node.children.map(child => processTreeForExpansion(child, depth + 1));
                }

                return processedNode;
            }

            function drawTree(ctx, node, descriptions, project, expandedTransNodes, settings, fontMultiplier, nodeMultiplier, fontFamily) {
                if (!node) return;

                // Draw edges first (so they appear behind nodes)
                if (node.children && node.children.length > 0) {
                    node.children.forEach(child => {
                        drawEdge(ctx, node, child, expandedTransNodes, settings, nodeMultiplier);
                    });
                }

                // Draw node
                drawNode(ctx, node, descriptions, project, expandedTransNodes, settings, fontMultiplier, nodeMultiplier, fontFamily);

                // Draw children
                if (node.children && node.children.length > 0) {
                    node.children.forEach(child => {
                        drawTree(ctx, child, descriptions, project, expandedTransNodes, settings, fontMultiplier, nodeMultiplier, fontFamily);
                    });
                }
            }

            function drawNode(ctx, node, descriptions, project, expandedTransNodes, settings, fontMultiplier, nodeMultiplier, fontFamily) {
                const colors = getNodeColor(node.type, node, project, expandedTransNodes, settings);
                const nodeWidth = 160 * nodeMultiplier;
                const nodeHeight = 80 * nodeMultiplier;

                // Check if this is a TRAN gate (transfer gate) - always draw as triangle if type is TRAN
                const isTransGate = node.type === 'TRAN' || node.transferTo;

                if (isTransGate) {
                    // Draw triangle for TRAN gates
                    // Point down when collapsed (default), point up when expanded
                    const height = 75 * nodeMultiplier;  // Increased from 60 to 75
                    const width = 90 * nodeMultiplier;   // Increased from 70 to 90
                    const isExpanded = node.isExpanded || (expandedTransNodes && expandedTransNodes.has(`${node.name}_${node.transferTo}`));

                    ctx.fillStyle = colors.fill;
                    ctx.strokeStyle = colors.stroke;
                    ctx.lineWidth = 2;

                    ctx.beginPath();
                    if (isExpanded) {
                        // Triangle pointing up (expanded state)
                        ctx.moveTo(node.x, node.y - height / 2); // Point at top
                        ctx.lineTo(node.x - width / 2, node.y + height / 2); // Bottom left
                        ctx.lineTo(node.x + width / 2, node.y + height / 2); // Bottom right
                    } else {
                        // Triangle pointing down (collapsed state)
                        ctx.moveTo(node.x, node.y + height / 2); // Point at bottom
                        ctx.lineTo(node.x - width / 2, node.y - height / 2); // Top left
                        ctx.lineTo(node.x + width / 2, node.y - height / 2); // Top right
                    }
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();

                    // Draw text in black - positioned higher in the triangle
                    ctx.fillStyle = 'black';
                    const tranLabelSize = 9 * fontMultiplier;  // Reduced from 10 to 9
                    ctx.font = `bold ${tranLabelSize}px ${fontFamily}`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    
                    // Position TRAN label higher (closer to top)
                    const labelOffset = isExpanded ? -height / 3 : -height / 4;
                    ctx.fillText('TRAN', node.x, node.y + labelOffset);
                    
                    // Dynamically size transfer name to fit
                    const maxTransWidth = width - 10;
                    let fontSize = 9 * fontMultiplier;  // Reduced from 10 to 9
                    ctx.font = `${fontSize}px ${fontFamily}`;
                    
                    const transferName = node.transferTo || node.name;
                    while (ctx.measureText(transferName).width > maxTransWidth && fontSize > 6 * fontMultiplier) {
                        fontSize -= 0.5;
                        ctx.font = `${fontSize}px ${fontFamily}`;
                    }
                    
                    // Position transfer name higher (closer to TRAN label)
                    const nameOffset = isExpanded ? -height / 6 : -height / 12;
                    ctx.fillText(transferName, node.x, node.y + nameOffset);
                } else {
                    // Draw shape based on node type
                    ctx.fillStyle = colors.fill;
                    ctx.strokeStyle = colors.stroke;
                    ctx.lineWidth = 2;

                    const x = node.x - nodeWidth / 2;
                    const y = node.y - nodeHeight / 2;
                    const radius = 5;

                    if (node.type === 'EVENT') {
                        // Draw oval/ellipse for events
                        const radiusX = nodeWidth / 2;
                        const radiusY = nodeHeight / 2;
                        
                        ctx.beginPath();
                        ctx.ellipse(node.x, node.y, radiusX, radiusY, 0, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.stroke();
                    } else {
                        // Draw rounded rectangle for gates
                        ctx.beginPath();
                        ctx.moveTo(x + radius, y);
                        ctx.lineTo(x + nodeWidth - radius, y);
                        ctx.quadraticCurveTo(x + nodeWidth, y, x + nodeWidth, y + radius);
                        ctx.lineTo(x + nodeWidth, y + nodeHeight - radius);
                        ctx.quadraticCurveTo(x + nodeWidth, y + nodeHeight, x + nodeWidth - radius, y + nodeHeight);
                        ctx.lineTo(x + radius, y + nodeHeight);
                        ctx.quadraticCurveTo(x, y + nodeHeight, x, y + nodeHeight - radius);
                        ctx.lineTo(x, y + radius);
                        ctx.quadraticCurveTo(x, y, x + radius, y);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
								// *** Draw symbol below OR/AND gates based on boxType setting ***
                        if (node.type === 'OR' || node.type === 'AND') {
                            const boxType = settings?.boxType || 'circle';

                            if (boxType === 'circle') {
                                // Option 2: Circle with +/- (current default behavior)
                                const circleRadius = 11 * nodeMultiplier;
                                const circleY = y + nodeHeight + circleRadius;

                                // Draw circle
                                ctx.beginPath();
                                ctx.arc(node.x, circleY, circleRadius, 0, 2 * Math.PI);
                                ctx.fillStyle = 'white';
                                ctx.fill();
                                ctx.strokeStyle = colors.stroke;
                                ctx.lineWidth = 2;
                                ctx.stroke();

                                // Draw operator symbol
                                ctx.fillStyle = 'black';
                                ctx.textAlign = 'center';
                                ctx.textBaseline = 'middle';
                                const symbolSize = 17 * fontMultiplier;
                                ctx.font = `bold ${symbolSize}px ${fontFamily}`;

                                if (node.type === 'OR') {
                                    ctx.fillText('+', node.x, circleY);
                                } else if (node.type === 'AND') {
                                    ctx.fillText('&times;', node.x, circleY);
                                }
                            } else if (boxType === 'gate-symbol') {
                                // Option 3: Fault tree gate symbols
                                const gateWidth = 30 * nodeMultiplier;
                                const gateHeight = 20 * nodeMultiplier;
                                const gateY = y + nodeHeight + 2;

                                ctx.fillStyle = colors.fill;
                                ctx.strokeStyle = colors.stroke;
                                ctx.lineWidth = 2;

                                if (node.type === 'OR') {
                                    // Draw OR gate symbol (rounded-pointy top, concave bottom)
                                    ctx.beginPath();
                                    // Start at bottom left
                                    ctx.moveTo(node.x - gateWidth / 2, gateY + gateHeight);
                                    // Concave bottom (curves inward)
                                    ctx.quadraticCurveTo(node.x, gateY + gateHeight - 5, node.x + gateWidth / 2, gateY + gateHeight);
                                    // Right side going up
                                    ctx.lineTo(node.x + gateWidth / 2, gateY + gateHeight / 3);
                                    // Rounded-pointy top (curves to point)
                                    ctx.quadraticCurveTo(node.x + gateWidth / 4, gateY, node.x, gateY);
                                    ctx.quadraticCurveTo(node.x - gateWidth / 4, gateY, node.x - gateWidth / 2, gateY + gateHeight / 3);
                                    // Left side going down
                                    ctx.lineTo(node.x - gateWidth / 2, gateY + gateHeight);
                                    ctx.fill();
                                    ctx.stroke();
                                } else if (node.type === 'AND') {
                                    // Draw AND gate symbol (box with rounded half-circle on top)
                                    ctx.beginPath();
                                    // Start at bottom left of the box
                                    ctx.moveTo(node.x - gateWidth / 2, gateY + gateHeight);
                                    // Left side going up to where semicircle starts
                                    ctx.lineTo(node.x - gateWidth / 2, gateY + gateHeight / 2);
                                    // Top semicircle (arc from left to right, counterclockwise)
                                    ctx.arc(node.x, gateY + gateHeight / 2, gateWidth / 2, Math.PI, 0, false);
                                    // Right side going down
                                    ctx.lineTo(node.x + gateWidth / 2, gateY + gateHeight);
                                    // Bottom edge
                                    ctx.lineTo(node.x - gateWidth / 2, gateY + gateHeight);
                                    ctx.fill();
                                    ctx.stroke();
                                }
                            }
                            // Option 1: box-only - don't draw anything (no else clause needed)
                        }
                    }

                    // Draw gate type header if applicable
                    if (node.type !== 'EVENT') {
                        const headerHeight = 16 * nodeMultiplier;
                        ctx.fillStyle = 'rgba(0,0,0,0.1)';
                        ctx.fillRect(x, y, nodeWidth, headerHeight);
                        ctx.fillStyle = 'black';
                        const headerFontSize = 11 * fontMultiplier;  // Increased from 10 to 11
                        ctx.font = `bold ${headerFontSize}px ${fontFamily}`;
                        ctx.textBaseline = 'middle';
                        
                        // Align gate type text based on gate type
                        if (node.type === 'OR') {
                            ctx.textAlign = 'right';
                            ctx.fillText(node.type, x + nodeWidth - 5, y + headerHeight / 2);
                        } else if (node.type === 'AND') {
                            ctx.textAlign = 'left';
                            ctx.fillText(node.type, x + 5, y + headerHeight / 2);
                        } else {
                            // Center align for all other gate types
                            ctx.textAlign = 'center';
                            ctx.fillText(node.type, node.x, y + headerHeight / 2);
                        }
                    }

                    // Draw node name in black - shrink to fit
                    ctx.fillStyle = 'black';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    const nameY = node.type === 'EVENT' ? node.y - 18 : node.y + 5;
                    
                    // Dynamically size text to fit within node
                    const maxNameWidth = nodeWidth - 10;
                    let fontSize = 12 * fontMultiplier;
                    ctx.font = `bold ${fontSize}px ${fontFamily}`;
                    
                    while (ctx.measureText(node.name).width > maxNameWidth && fontSize > 7 * fontMultiplier) {
                        fontSize -= 0.5;
                        ctx.font = `bold ${fontSize}px ${fontFamily}`;
                    }
                    
                    ctx.fillText(node.name, node.x, nameY);

                    // Draw description for events (allow 3 lines)
                    if (node.type === 'EVENT' && descriptions.events && descriptions.events[node.name]) {
                        const description = descriptions.events[node.name];
                        const descFontSize = 10 * fontMultiplier;  // Increased from 9 to 10
                        ctx.font = `${descFontSize}px ${fontFamily}`;
                        const lines = wrapText(ctx, description, nodeWidth - 10);
                        const lineHeight = 11 * fontMultiplier;  // Increased from 10 to 11
                        let lastLineY = node.y + 2;
                        lines.slice(0, 3).forEach((line, i) => {
                            let displayLine = line;
                            if (i === 2 && lines.length > 3) {
                                displayLine = line.substring(0, Math.max(0, line.length - 3)) + '...';
                            }
                            lastLineY = node.y + 2 + i * lineHeight;
                            ctx.fillText(displayLine, node.x, lastLineY);
                        });
                        
                        // Draw probability if available and setting is not 'hide'
                        if (settings.showProbability !== 'hide' && descriptions.eventInfo && descriptions.eventInfo[node.name]) {
                            const eventData = descriptions.eventInfo[node.name];
                            if (eventData.Calc_Prob) {
                                const probText = formatProbability(eventData.Calc_Prob, settings.showProbability);
                                const probFontSize = 12 * fontMultiplier;  // Same size as node name
                                ctx.font = `bold ${probFontSize}px ${fontFamily}`;
                                ctx.fillText(probText, node.x, lastLineY + lineHeight + 2);
                            }
                        }
                    } else if (node.type !== 'EVENT' && descriptions.gates && descriptions.gates[node.name]) {
                        // Draw description for gates (allow 2 lines)
                        const description = descriptions.gates[node.name];
                        const descFontSize = 9 * fontMultiplier;  // Increased from 8 to 9
                        ctx.font = `${descFontSize}px ${fontFamily}`;
                        const lines = wrapText(ctx, description, nodeWidth - 10);
                        const lineHeight = 10 * fontMultiplier;  // Increased from 9 to 10
                        lines.slice(0, 2).forEach((line, i) => {
                            let displayLine = line;
                            if (i === 1 && lines.length > 2) {
                                displayLine = line.substring(0, Math.max(0, line.length - 3)) + '...';
                            }
                            ctx.fillText(displayLine, node.x, node.y + 20 + i * lineHeight);
                        });
                    } else if (node.description) {
                        const descFontSize = 10 * fontMultiplier;  // Increased from 9 to 10
                        ctx.font = `${descFontSize}px ${fontFamily}`;
                        ctx.fillText(node.description, node.x, node.y + 5);
                    }
                }
            }

            function drawEdge(ctx, parent, child, expandedTransNodes, settings, nodeMultiplier) {
                ctx.strokeStyle = '#6b7280'; // Darker gray
                ctx.lineWidth = 2;

                // Calculate start and end points based on node types
                const isParentTrans = parent.type === 'TRAN' || parent.transferTo;
                const isChildTrans = child.type === 'TRAN' || child.transferTo;

                // Check if parent is expanded (pointing up) or collapsed (pointing down)
                const isParentExpanded = parent.isExpanded || (expandedTransNodes && parent.transferTo && expandedTransNodes.has(`${parent.name}_${parent.transferTo}`));
                const isChildExpanded = child.isExpanded || (expandedTransNodes && child.transferTo && expandedTransNodes.has(`${child.name}_${child.transferTo}`));

                // Apply node size multiplier to offsets
                const rectOffset = 40 * nodeMultiplier;
                const tranOffset = 30 * nodeMultiplier;
                const nodeHeight = 80 * nodeMultiplier;

                let startY = parent.y + (isParentTrans ? tranOffset : rectOffset);
                let endY = child.y - (isChildTrans ? tranOffset : rectOffset);

                // Adjust startY if parent is OR/AND gate with gate-symbol boxType
                const boxType = settings?.boxType || 'circle';
                if (boxType === 'gate-symbol' && (parent.type === 'OR' || parent.type === 'AND')) {
                    const gateHeight = 20 * nodeMultiplier;
                    // Connect to bottom of gate symbol: nodeHeight/2 (to bottom of box) + 2 (gap) + gateHeight
                    startY = parent.y + nodeHeight / 2 + 2 + gateHeight;
                }

                // Set line style
                ctx.strokeStyle = '#6b7280'; // Darker gray
                ctx.lineWidth = 1.5;
                
                // Set dash pattern based on arrows setting
                // 'dotted' option means dotted lines with no arrows
                if (settings.arrows === 'dotted') {
                    ctx.setLineDash([5, 5]); // 5px dash, 5px gap
                } else {
                    ctx.setLineDash([]); // Solid line for both 'arrows' and 'no-arrows'
                }
                
                // Draw line based on line style setting (curved or straight)
                ctx.beginPath();
                ctx.moveTo(parent.x, startY);
                
                if (settings.lineStyle === 'straight') {
                    // Draw straight line
                    ctx.lineTo(child.x, endY);
                } else {
                    // Draw curved line using quadratic bezier curve
                    const midY = (startY + endY) / 2;
                    const controlPointY = midY;
                    ctx.quadraticCurveTo(parent.x, controlPointY, child.x, endY);
                }
                ctx.stroke();
                
                // Reset line dash after drawing
                ctx.setLineDash([]);

                // Draw arrowhead at end only if 'arrows' option is selected
                // Not shown for 'no-arrows' or 'dotted'
                if (settings.arrows === 'arrows') {
                    const arrowLength = 8;
                    let angle;
                    
                    if (settings.lineStyle === 'straight') {
                        // Calculate angle for straight line
                        angle = Math.atan2(endY - startY, child.x - parent.x);
                    } else {
                        // Calculate angle for curved line
                        const midY = (startY + endY) / 2;
                        angle = Math.atan2(endY - midY, child.x - parent.x);
                    }
                    
                    ctx.beginPath();
                    ctx.moveTo(child.x, endY);
                    ctx.lineTo(
                        child.x - arrowLength * Math.cos(angle - Math.PI / 6),
                        endY - arrowLength * Math.sin(angle - Math.PI / 6)
                    );
                    ctx.moveTo(child.x, endY);
                    ctx.lineTo(
                        child.x - arrowLength * Math.cos(angle + Math.PI / 6),
                        endY - arrowLength * Math.sin(angle + Math.PI / 6)
                    );
                    ctx.stroke();
                }
            }

            function getNodeColor(type, node, project, expandedTransNodes, settings) {
                // Helper function to generate color variations from a base color
                function generateColorVariations(baseColor) {
                    // Parse hex color
                    const hex = baseColor.replace('#', '');
                    const r = parseInt(hex.substr(0, 2), 16);
                    const g = parseInt(hex.substr(2, 2), 16);
                    const b = parseInt(hex.substr(4, 2), 16);
                    
                    // Generate variations by adjusting lightness
                    const variations = {
                        'OR': {
                            fill: `rgb(${Math.min(255, r + 30)}, ${Math.min(255, g + 30)}, ${Math.min(255, b + 30)})`,
                            stroke: baseColor
                        },
                        'AND': {
                            fill: baseColor,
                            stroke: `rgb(${Math.max(0, r - 40)}, ${Math.max(0, g - 40)}, ${Math.max(0, b - 40)})`
                        },
                        'DT': {
                            fill: `rgb(${Math.min(255, r + 50)}, ${Math.min(255, g + 50)}, ${Math.min(255, b + 50)})`,
                            stroke: `rgb(${Math.max(0, r - 20)}, ${Math.max(0, g - 20)}, ${Math.max(0, b - 20)})`
                        },
                        'VOTING': {
                            fill: `rgb(${Math.min(255, r + 40)}, ${Math.min(255, g + 40)}, ${Math.min(255, b + 40)})`,
                            stroke: `rgb(${Math.max(0, r - 30)}, ${Math.max(0, g - 30)}, ${Math.max(0, b - 30)})`
                        },
                        'TRAN': {
                            fill: `rgb(${Math.max(0, r - 30)}, ${Math.max(0, g - 30)}, ${Math.max(0, b - 30)})`,
                            stroke: `rgb(${Math.max(0, r - 60)}, ${Math.max(0, g - 60)}, ${Math.max(0, b - 60)})`
                        },
                        'TRAN_EXPANDED': {
                            fill: `rgb(${Math.min(255, r + 80)}, ${Math.min(255, g + 80)}, ${Math.min(255, b + 80)})`,
                            stroke: `rgb(${Math.min(255, r + 40)}, ${Math.min(255, g + 40)}, ${Math.min(255, b + 40)})`
                        },
                        'EVENT': {
                            fill: `rgb(${Math.min(255, r + 20)}, ${Math.min(255, g + 20)}, ${Math.min(255, b + 20)})`,
                            stroke: `rgb(${Math.max(0, r - 50)}, ${Math.max(0, g - 50)}, ${Math.max(0, b - 50)})`
                        }
                    };
                    
                    return variations;
                }
                
                // Single Color mode
                if (settings && settings.colorMode === 'single-color') {
                    const baseColor = settings.singleColor || '#3b82f6';
                    const variations = generateColorVariations(baseColor);
                    
                    // Check for expanded TRAN
                    if (node && node.type === 'TRAN' && node.isExpanded) {
                        return variations['TRAN_EXPANDED'];
                    }
                    if (node && node.transferTo) {
                        const nodeId = `${node.name}_${node.transferTo}`;
                        if (expandedTransNodes && expandedTransNodes.has(nodeId)) {
                            return variations['TRAN_EXPANDED'];
                        }
                    }
                    
                    // Check for voting gates
                    if (type && type.includes('/')) {
                        return variations['VOTING'];
                    }
                    
                    // Return variation based on type
                    return variations[type] || variations['EVENT'];
                }
                
                // Grayscale mode - return gray for all nodes
                if (settings && settings.colorMode === 'grayscale') {
                    // Different shades of gray for different node types
                    if (node && node.type === 'TRAN' && node.isExpanded) {
                        return { fill: '#d1d5db', stroke: '#9ca3af' }; // Light gray for expanded TRAN
                    }
                    if (node && node.transferTo) {
                        const nodeId = `${node.name}_${node.transferTo}`;
                        if (expandedTransNodes && expandedTransNodes.has(nodeId)) {
                            return { fill: '#d1d5db', stroke: '#9ca3af' }; // Light gray for expanded TRAN
                        }
                    }
                    return { fill: '#9ca3af', stroke: '#6b7280' }; // Medium gray for all others
                }

                // Color mode - original colors
                const colors = {
                    'OR': { fill: '#f59e0b', stroke: '#d97706' },
                    'AND': { fill: '#60a5fa', stroke: '#3b82f6' }, // Lightened blue
                    'DT': { fill: '#ec4899', stroke: '#db2777' },
                    'TRAN': { fill: '#9ca3af', stroke: '#6b7280' }, // Default gray
                    'TRAN_EXPANDED': { fill: '#fbff11', stroke: '#e6ea0f' }, // Changed to requested yellow
                    'EVENT': { fill: '#73f3c9', stroke: '#059669' }
                };

                // Check for voting gates (X/Y format)
                if (type && type.includes('/')) {
                    return { fill: '#f97316', stroke: '#ea580c' };
                }

                // Check if this is an expanded TRAN node (show yellow) using isExpanded flag
                if (node && node.type === 'TRAN' && node.isExpanded) {
                    return colors['TRAN_EXPANDED'];
                }

                // Also check expandedTransNodes set as backup
                if (node && node.transferTo) {
                    const nodeId = `${node.name}_${node.transferTo}`;
                    if (expandedTransNodes && expandedTransNodes.has(nodeId)) {
                        return colors['TRAN_EXPANDED'];
                    }
                }

                // For TRAN gates, try to determine color from referenced tree's top gate
                if (type === 'TRAN' && node && node.transferTo && project && project.faultTrees) {
                    // Find the referenced tree
                    const referencedTree = project.faultTrees.find(tree => 
                        tree.treeName === node.transferTo || 
                        tree.rootNode.name === node.transferTo
                    );
                    
                    if (referencedTree && referencedTree.rootNode) {
                        const topGateType = referencedTree.rootNode.type;
                        // Return the color for the top gate type
                        if (topGateType.includes('/')) {
                            return { fill: '#f97316', stroke: '#ea580c' };
                        }
                        return colors[topGateType] || colors['TRAN'];
                    }
                    // If referenced tree not found, keep gray
                    return colors['TRAN'];
                }

                return colors[type] || colors['EVENT'];
            }

            function wrapText(ctx, text, maxWidth) {
                const words = text.split(' ');
                const lines = [];
                let currentLine = words[0];

                for (let i = 1; i < words.length; i++) {
                    const word = words[i];
                    const width = ctx.measureText(currentLine + ' ' + word).width;
                    if (width < maxWidth) {
                        currentLine += ' ' + word;
                    } else {
                        lines.push(currentLine);
                        currentLine = word;
                    }
                }
                lines.push(currentLine);
                return lines;
            }

            // Event handlers
            function handleWheel(e) {
                e.preventDefault();
                const delta = e.deltaY > 0 ? -0.1 : 0.1;
                setScale(prev => Math.max(0.1, Math.min(2, prev + delta)));
            }

            function handleMouseDown(e) {
                const canvas = canvasRef.current;
                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;

                // Transform click coordinates to canvas space
                const canvasX = (x - canvas.width / 2 - offset.x) / scale;
                const canvasY = (y - 50 - offset.y) / scale;

                // Check if click is on a TRAN node in processed tree (for accurate positions)
                const clickedNode = processedTreeRef.current ? 
                    findTranNodeAtPoint(processedTreeRef.current, canvasX, canvasY) : null;
                
                if (clickedNode && (clickedNode.type === 'TRAN' || clickedNode.transferTo)) {
                    // For TRAN nodes, we need to find the transferTo reference
                    // First check if it has transferTo directly
                    let transferTarget = clickedNode.transferTo;
                    
                    // If not, we need to look it up from the original tree
                    if (!transferTarget && clickedNode.type === 'TRAN') {
                        const originalNode = findOriginalTranNode(tree.rootNode, clickedNode.name);
                        if (originalNode) {
                            transferTarget = originalNode.transferTo;
                        }
                    }
                    
                    if (transferTarget) {
                        // Toggle expansion of this TRAN node
                        const nodeId = `${clickedNode.name}_${transferTarget}`;
                        
                        setExpandedTransNodes(prev => {
                            const newSet = new Set(prev);
                            if (newSet.has(nodeId)) {
                                newSet.delete(nodeId);
                            } else {
                                newSet.add(nodeId);
                            }
                            return newSet;
                        });
                        return; // Don't start dragging if we clicked a TRAN node
                    }
                }

                // Otherwise, start dragging
                setIsDragging(true);
                setDragStart({ x: e.clientX - offset.x, y: e.clientY - offset.y });
            }

            // Find original TRAN node in the unprocessed tree
            function findOriginalTranNode(node, name) {
                if (!node) return null;
                
                // Check if this is a TRAN node with matching name
                if (node.name === name && (node.type === 'TRAN' || node.transferTo)) {
                    return node;
                }
                
                // Search children
                if (node.children) {
                    for (const child of node.children) {
                        const found = findOriginalTranNode(child, name);
                        if (found) return found;
                    }
                }
                return null;
            }

            // Find node by name in tree
            function findNodeByName(node, name) {
                if (!node) return null;
                if (node.name === name) return node;
                
                if (node.children) {
                    for (const child of node.children) {
                        const found = findNodeByName(child, name);
                        if (found) return found;
                    }
                }
                return null;
            }

            // Find TRAN node at given coordinates (searches in tree for accurate positions)
            function findTranNodeAtPoint(node, x, y, depth = 0) {
                if (!node) return null;

                // Check if this node has position info
                if (node.x !== undefined && node.y !== undefined) {
                    // Check if this is a TRAN node by looking at its type or transferTo property
                    const isTransGate = node.type === 'TRAN' || node.transferTo;
                    
                    if (isTransGate) {
                        // Check if click is within triangle bounds
                        const height = 60;
                        const width = 70;
                        const top = node.y - height / 2;
                        const bottom = node.y + height / 2;
                        const left = node.x - width / 2;
                        const right = node.x + width / 2;
                        
                        if (x >= left && x <= right && y >= top && y <= bottom) {
                            return node;
                        }
                    }
                }

                // Check children
                if (node.children) {
                    for (const child of node.children) {
                        const found = findTranNodeAtPoint(child, x, y, depth + 1);
                        if (found) return found;
                    }
                }

                return null;
            }

            function handleMouseMove(e) {
                if (isDragging) {
                    setOffset({
                        x: e.clientX - dragStart.x,
                        y: e.clientY - dragStart.y
                    });
                } else {
                    // Update cursor based on whether hovering over TRAN node
                    const canvas = canvasRef.current;
                    if (!canvas || !processedTreeRef.current) return;
                    
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    
                    const canvasX = (x - canvas.width / 2 - offset.x) / scale;
                    const canvasY = (y - 50 - offset.y) / scale;
                    
                    const tranNode = findTranNodeAtPoint(processedTreeRef.current, canvasX, canvasY);
                    canvas.style.cursor = tranNode ? 'pointer' : 'grab';
                }
            }

            function handleMouseUp() {
                setIsDragging(false);
            }

            const [copyStatus, setCopyStatus] = useState('');

            function handleZoomIn() {
                setScale(prev => Math.min(2, prev + 0.2));
            }

            function handleZoomOut() {
                setScale(prev => Math.max(0.1, prev - 0.2));
            }

            function handleReset() {
                setScale(1);
                setOffset({ x: 0, y: 0 });
            }

            async function handleCopyToClipboard() {
                const canvas = canvasRef.current;
                if (!canvas) {
                    alert('Canvas not ready');
                    return;
                }

                setCopyStatus('Copying...');

                try {
                    // First check if we have clipboard write permission
                    if (!navigator.clipboard || !navigator.clipboard.write) {
                        throw new Error('Clipboard API not available');
                    }

                    // Create a promise-based version
                    const blob = await new Promise((resolve, reject) => {
                        canvas.toBlob((b) => {
                            if (b) resolve(b);
                            else reject(new Error('Failed to create blob'));
                        }, 'image/png');
                    });

                    // Try to write to clipboard
                    const clipboardItem = new ClipboardItem({ 'image/png': blob });
                    await navigator.clipboard.write([clipboardItem]);
                    
                    setCopyStatus('Copied!');
                    setTimeout(() => setCopyStatus(''), 2000);
                    
                } catch (err) {
                    console.error('Copy failed:', err);
                    setCopyStatus('Failed');
                    setTimeout(() => setCopyStatus(''), 2000);
                    
                    // More helpful error message
                    if (err.name === 'NotAllowedError') {
                        alert('Clipboard access denied. Please make sure:\n1. You are using HTTPS or localhost\n2. You have granted clipboard permissions\n\nAlternatively, use the Download button () to save as PNG file.');
                    } else if (err.message.includes('Clipboard API')) {
                        alert('Your browser does not support clipboard images.\n\nTip: Use the Download button () to save as PNG file instead.');
                    } else {
                        alert('Failed to copy: ' + err.message + '\n\nTip: Use the Download button () as an alternative.');
                    }
                }
            }

            function handleDownloadImage() {
                const canvas = canvasRef.current;
                if (!canvas) {
                    alert('Canvas not ready');
                    return;
                }

                try {
                    // Get the tree name for the filename
                    const treeName = tree.treeName || 'fault_tree';
                    const fileName = `${treeName.replace(/[^a-z0-9]/gi, '_')}.png`;

                    // Convert canvas to data URL
                    const dataURL = canvas.toDataURL('image/png');
                    
                    // Create a temporary link element
                    const link = document.createElement('a');
                    link.download = fileName;
                    link.href = dataURL;
                    
                    // Trigger download
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    
                    // Show success feedback
                    setCopyStatus('Downloaded!');
                    setTimeout(() => setCopyStatus(''), 2000);
                } catch (err) {
                    console.error('Download failed:', err);
                    alert('Failed to download image: ' + err.message);
                }
            }

            return (
                <div ref={containerRef} className="relative w-full h-full" style={backgroundStyle}>
                    <canvas
                        ref={canvasRef}
                        onMouseDown={handleMouseDown}
                        onMouseMove={handleMouseMove}
                        onMouseUp={handleMouseUp}
                        onMouseLeave={handleMouseUp}
                        className="w-full h-full"
                    />
                    <div className="absolute bottom-4 right-4 bg-white rounded-lg shadow-lg p-2 flex gap-2">
                        <button
                            onClick={handleZoomIn}
                            className="p-2 hover:bg-gray-100 rounded"
                            title="Zoom In"
                        >
                            <ZoomInIcon />
                        </button>
                        <button
                            onClick={handleZoomOut}
                            className="p-2 hover:bg-gray-100 rounded"
                            title="Zoom Out"
                        >
                            <ZoomOutIcon />
                        </button>
                        <button
                            onClick={handleReset}
                            className="p-2 hover:bg-gray-100 rounded"
                            title="Reset View"
                        >
                            <RefreshIcon />
                        </button>
                        <div className="border-l border-gray-300 mx-1"></div>
                        <button
                            onClick={handleCopyToClipboard}
                            className="p-2 hover:bg-gray-100 rounded relative"
                            title={copyStatus || "Copy to Clipboard (requires HTTPS/localhost)"}
                        >
                            <CopyIcon />
                            {copyStatus && (
                                <span className="absolute -top-8 left-1/2 transform -translate-x-1/2 bg-gray-800 text-white text-xs px-2 py-1 rounded whitespace-nowrap">
                                    {copyStatus}
                                </span>
                            )}
                        </button>
                        <button
                            onClick={handleDownloadImage}
                            className="p-2 hover:bg-gray-100 rounded"
                            title="Download as PNG (works anywhere)"
                        >
                            <DownloadIcon />
                        </button>
                        <div className="px-3 py-2 text-sm font-medium text-gray-700">
                            {Math.round(scale * 100)}%
                        </div>
                    </div>
                    <div className="absolute top-2 right-2 bg-white rounded-lg shadow-lg p-2">
                        <div className="text-[10px] font-semibold text-gray-700 mb-1">Legend</div>
                        <div className="space-y-0.5 text-[9px]">
                            {(() => {
                                // Get legend colors based on current color mode
                                const getLegendColors = () => {
                                    // Single Color mode
                                    if (settings && settings.colorMode === 'single-color') {
                                        const baseColor = settings.singleColor || '#3b82f6';
                                        const hex = baseColor.replace('#', '');
                                        const r = parseInt(hex.substr(0, 2), 16);
                                        const g = parseInt(hex.substr(2, 2), 16);
                                        const b = parseInt(hex.substr(4, 2), 16);
                                        
                                        return {
                                            'OR': `rgb(${Math.min(255, r + 30)}, ${Math.min(255, g + 30)}, ${Math.min(255, b + 30)})`,
                                            'AND': baseColor,
                                            'VOTING': `rgb(${Math.min(255, r + 40)}, ${Math.min(255, g + 40)}, ${Math.min(255, b + 40)})`,
                                            'DT': `rgb(${Math.min(255, r + 50)}, ${Math.min(255, g + 50)}, ${Math.min(255, b + 50)})`,
                                            'TRAN': `rgb(${Math.max(0, r - 30)}, ${Math.max(0, g - 30)}, ${Math.max(0, b - 30)})`,
                                            'EVENT': `rgb(${Math.min(255, r + 20)}, ${Math.min(255, g + 20)}, ${Math.min(255, b + 20)})`
                                        };
                                    }
                                    
                                    // Grayscale mode
                                    if (settings && settings.colorMode === 'grayscale') {
                                        return {
                                            'OR': '#9ca3af',
                                            'AND': '#9ca3af',
                                            'VOTING': '#9ca3af',
                                            'DT': '#9ca3af',
                                            'TRAN': '#9ca3af',
                                            'EVENT': '#9ca3af'
                                        };
                                    }
                                    
                                    // Color mode (default)
                                    return {
                                        'OR': '#f59e0b',
                                        'AND': '#3b82f6',
                                        'VOTING': '#f97316',
                                        'DT': '#ec4899',
                                        'TRAN': '#9ca3af',
                                        'EVENT': '#73f3c9'
                                    };
                                };
                                
                                const colors = getLegendColors();
                                
                                return (
                                    <>
                                        <div className="flex items-center gap-1.5">
                                            <div className="w-3 h-3 rounded" style={{backgroundColor: colors.OR}}></div>
                                            <span>OR Gate</span>
                                        </div>
                                        <div className="flex items-center gap-1.5">
                                            <div className="w-3 h-3 rounded" style={{backgroundColor: colors.AND}}></div>
                                            <span>AND Gate</span>
                                        </div>
                                        <div className="flex items-center gap-1.5">
                                            <div className="w-3 h-3 rounded" style={{backgroundColor: colors.VOTING}}></div>
                                            <span>Voting Gate</span>
                                        </div>
                                        <div className="flex items-center gap-1.5">
                                            <div className="w-3 h-3 rounded" style={{backgroundColor: colors.DT}}></div>
                                            <span>DT Gate</span>
                                        </div>
                                        <div className="flex items-center gap-1.5">
                                            <div className="w-3 h-3 rounded" style={{backgroundColor: colors.TRAN}}></div>
                                            <span>TRAN Gate</span>
                                        </div>
                                        <div className="flex items-center gap-1.5">
                                            <div className="w-3 h-3 rounded" style={{backgroundColor: colors.EVENT}}></div>
                                            <span>Basic Event</span>
                                        </div>
                                    </>
                                );
                            })()}
                        </div>
                    </div>
                </div>
            );
        }

        // Settings Modal Component
        // Cut Sets Floating Window Component
        function CutSetsFloatingWindow({ 
            cutSetsData, 
            position, 
            size, 
            minimized,
            onPositionChange, 
            onSizeChange,
            onMinimize,
            onClose,
            onMouseDown,
            eventInfo,
            eventDescriptions,
            treeName,
            settings
        }) {
            const [isResizing, setIsResizing] = React.useState(false);
            const [resizeStart, setResizeStart] = React.useState({ x: 0, y: 0, width: 0, height: 0 });
            const [highlightedEvent, setHighlightedEvent] = React.useState(null);

            // Check and adjust position to keep window in viewport
            React.useEffect(() => {
                const adjustedY = Math.max(20, position.y); // Ensure at least 20px from top
                if (adjustedY !== position.y) {
                    onPositionChange({ ...position, y: adjustedY });
                }
            }, [position.y]);

            const handleResizeStart = (e) => {
                e.preventDefault();
                e.stopPropagation();
                setIsResizing(true);
                setResizeStart({
                    x: e.clientX,
                    y: e.clientY,
                    width: size.width,
                    height: size.height
                });
            };

            React.useEffect(() => {
                if (!isResizing) return;

                const handleMouseMove = (e) => {
                    const deltaX = e.clientX - resizeStart.x;
                    const deltaY = e.clientY - resizeStart.y;
                    const newWidth = Math.max(200, resizeStart.width + deltaX);
                    const newHeight = Math.max(150, resizeStart.height + deltaY);
                    onSizeChange({ width: newWidth, height: newHeight });
                };

                const handleMouseUp = () => {
                    setIsResizing(false);
                };

                document.addEventListener('mousemove', handleMouseMove);
                document.addEventListener('mouseup', handleMouseUp);

                return () => {
                    document.removeEventListener('mousemove', handleMouseMove);
                    document.removeEventListener('mouseup', handleMouseUp);
                };
            }, [isResizing, resizeStart, onSizeChange]);

            if (!cutSetsData || !cutSetsData.cutSets) {
                return null;
            }
            
            // Get font size classes based on settings
            const getFontSizeClasses = () => {
                switch(settings?.fontSize) {
                    case 'small': return { title: 'text-xs', content: 'text-[10px]' };
                    case 'large': return { title: 'text-base', content: 'text-sm' };
                    default: return { title: 'text-sm', content: 'text-xs' }; // medium
                }
            };
            
            const fontSizeClasses = getFontSizeClasses();
            
            // Helper function to calculate cut set probability
            const calculateCutSetProbability = (cutSet) => {
                let probability = 1.0;
                
                for (const event of cutSet) {
                    const info = eventInfo && eventInfo[event.name];
                    if (info && info.Calc_Prob !== undefined) {
                        if (event.complement) {
                            // Complemented event: use (1 - prob)
                            probability *= (1.0 - info.Calc_Prob);
                        } else {
                            // Normal event: use prob
                            probability *= info.Calc_Prob;
                        }
                    } else {
                        // If any event doesn't have probability, return null
                        return null;
                    }
                }
                
                return probability;
            };
            
            // Helper function to calculate fault tree probability
            const calculateFaultTreeProbability = () => {
                let ftProb = 1.0;
                
                for (const cutSet of cutSetsData.cutSets) {
                    const csProb = calculateCutSetProbability(cutSet);
                    if (csProb === null) {
                        // If any cut set can't be calculated, return null
                        return null;
                    }
                    ftProb *= (1.0 - csProb);
                }
                
                return 1.0 - ftProb;
            };
            
            // Helper function to format probability using settings (with one less digit)
            const formatProbability = (prob) => {
                if (prob === null || prob === undefined) return 'N/A';
                
                const digits = Math.max(1, (settings?.probabilityDigits || 3) - 1);
                return prob.toExponential(digits);
            };
            
            // Helper function to get event tooltip
            const getEventTooltip = (eventName) => {
                const info = eventInfo && eventInfo[eventName];
                const description = eventDescriptions && eventDescriptions[eventName];
                
                if (!info && !description) return eventName;
                
                const parts = [];
                
                // Add description first if available
                if (description) {
                    parts.push(description);
                }
                
                // BEI file has Calc_Prob field
                if (info && info.Calc_Prob !== undefined && info.Calc_Prob !== 0) {
                    parts.push(`Probability: ${formatProbability(info.Calc_Prob)}`);
                }
                // Could also show other useful info
                if (info && info.Lambda !== undefined && info.Lambda !== 0) {
                    parts.push(`Lambda: ${info.Lambda.toExponential(2)}`);
                }
                if (info && info.Mission !== undefined && info.Mission !== 0) {
                    parts.push(`Mission Time: ${info.Mission}`);
                }
                
                return parts.length > 0 ? parts.join('\n') : eventName;
            };
            
            // Helper function to toggle event highlighting
            const handleEventClick = (eventName) => {
                if (highlightedEvent === eventName) {
                    setHighlightedEvent(null); // Deselect if already selected
                } else {
                    setHighlightedEvent(eventName); // Select new event
                }
            };
            
            // Helper function to get event color classes
            const getEventColorClasses = (event) => {
                if (highlightedEvent === event.name) {
                    // Highlighted event - use bright yellow/gold
                    return 'bg-yellow-300 text-yellow-900 ring-2 ring-yellow-500';
                } else if (event.complement) {
                    // Complemented event - red
                    return 'bg-red-100 text-red-700';
                } else {
                    // Normal event - blue
                    return 'bg-blue-100 text-blue-700';
                }
            };
            
            // Sort cut sets by probability (highest first)
            const sortedCutSets = React.useMemo(() => {
                const cutSetsWithProb = cutSetsData.cutSets.map((cutSet, originalIndex) => ({
                    cutSet,
                    probability: calculateCutSetProbability(cutSet),
                    originalIndex
                }));
                
                // Sort by probability (highest first), null probabilities go to end
                cutSetsWithProb.sort((a, b) => {
                    if (a.probability === null && b.probability === null) return 0;
                    if (a.probability === null) return 1;
                    if (b.probability === null) return -1;
                    return b.probability - a.probability; // Descending order
                });
                
                return cutSetsWithProb;
            }, [cutSetsData.cutSets, eventInfo]);
            
            // Calculate fault tree probability for title
            const faultTreeProb = calculateFaultTreeProbability();
            const titleText = `Cut Sets from ${treeName} [${formatProbability(faultTreeProb)}]`;

            return (
                <div
                    style={{
                        position: 'fixed',
                        left: `${position.x}px`,
                        top: `${position.y}px`,
                        width: `${size.width}px`,
                        height: minimized ? 'auto' : `${size.height}px`,
                        zIndex: 1000
                    }}
                    className="bg-white rounded shadow-2xl border-2 border-gray-300 flex flex-col"
                >
                    {/* Title Bar */}
                    <div
                        onMouseDown={onMouseDown}
                        className={`bg-blue-600 text-white px-2 py-1 rounded-t cursor-move flex items-center justify-between ${fontSizeClasses.title} font-semibold select-none`}
                        title={titleText}
                    >
                        <span className="truncate">{titleText}</span>
                        <div className="flex gap-1 flex-shrink-0">
                            <button
                                onClick={(e) => {
                                    e.stopPropagation();
                                    onMinimize();
                                }}
                                className="hover:bg-blue-700 px-1 rounded"
                                title={minimized ? "Expand" : "Minimize"}
                            >
                                {minimized ? '&#x25A1;' : '_'}
                            </button>
                            <button
                                onClick={(e) => {
                                    e.stopPropagation();
                                    onClose();
                                }}
                                className="hover:bg-blue-700 px-1 rounded"
                                title="Close"
                            >
                                &times;
                            </button>
                        </div>
                    </div>

                    {/* Content */}
                    {!minimized && (
                        <>
                            <div className={`flex-1 overflow-y-auto p-2 ${fontSizeClasses.content}`}>
                                {sortedCutSets.length === 0 ? (
                                    <div className="text-gray-500 text-center py-4">
                                        0 cut sets
                                    </div>
                                ) : (
                                    <div className="space-y-1">
                                        {sortedCutSets.map(({ cutSet, probability }, index) => {
                                            return (
                                                <div key={index} className="flex items-start gap-1">
                                                    <span className="text-gray-600 font-semibold whitespace-nowrap">
                                                        #{index + 1}
                                                    </span>
                                                    {probability !== null && (
                                                        <span 
                                                            className="px-1 py-0.5 rounded font-medium bg-purple-100 text-purple-700 whitespace-nowrap"
                                                            title={`Cut set probability: ${formatProbability(probability)}`}
                                                        >
                                                            {formatProbability(probability)}
                                                        </span>
                                                    )}
                                                    <div className="flex flex-wrap gap-1 items-center">
                                                        {cutSet.map((event, eventIndex) => (
                                                            <React.Fragment key={eventIndex}>
                                                                <span
                                                                    className={`px-1 py-0.5 rounded font-medium cursor-pointer transition-all ${getEventColorClasses(event)}`}
                                                                    title={getEventTooltip(event.name)}
                                                                    onClick={() => handleEventClick(event.name)}
                                                                >
                                                                    {event.complement && '/'}
                                                                    {event.name}
                                                                </span>
                                                                {eventIndex < cutSet.length - 1 && (
                                                                    <span className="text-gray-400">*</span>
                                                                )}
                                                            </React.Fragment>
                                                        ))}
                                                    </div>
                                                </div>
                                            );
                                        })}
                                    </div>
                                )}
                            </div>

                            {/* Resize Handle */}
                            <div
                                onMouseDown={handleResizeStart}
                                className="absolute bottom-0 right-0 w-4 h-4 cursor-se-resize"
                                style={{
                                    background: 'linear-gradient(135deg, transparent 50%, #9ca3af 50%)'
                                }}
                            />
                        </>
                    )}
                </div>
            );
        }

        // Report Modal Component
        function ReportModal({ savedProjects, currentProject, cutSets, onClose, settings, selectedTreeIndex, setSelectedTreeIndex }) {
            // Load saved report preferences from localStorage
            const loadReportPreferences = () => {
                try {
                    const saved = localStorage.getItem('reportPreferences');
                    if (saved) {
                        return JSON.parse(saved);
                    }
                } catch (error) {
                    console.error('Error loading report preferences:', error);
                }
                return {
                    fileFormat: 'markdown',
                    contentType: 'graphics',
                    cutSetLimit: 100,
                    includeHeader: true,
                    includeProject: true,
                    includeDate: true,
                    selectedTreeIndices: []
                };
            };

            const prefs = loadReportPreferences();

            const [fileFormat, setFileFormat] = useState(prefs.fileFormat);
            const [fileName, setFileName] = useState('fault_tree_report');
            const [contentType, setContentType] = useState(prefs.contentType);
            const [cutSetLimit, setCutSetLimit] = useState(prefs.cutSetLimit);
            const [selectedTrees, setSelectedTrees] = useState(() => {
                // Restore previous selection if available
                if (prefs.selectedTreeIndices && prefs.selectedTreeIndices.length > 0) {
                    return new Set(prefs.selectedTreeIndices);
                }
                return new Set(['all']);
            });
            const [includeHeader, setIncludeHeader] = useState(prefs.includeHeader);
            const [includeProject, setIncludeProject] = useState(prefs.includeProject);
            const [includeDate, setIncludeDate] = useState(prefs.includeDate);
            const [isGenerating, setIsGenerating] = useState(false);
            const [progressMessage, setProgressMessage] = useState('');
            const [progressPercent, setProgressPercent] = useState(0);

            // Save report preferences to localStorage whenever they change
            useEffect(() => {
                const preferences = {
                    fileFormat,
                    contentType,
                    cutSetLimit,
                    includeHeader,
                    includeProject,
                    includeDate,
                    selectedTreeIndices: Array.from(selectedTrees)
                };
                localStorage.setItem('reportPreferences', JSON.stringify(preferences));
            }, [fileFormat, contentType, cutSetLimit, includeHeader, includeProject, includeDate, selectedTrees]);

            const availableTrees = currentProject?.faultTrees || [];

            const handleTreeToggle = (treeId) => {
                const newSelected = new Set(selectedTrees);
                if (treeId === 'all') {
                    if (selectedTrees.has('all')) {
                        newSelected.clear();
                    } else {
                        newSelected.clear();
                        newSelected.add('all');
                    }
                } else {
                    newSelected.delete('all');
                    if (selectedTrees.has(treeId)) {
                        newSelected.delete(treeId);
                    } else {
                        newSelected.add(treeId);
                    }
                }
                setSelectedTrees(newSelected);
            };

            // Capture fault tree image from the actual displayed canvas
            const captureFaultTreeImage = async (treeIndex, isFirstTree = false) => {
                console.log(`\n--- Capturing image for tree ${treeIndex} ---`);
                return new Promise((resolve) => {
                    try {
                        // Save current tree index
                        const currentIndex = selectedTreeIndex;
                        console.log(`Current tree index: ${currentIndex}, switching to: ${treeIndex}`);
                        
                        // Switch to the tree we want to capture
                        setSelectedTreeIndex(treeIndex);
                        
                        // First tree needs more time to render (1.5 seconds), others need 500ms
                        const timeout = isFirstTree ? 1500 : 500;
                        console.log(`Waiting ${timeout}ms for render...`);
                        
                        // Retry mechanism for canvas readiness
                        const attemptCapture = (attemptNumber = 1, maxAttempts = 3) => {
                            setTimeout(() => {
                                try {
                                    // Find the canvas element in the DOM
                                    const canvasElements = document.querySelectorAll('canvas');
                                    console.log(`Attempt ${attemptNumber}: Found ${canvasElements.length} canvas elements`);
                                    
                                    if (canvasElements.length === 0) {
                                        if (attemptNumber < maxAttempts) {
                                            console.log(`No canvas found, retrying in 500ms...`);
                                            attemptCapture(attemptNumber + 1, maxAttempts);
                                            return;
                                        }
                                        console.log(' No canvas found after all attempts');
                                        setSelectedTreeIndex(currentIndex);
                                        resolve(null);
                                        return;
                                    }
                                    
                                    // Use the first canvas (the fault tree canvas)
                                    const displayedCanvas = canvasElements[0];
                                    console.log(`Canvas dimensions: ${displayedCanvas.width}x${displayedCanvas.height}`);
                                    
                                    // Check if canvas is ready (has content)
                                    if (displayedCanvas.width === 0 || displayedCanvas.height === 0) {
                                        if (attemptNumber < maxAttempts) {
                                            console.log(`Canvas not ready, retrying in 500ms...`);
                                            attemptCapture(attemptNumber + 1, maxAttempts);
                                            return;
                                        }
                                        console.log(' Canvas not ready after all attempts');
                                        setSelectedTreeIndex(currentIndex);
                                        resolve(null);
                                        return;
                                    }
                                    
                                    // Get canvas image data to find non-white bounds
                                    // Set willReadFrequently for performance
                                    const ctx = displayedCanvas.getContext('2d', { willReadFrequently: true });
                                    const imageData = ctx.getImageData(0, 0, displayedCanvas.width, displayedCanvas.height);
                                    const data = imageData.data;
                                    
                                    let minX = displayedCanvas.width;
                                    let minY = displayedCanvas.height;
                                    let maxX = 0;
                                    let maxY = 0;
                                    let hasContent = false;
                                    
                                    // More aggressive whitespace detection - check every 4th pixel for speed
                                    // and use a stricter threshold for "white"
                                    for (let y = 0; y < displayedCanvas.height; y += 2) {
                                        for (let x = 0; x < displayedCanvas.width; x += 2) {
                                            const idx = (y * displayedCanvas.width + x) * 4;
                                            const r = data[idx];
                                            const g = data[idx + 1];
                                            const b = data[idx + 2];
                                            const a = data[idx + 3];
                                            
                                            // More strict: pixel is not white if any channel is < 245 and has opacity
                                            if (a > 0 && (r < 245 || g < 245 || b < 245)) {
                                                minX = Math.min(minX, x);
                                                minY = Math.min(minY, y);
                                                maxX = Math.max(maxX, x);
                                                maxY = Math.max(maxY, y);
                                                hasContent = true;
                                            }
                                        }
                                    }
                                    
                                    if (!hasContent) {
                                        if (attemptNumber < maxAttempts) {
                                            console.log(`No content found in canvas, retrying in 500ms...`);
                                            attemptCapture(attemptNumber + 1, maxAttempts);
                                            return;
                                        }
                                        console.log(' No content found in canvas after all attempts');
                                        setSelectedTreeIndex(currentIndex);
                                        resolve(null);
                                        return;
                                    }
                                    
                                    // Add padding around the content
                                    const padding = 30;
                                    minX = Math.max(0, minX - padding);
                                    minY = Math.max(0, minY - padding);
                                    maxX = Math.min(displayedCanvas.width, maxX + padding);
                                    maxY = Math.min(displayedCanvas.height, maxY + padding);
                                    
                                    const trimmedWidth = maxX - minX;
                                    const trimmedHeight = maxY - minY;
                                    
                                    console.log(`Original: ${displayedCanvas.width}x${displayedCanvas.height}`);
                                    console.log(`Trimmed bounds: ${minX},${minY} to ${maxX},${maxY}`);
                                    console.log(`Trimmed size: ${trimmedWidth}x${trimmedHeight}`);
                                    console.log(`Reduction: ${Math.round((1 - (trimmedWidth * trimmedHeight) / (displayedCanvas.width * displayedCanvas.height)) * 100)}%`);
                                    
                                    // Create a higher resolution copy with trimmed bounds
                                    const scale = 2; // 2x resolution for better quality
                                    const canvas = document.createElement('canvas');
                                    canvas.width = trimmedWidth * scale;
                                    canvas.height = trimmedHeight * scale;
                                    const newCtx = canvas.getContext('2d');
                                    
                                    // Fill with white background
                                    newCtx.fillStyle = '#ffffff';
                                    newCtx.fillRect(0, 0, canvas.width, canvas.height);
                                    
                                    // Scale up and draw the trimmed portion
                                    newCtx.scale(scale, scale);
                                    newCtx.drawImage(displayedCanvas, minX, minY, trimmedWidth, trimmedHeight, 0, 0, trimmedWidth, trimmedHeight);
                                    
                                    // Convert to base64
                                    const finalImageData = canvas.toDataURL('image/png');
                                    console.log(` Image captured and trimmed (attempt ${attemptNumber}), base64 length: ${finalImageData.length}`);
                                    
                                    // Restore original tree index
                                    setSelectedTreeIndex(currentIndex);
                                    console.log(`Restored tree index to: ${currentIndex}`);
                                    
                                    resolve(finalImageData);
                                } catch (error) {
                                    console.error(' Error in capture attempt:', error);
                                    if (attemptNumber < maxAttempts) {
                                        console.log(`Error occurred, retrying in 500ms...`);
                                        attemptCapture(attemptNumber + 1, maxAttempts);
                                    } else {
                                        setSelectedTreeIndex(currentIndex);
                                        resolve(null);
                                    }
                                }
                            }, attemptNumber === 1 ? timeout : 500); // First attempt uses initial timeout, retries use 500ms
                        };
                        
                        // Start the capture attempts
                        attemptCapture();
                        
                    } catch (error) {
                        console.error(' Error in captureFaultTreeImage:', error);
                        resolve(null);
                    }
                });
            };

            const handleGenerate = async () => {
                console.log('\n=== Report Generation Started ===');
                try {
                    setIsGenerating(true);
                    setProgressPercent(0);
                    setProgressMessage('Preparing report...');
                    
                    // Determine which trees to include
                    const treesToInclude = selectedTrees.has('all')
                        ? availableTrees.map((_, idx) => idx)
                        : Array.from(selectedTrees).filter(id => id !== 'all');

                    console.log('Trees to include:', treesToInclude);

                    if (treesToInclude.length === 0) {
                        alert('Please select at least one fault tree to generate a report.');
                        setIsGenerating(false);
                        return;
                    }

                    const includeGraphics = contentType === 'graphics' || contentType === 'both';
                    const includeCutSetsData = contentType === 'cutsets' || contentType === 'both';
                    
                    console.log('Include graphics:', includeGraphics);
                    console.log('Include cut sets:', includeCutSetsData);

                    // Capture tree images if graphics are needed
                    const treeImages = {};
                    if (includeGraphics) {
                        console.log('\n--- Starting image capture ---');
                        
                        // Warm-up: render the first tree to initialize the canvas system
                        if (treesToInclude.length > 0) {
                            console.log('Warming up canvas with first tree...');
                            setSelectedTreeIndex(treesToInclude[0]);
                            await new Promise(resolve => setTimeout(resolve, 800)); // Wait for initial render
                            console.log('Canvas warm-up complete');
                        }
                        
                        for (let i = 0; i < treesToInclude.length; i++) {
                            const idx = treesToInclude[i];
                            const percent = Math.round(((i + 1) / treesToInclude.length) * 50);
                            setProgressPercent(percent);
                            setProgressMessage(`Capturing tree ${i + 1} of ${treesToInclude.length}...`);
                            
                            console.log(`Capturing tree ${idx}...`);
                            const imageData = await captureFaultTreeImage(idx, i === 0); // First tree gets longer timeout
                            if (imageData) {
                                treeImages[idx] = imageData;
                                console.log(` Tree ${idx} image added to collection`);
                            } else {
                                console.log(` Tree ${idx} image capture failed`);
                            }
                        }
                        console.log('Image capture complete. Images collected:', Object.keys(treeImages));
                    }

                    setProgressPercent(60);
                    setProgressMessage('Generating report document...');

                    // Prepare header options
                    const headerOptions = {
                        includeHeader,
                        includeProject,
                        includeDate
                    };

                    // Generate report content based on format
                    if (fileFormat === 'markdown') {
                        console.log('Generating Markdown report...');
                        const content = generateMarkdownReport(treesToInclude, treeImages, includeCutSetsData, headerOptions);
                        downloadReport(content, fileName, 'markdown');
                    } else if (fileFormat === 'word') {
                        console.log('Generating Word report...');
                        await generateWordReport(treesToInclude, treeImages, includeCutSetsData, headerOptions);
                    }

                    setProgressPercent(100);
                    setProgressMessage('Complete!');
                    
                    setTimeout(() => {
                        setIsGenerating(false);
                        onClose();
                    }, 500);
                    
                    console.log('=== Report Generation Complete ===\n');
                } catch (error) {
                    console.error('!!! Error in handleGenerate:', error);
                    setIsGenerating(false);
                    alert(`Error generating report: ${error.message}`);
                }
            };

            const generateMarkdownReport = (treeIndices, treeImages, includeCutSetsData, headerOptions = {}) => {
                let md = '';

                // Title (optional)
                if (headerOptions.includeHeader !== false) {
                    md += `# Fault Tree Analysis Report\n\n`;
                }

                // Project info (optional)
                if (headerOptions.includeProject !== false) {
                    md += `**Project:** ${currentProject?.projectName || 'Unnamed Project'}\n`;
                }
                if (headerOptions.includeDate !== false) {
                    md += `**Generated:** ${new Date().toLocaleString()}\n`;
                }

                // Add separator if any header elements were included
                if (headerOptions.includeHeader !== false || headerOptions.includeProject !== false || headerOptions.includeDate !== false) {
                    md += `\n---\n\n`;
                }

                treeIndices.forEach(idx => {
                    const tree = availableTrees[idx];
                    if (!tree) return;

                    md += `## ${tree.treeName || `Fault Tree ${idx + 1}`}\n\n`;

                    if (treeImages[idx]) {
                        md += `### Fault Tree Diagram\n\n`;
                        md += `![${tree.treeName}](${treeImages[idx]})\n\n`;
                    }

                    if (includeCutSetsData && cutSets) {
                        const treeKey = `${currentProject.projectName}_${tree.treeName}_${tree.modelPhase || ''}`.trim();
                        const cutSetData = cutSets[treeKey];

                        if (cutSetData && cutSetData.cutSets) {
                            md += `### Cut Sets\n\n`;
                            const limit = Math.min(cutSetData.cutSets.length, cutSetLimit);
                            md += `Showing ${limit} of ${cutSetData.cutSets.length} cut sets\n\n`;

                            cutSetData.cutSets.slice(0, limit).forEach((cutSet, i) => {
                                md += `${i + 1}. `;
                                md += cutSet.map(event => {
                                    const isComplemented = event.startsWith('/');
                                    const eventName = isComplemented ? event.substring(1) : event;
                                    return isComplemented ? `NOT(${eventName})` : eventName;
                                }).join(' AND ');
                                md += `\n`;
                            });
                            md += `\n`;
                        }
                    }

                    md += `---\n\n`;
                });

                return md;
            };

            const generateWordReport = async (treeIndices, treeImages, includeCutSetsData, headerOptions = {}) => {
                console.log('=== Word Report Generation Started ===');
                console.log('Tree indices:', treeIndices);
                console.log('Tree images:', treeImages);
                console.log('Include cut sets:', includeCutSetsData);
                
                try {
                    // Get eventInfo and settings from currentProject
                    const eventInfo = currentProject?.eventInfo || {};
                    const probDigits = parseInt(settings?.showProbability || '3');
                    
                    console.log('Event info count:', Object.keys(eventInfo).length);
                    console.log('Probability digits:', probDigits);

                    // Build HTML content
                    let htmlContent = `<html xmlns:o='urn:schemas-microsoft-com:office:office' xmlns:w='urn:schemas-microsoft-com:office:word' xmlns='http://www.w3.org/TR/REC-html40'>
<head>
<meta charset='utf-8'>
<title>Fault Tree Analysis Report</title>
<style>
body {
    font-family: Calibri, Arial, sans-serif;
    font-size: 11pt;
    line-height: 1.5;
}
h1 {
    font-size: 20pt;
    font-weight: bold;
    margin: 12pt 0;
}
h2 {
    font-size: 16pt;
    font-weight: bold;
    margin: 10pt 0;
    page-break-before: always;
}
h2:first-of-type {
    page-break-before: auto;
}
h3 {
    font-size: 14pt;
    font-weight: bold;
    margin: 8pt 0;
}
table {
    border-collapse: collapse;
    width: 100%;
    margin: 1pt 0;
    font-size: 10pt;
}
th, td {
    border: 1px solid black;
    padding: 2pt 4pt;
    text-align: left;
    vertical-align: top;
}
th {
    background-color: #f0f0f0;
    font-weight: bold;
}
.event-name {
    font-weight: bold;
}
img {
    display: block;
    margin: 10pt auto;
    width: 6.5in;
    border: 1px solid #ccc;
}
p {
    margin: 6pt 0;
}
</style>
</head>
<body>
`;

                    // Title (optional)
                    if (headerOptions.includeHeader !== false) {
                        htmlContent += `<h1 style="text-align: center;">Fault Tree Analysis Report</h1>\n`;
                    }

                    // Project info (optional)
                    if (headerOptions.includeProject !== false) {
                        htmlContent += `<p><strong>Project:</strong> ${currentProject?.projectName || 'Unnamed Project'}</p>\n`;
                    }
                    if (headerOptions.includeDate !== false) {
                        htmlContent += `<p><strong>Generated:</strong> ${new Date().toLocaleString()}</p>\n`;
                    }

                    // Add trees
                    for (let i = 0; i < treeIndices.length; i++) {
                        const idx = treeIndices[i];
                        const tree = availableTrees[idx];
                        if (!tree) {
                            console.log(`Tree ${idx} not found`);
                            continue;
                        }

                        console.log(`\n--- Processing tree ${idx}: ${tree.treeName} ---`);

                        // Tree name
                        htmlContent += `<h2>${tree.treeName || `Fault Tree ${idx + 1}`}</h2>\n`;

                        // Add image if available
                        const imageData = treeImages[idx];
                        console.log(`Tree ${idx} - Image exists:`, !!imageData);
                        console.log(`Tree ${idx} - Image length:`, imageData?.length || 0);
                        console.log(`Tree ${idx} - Image starts with:`, imageData?.substring(0, 50) || 'none');
                        
                        if (imageData && imageData.length > 0) {
                            htmlContent += `<h3>Fault Tree Diagram</h3>\n`;
                            htmlContent += `<p><img src="${imageData}" alt="Fault Tree Diagram" width="630" /></p>\n`;
                            console.log(` Image HTML added for tree ${idx}`);
                        } else {
                            console.log(` No image data for tree ${idx}`);
                        }

                        // Add cut sets if requested
                        if (includeCutSetsData && cutSets) {
                            // Try to find cut sets by tree name directly
                            const treeName = tree.treeName;
                            console.log(`Looking for cut sets: "${treeName}"`);
                            console.log(`Available keys:`, Object.keys(cutSets));
                            
                            const cutSetData = cutSets[treeName];

                            if (cutSetData && cutSetData.cutSets) {
                                console.log(` Found ${cutSetData.cutSets.length} cut sets`);
                                
                                // Calculate probabilities for all cut sets
                                const cutSetsWithProb = cutSetData.cutSets.map((cutSet, idx) => {
                                    let probability = 1.0;
                                    let probValid = true;
                                    
                                    for (const event of cutSet) {
                                        const eventName = event.name || event;
                                        const cleanName = eventName.startsWith('/') ? eventName.substring(1) : eventName;
                                        const isComplemented = event.complement || eventName.startsWith('/');
                                        
                                        const info = eventInfo[cleanName];
                                        if (info && info.Calc_Prob !== undefined) {
                                            if (isComplemented) {
                                                probability *= (1.0 - info.Calc_Prob);
                                            } else {
                                                probability *= info.Calc_Prob;
                                            }
                                        } else {
                                            probValid = false;
                                            break;
                                        }
                                    }
                                    
                                    return {
                                        cutSet,
                                        probability: probValid ? probability : null,
                                        originalIndex: idx
                                    };
                                });
                                
                                // Sort by probability (highest first)
                                cutSetsWithProb.sort((a, b) => {
                                    if (a.probability === null && b.probability === null) return 0;
                                    if (a.probability === null) return 1;
                                    if (b.probability === null) return -1;
                                    return b.probability - a.probability;
                                });
                                
                                // Calculate MCUB (Minimal Cut-set Upper Bound)
                                let mcub = 0;
                                let mcubValid = true;
                                for (const item of cutSetsWithProb) {
                                    if (item.probability !== null) {
                                        mcub += item.probability;
                                    } else {
                                        mcubValid = false;
                                        break;
                                    }
                                }
                                
                                htmlContent += `<h3>Minimal Cut Sets</h3>\n`;
                                
                                // Add MCUB
                                if (mcubValid) {
                                    const mcubText = mcub.toExponential(probDigits);
                                    htmlContent += `<p><strong>MCUB (Minimal Cut-set Upper Bound):</strong> ${mcubText}</p>\n`;
                                }
                                
                                const limit = Math.min(cutSetsWithProb.length, cutSetLimit);
                                htmlContent += `<p>Showing ${limit} of ${cutSetsWithProb.length} cut sets (sorted by probability)</p>\n`;

                                // Create table
                                htmlContent += `<table>\n`;
                                htmlContent += `<tr><th style="width: 50px;">#</th><th>Events</th><th style="width: 120px;">Probability</th></tr>\n`;

                                cutSetsWithProb.slice(0, limit).forEach((item, cutSetIdx) => {
                                    const cutSet = item.cutSet;
                                    const probability = item.probability;
                                    
                                    // Build event list with descriptions - each on new line with bold event names
                                    const eventDescriptions = currentProject?.eventDescriptions || {};
                                    const eventLines = cutSet.map(event => {
                                        const eventName = event.name || event;
                                        const isComplemented = event.complement || eventName.startsWith('/');
                                        const cleanName = isComplemented && eventName.startsWith('/') ? eventName.substring(1) : eventName;
                                        
                                        const prefix = isComplemented ? `<span class="event-name">NOT(${cleanName})</span>` : `<span class="event-name">${cleanName}</span>`;
                                        const description = eventDescriptions[cleanName] || '';
                                        
                                        return description ? `${prefix} - ${description}` : prefix;
                                    }).join('<br/>');

                                    const probText = probability !== null ? probability.toExponential(probDigits) : 'N/A';

                                    htmlContent += `<tr><td>${cutSetIdx + 1}</td><td>${eventLines}</td><td>${probText}</td></tr>\n`;
                                });

                                htmlContent += `</table>\n`;
                                console.log(` Cut sets table added`);
                            } else {
                                console.log(` No cut sets found`);
                            }
                        }
                    }

                    htmlContent += `</body>\n</html>`;
                    
                    console.log('\n=== HTML Complete ===');
                    console.log('Total HTML length:', htmlContent.length);
                    
                    // Create blob with Word MIME type
                    const blob = new Blob([htmlContent], { 
                        type: 'application/msword' 
                    });
                    
                    console.log('Blob size:', blob.size);
                    
                    // Download
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${fileName}.doc`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    console.log(' Download complete\n');
                } catch (error) {
                    console.error('!!! Error:', error);
                    console.error('Stack:', error.stack);
                    alert(`Error generating Word report: ${error.message}`);
                }
            };

            const generatePDFReport = async (treeIndices, treeImages, includeCutSetsData, headerOptions = {}) => {
                console.log('PDF generation started');
                console.log('Tree indices:', treeIndices);
                console.log('Tree images keys:', Object.keys(treeImages));
                console.log('Include cut sets:', includeCutSetsData);
                console.log('Header options:', headerOptions);

                const { jsPDF } = window.jspdf;
                const doc = new jsPDF();
                let y = 20;

                // Title (optional)
                if (headerOptions.includeHeader !== false) {
                    doc.setFontSize(20);
                    doc.text("Fault Tree Analysis Report", 105, y, { align: 'center' });
                    y += 15;
                }

                // Project info (optional)
                doc.setFontSize(12);
                if (headerOptions.includeProject !== false) {
                    doc.text(`Project: ${currentProject?.projectName || 'Unnamed Project'}`, 20, y);
                    y += 7;
                }
                if (headerOptions.includeDate !== false) {
                    doc.text(`Generated: ${new Date().toLocaleString()}`, 20, y);
                    y += 7;
                }

                // Add some space after header if any header elements were included
                if (headerOptions.includeHeader !== false || headerOptions.includeProject !== false || headerOptions.includeDate !== false) {
                    y += 8;
                }

                // Add trees
                for (const idx of treeIndices) {
                    const tree = availableTrees[idx];
                    if (!tree) {
                        console.log(`Tree at index ${idx} not found`);
                        continue;
                    }

                    // Check if need new page
                    if (y > 250) {
                        doc.addPage();
                        y = 20;
                    }

                    // Tree name
                    doc.setFontSize(16);
                    doc.text(tree.treeName || `Fault Tree ${idx + 1}`, 20, y);
                    y += 10;

                    // Add image if available
                    console.log(`Checking image for tree ${idx}, exists: ${!!treeImages[idx]}`);
                    if (treeImages[idx]) {
                        try {
                            console.log(`Adding image to PDF for tree ${idx}`);
                            doc.addImage(treeImages[idx], 'PNG', 20, y, 170, 113);
                            y += 120;
                            console.log(`Image added successfully for tree ${idx}`);
                        } catch (err) {
                            console.error('Error adding image to PDF:', err);
                        }
                    } else {
                        console.log(`No image data for tree ${idx}`);
                    }

                    // Add cut sets if requested
                    if (includeCutSetsData && cutSets) {
                        const treeKey = `${currentProject.projectName}_${tree.treeName}_${tree.modelPhase || ''}`.trim();
                        console.log(`Looking for cut sets with key: "${treeKey}"`);
                        console.log('Available cut set keys:', Object.keys(cutSets));
                        const cutSetData = cutSets[treeKey];

                        if (cutSetData && cutSetData.cutSets) {
                            console.log(`Found ${cutSetData.cutSets.length} cut sets for tree ${idx}`);
                            if (y > 250) {
                                doc.addPage();
                                y = 20;
                            }

                            doc.setFontSize(14);
                            doc.text("Cut Sets", 20, y);
                            y += 7;

                            doc.setFontSize(10);
                            const limit = Math.min(cutSetData.cutSets.length, cutSetLimit);
                            doc.text(`Showing ${limit} of ${cutSetData.cutSets.length} cut sets`, 20, y);
                            y += 10;

                            cutSetData.cutSets.slice(0, limit).forEach((cutSet, i) => {
                                if (y > 280) {
                                    doc.addPage();
                                    y = 20;
                                }

                                const cutSetText = cutSet.map(event => {
                                    const isComplemented = event.startsWith('/');
                                    const eventName = isComplemented ? event.substring(1) : event;
                                    return isComplemented ? `NOT(${eventName})` : eventName;
                                }).join(' AND ');

                                doc.text(`${i + 1}. ${cutSetText}`, 25, y);
                                y += 5;
                            });
                        } else {
                            console.log(`No cut set data found for tree ${idx}, key: "${treeKey}"`);
                        }
                    }

                    y += 10;
                }

                // Save PDF
                console.log('Saving PDF');
                doc.save(`${fileName}.pdf`);
            };

            const downloadReport = (content, filename, format) => {
                // Only handles markdown format (Word and PDF handle their own downloads)
                const blob = new Blob([content], { type: 'text/markdown' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${filename}.md`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            };

            const includeCutSets = contentType === 'cutsets' || contentType === 'both';

            return (
                <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50" onClick={onClose}>
                    <div className="bg-white rounded-lg shadow-xl max-w-4xl w-full m-4 max-h-[90vh] flex flex-col" onClick={(e) => e.stopPropagation()}>
                        {/* Header */}
                        <div className="p-4 border-b border-gray-200">
                            <div className="flex items-center justify-between">
                                <h2 className="text-lg font-bold text-gray-800">Generate Report</h2>
                                <button onClick={onClose} className="text-gray-500 hover:text-gray-700">
                                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                                        <line x1="18" y1="6" x2="6" y2="18"></line>
                                        <line x1="6" y1="6" x2="18" y2="18"></line>
                                    </svg>
                                </button>
                            </div>
                        </div>

                        {/* Two-column layout */}
                        <div className="flex-1 flex overflow-hidden">
                            {/* Left column - Fault Trees */}
                            <div className="w-1/3 border-r border-gray-200 p-4 overflow-y-auto">
                                <h3 className="text-sm font-semibold text-gray-700 mb-2">Fault Trees</h3>
                                <div className="space-y-0.5">
                                    {/* All Trees Option */}
                                    <label className="flex items-center gap-2 py-1 px-2 hover:bg-gray-50 rounded cursor-pointer">
                                        <input
                                            type="checkbox"
                                            checked={selectedTrees.has('all')}
                                            onChange={() => handleTreeToggle('all')}
                                            className="w-4 h-4"
                                        />
                                        <span className="text-sm font-medium">All Trees</span>
                                    </label>

                                    {/* Individual Trees */}
                                    {availableTrees.map((tree, idx) => (
                                        <label key={idx} className="flex items-center gap-2 py-1 px-2 hover:bg-gray-50 rounded cursor-pointer">
                                            <input
                                                type="checkbox"
                                                checked={selectedTrees.has(idx) || selectedTrees.has('all')}
                                                onChange={() => handleTreeToggle(idx)}
                                                disabled={selectedTrees.has('all')}
                                                className="w-4 h-4"
                                            />
                                            <span className="text-sm">{tree.treeName || `Tree ${idx + 1}`}</span>
                                        </label>
                                    ))}
                                </div>
                            </div>

                            {/* Right column - Options */}
                            <div className="w-2/3 p-4 overflow-y-auto">
                                <div className="space-y-4">
                                    {/* File Format */}
                                    <div>
                                        <label className="block text-xs font-medium text-gray-700 mb-1">File Format</label>
                                        <div className="flex gap-2">
                                            {[
                                                { value: 'word', label: 'Word' },
                                                { value: 'markdown', label: 'Markdown' }
                                            ].map(format => (
                                                <button
                                                    key={format.value}
                                                    onClick={() => setFileFormat(format.value)}
                                                    className={`flex-1 px-4 py-2 rounded text-sm ${
                                                        fileFormat === format.value
                                                            ? 'bg-blue-600 text-white'
                                                            : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
                                                    }`}
                                                >
                                                    {format.label}
                                                </button>
                                            ))}
                                        </div>
                                    </div>

                                    {/* File Name */}
                                    <div>
                                        <label className="block text-xs font-medium text-gray-700 mb-1">File Name</label>
                                        <input
                                            type="text"
                                            value={fileName}
                                            onChange={(e) => setFileName(e.target.value)}
                                            className="w-full px-3 py-2 border border-gray-300 rounded text-sm focus:outline-none focus:ring-2 focus:ring-blue-500"
                                            placeholder="Enter file name"
                                        />
                                    </div>

                                    {/* Content Type */}
                                    <div>
                                        <label className="block text-xs font-medium text-gray-700 mb-1">Content Type</label>
                                        <div className="flex gap-2">
                                            {[
                                                { value: 'graphics', label: 'Fault Tree Graphics' },
                                                { value: 'cutsets', label: 'Fault Tree Cut Sets' },
                                                { value: 'both', label: 'Graphics + Cut Sets' }
                                            ].map(type => (
                                                <button
                                                    key={type.value}
                                                    onClick={() => setContentType(type.value)}
                                                    className={`flex-1 px-3 py-2 rounded text-xs ${
                                                        contentType === type.value
                                                            ? 'bg-blue-600 text-white'
                                                            : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
                                                    }`}
                                                >
                                                    {type.label}
                                                </button>
                                            ))}
                                        </div>
                                        <p className="text-xs text-gray-600 mt-1 italic">
                                            Note: Fault tree will be shown using the {
                                                settings?.defaultViewStyle === '150' ? '150%' :
                                                settings?.defaultViewStyle === '100' ? '100%' :
                                                'Fit to Window'
                                            } setting
                                        </p>
                                    </div>

                                    {/* Limit Cut Sets */}
                                    {includeCutSets && (
                                        <div>
                                            <label className="block text-xs font-medium text-gray-700 mb-1">Limit Cut Sets to</label>
                                            <input
                                                type="number"
                                                value={cutSetLimit}
                                                onChange={(e) => setCutSetLimit(parseInt(e.target.value) || 100)}
                                                min="1"
                                                className="w-full px-3 py-2 border border-gray-300 rounded text-sm focus:outline-none focus:ring-2 focus:ring-blue-500"
                                            />
                                        </div>
                                    )}

                                    {/* Report Header Options */}
                                    <div>
                                        <label className="block text-xs font-medium text-gray-700 mb-2">Report Header Options</label>
                                        <div className="space-y-2">
                                            <label className="flex items-center gap-2 cursor-pointer">
                                                <input
                                                    type="checkbox"
                                                    checked={includeHeader}
                                                    onChange={(e) => setIncludeHeader(e.target.checked)}
                                                    className="w-4 h-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500"
                                                />
                                                <span className="text-sm text-gray-700">Include "Fault Tree Analysis Report" header</span>
                                            </label>
                                            <label className="flex items-center gap-2 cursor-pointer">
                                                <input
                                                    type="checkbox"
                                                    checked={includeProject}
                                                    onChange={(e) => setIncludeProject(e.target.checked)}
                                                    className="w-4 h-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500"
                                                />
                                                <span className="text-sm text-gray-700">Include project name</span>
                                            </label>
                                            <label className="flex items-center gap-2 cursor-pointer">
                                                <input
                                                    type="checkbox"
                                                    checked={includeDate}
                                                    onChange={(e) => setIncludeDate(e.target.checked)}
                                                    className="w-4 h-4 text-blue-600 border-gray-300 rounded focus:ring-blue-500"
                                                />
                                                <span className="text-sm text-gray-700">Include date generated</span>
                                            </label>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        {/* Footer - Progress Bar and Action Buttons */}
                        <div className="border-t border-gray-200">
                            {/* Progress Bar */}
                            {isGenerating && (
                                <div className="p-4 bg-gray-50">
                                    <div className="mb-2 text-sm text-gray-700">{progressMessage}</div>
                                    <div className="w-full bg-gray-200 rounded-full h-4">
                                        <div 
                                            className="bg-blue-600 h-4 rounded-full transition-all duration-300"
                                            style={{ width: `${progressPercent}%` }}
                                        ></div>
                                    </div>
                                </div>
                            )}
                            
                            {/* Action Buttons */}
                            <div className="p-4">
                                <div className="flex justify-end gap-2">
                                    <button
                                        onClick={onClose}
                                        disabled={isGenerating}
                                        className={`px-4 py-2 text-sm rounded ${
                                            isGenerating 
                                                ? 'bg-gray-100 text-gray-400 cursor-not-allowed' 
                                                : 'bg-gray-200 text-gray-700 hover:bg-gray-300'
                                        }`}
                                    >
                                        Cancel
                                    </button>
                                    <button
                                        onClick={handleGenerate}
                                        disabled={isGenerating}
                                        className={`px-4 py-2 text-sm rounded ${
                                            isGenerating 
                                                ? 'bg-blue-300 text-white cursor-not-allowed' 
                                                : 'bg-blue-600 text-white hover:bg-blue-700'
                                        }`}
                                    >
                                        {isGenerating ? 'Generating...' : 'Generate Report'}
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        function SettingsModal({ settings, onSave, onClose }) {
            const [localSettings, setLocalSettings] = useState({ ...settings });

            const handleChange = (key, value) => {
                setLocalSettings(prev => ({ ...prev, [key]: value }));
            };

            const handleSave = () => {
                SettingsManager.save(localSettings);
                onSave(localSettings);
                onClose();
            };

            const handleReset = () => {
                const defaults = SettingsManager.reset();
                setLocalSettings(defaults);
                SettingsManager.save(defaults);
                onSave(defaults);
            };

            return (
                <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50" onClick={onClose}>
                    <div className="bg-white rounded-lg shadow-xl max-w-2xl w-full m-4 max-h-[90vh] overflow-y-auto" onClick={(e) => e.stopPropagation()}>
                        <div className="p-4">
                            <div className="flex items-center justify-between mb-4">
                                <h2 className="text-lg font-bold text-gray-800">Settings</h2>
                                <button onClick={onClose} className="text-gray-500 hover:text-gray-700">
                                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                                        <line x1="18" y1="6" x2="6" y2="18"></line>
                                        <line x1="6" y1="6" x2="18" y2="18"></line>
                                    </svg>
                                </button>
                            </div>

                            <div className="space-y-4">
                                {/* Font Size */}
                                <div>
                                    <label className="block text-xs font-medium text-gray-700 mb-1">Text Font Size</label>
                                    <div className="flex gap-2">
                                        {['small', 'medium', 'large'].map(size => (
                                            <button
                                                key={size}
                                                onClick={() => handleChange('fontSize', size)}
                                                className={`flex-1 px-4 py-2 rounded ${
                                                    localSettings.fontSize === size
                                                        ? 'bg-blue-600 text-white'
                                                        : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
                                                }`}
                                            >
                                                {size.charAt(0).toUpperCase() + size.slice(1)}
                                            </button>
                                        ))}
                                    </div>
                                </div>

                                {/* Node Size */}
                                <div>
                                    <label className="block text-xs font-medium text-gray-700 mb-1">Node Size</label>
                                    <div className="flex gap-2">
                                        {['small', 'medium', 'large'].map(size => (
                                            <button
                                                key={size}
                                                onClick={() => handleChange('nodeSize', size)}
                                                className={`flex-1 px-4 py-2 rounded ${
                                                    localSettings.nodeSize === size
                                                        ? 'bg-blue-600 text-white'
                                                        : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
                                                }`}
                                            >
                                                {size.charAt(0).toUpperCase() + size.slice(1)}
                                            </button>
                                        ))}
                                    </div>
                                </div>

                                {/* Color Mode */}
                                <div>
                                    <label className="block text-xs font-medium text-gray-700 mb-1">Node Colors</label>
                                    <div className="flex gap-2">
                                        {[
                                            { value: 'color', label: 'Color' },
                                            { value: 'grayscale', label: 'Grayscale' },
                                            { value: 'single-color', label: 'Single Color' }
                                        ].map(mode => (
                                            <button
                                                key={mode.value}
                                                onClick={() => handleChange('colorMode', mode.value)}
                                                className={`flex-1 px-4 py-2 rounded ${
                                                    localSettings.colorMode === mode.value
                                                        ? 'bg-blue-600 text-white'
                                                        : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
                                                }`}
                                            >
                                                {mode.label}
                                            </button>
                                        ))}
                                    </div>
                                    
                                    {/* Color Picker for Single Color Mode */}
                                    {localSettings.colorMode === 'single-color' && (
                                        <div className="mt-3">
                                            <label className="block text-xs font-medium text-gray-700 mb-1">
                                                Select Base Color
                                            </label>
                                            <div className="flex items-center gap-3">
                                                <input
                                                    type="color"
                                                    value={localSettings.singleColor || '#3b82f6'}
                                                    onChange={(e) => handleChange('singleColor', e.target.value)}
                                                    className="w-16 h-10 rounded cursor-pointer border border-gray-300"
                                                />
                                                <span className="text-sm text-gray-600">
                                                    {localSettings.singleColor || '#3b82f6'}
                                                </span>
                                                <button
                                                    onClick={() => handleChange('singleColor', '#3b82f6')}
                                                    className="px-3 py-1 text-xs bg-gray-100 text-gray-700 rounded hover:bg-gray-200"
                                                >
                                                    Reset
                                                </button>
                                            </div>
                                        </div>
                                    )}
                                </div>

                                {/* Font Family */}
                                <div>
                                    <label className="block text-xs font-medium text-gray-700 mb-1">Font Family</label>
                                    <div className="flex gap-2">
                                        {[
                                            { value: 'sans-serif', label: 'Sans-serif' },
                                            { value: 'serif', label: 'Serif' },
                                            { value: 'monospace', label: 'Monospaced' }
                                        ].map(font => (
                                            <button
                                                key={font.value}
                                                onClick={() => handleChange('fontFamily', font.value)}
                                                className={`flex-1 px-4 py-2 rounded ${
                                                    localSettings.fontFamily === font.value
                                                        ? 'bg-blue-600 text-white'
                                                        : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
                                                }`}
                                            >
                                                {font.label}
                                            </button>
                                        ))}
                                    </div>
                                </div>

                                {/* Connection Lines */}
                                <div>
                                    <label className="block text-xs font-medium text-gray-700 mb-1">Connection Lines</label>
                                    <div className="flex gap-2">
                                        {[
                                            { value: 'arrows', label: 'Lines with Arrows' },
                                            { value: 'no-arrows', label: 'Lines with No Arrows' },
                                            { value: 'dotted', label: 'Dotted Lines' }
                                        ].map(option => (
                                            <button
                                                key={option.value}
                                                onClick={() => handleChange('arrows', option.value)}
                                                className={`flex-1 px-4 py-2 rounded ${
                                                    localSettings.arrows === option.value
                                                        ? 'bg-blue-600 text-white'
                                                        : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
                                                }`}
                                            >
                                                {option.label}
                                            </button>
                                        ))}
                                    </div>
                                </div>

                                {/* Background */}
                                <div>
                                    <label className="block text-xs font-medium text-gray-700 mb-1">Background</label>
                                    <div className="grid grid-cols-2 gap-2">
                                        {[
                                            { value: 'light', label: 'Light (White)' },
                                            { value: 'dark', label: 'Dark (Black)' },
                                            { value: 'grid', label: 'Grid (Blue)' },
                                            { value: 'engineering', label: 'Engineering (Green)' }
                                        ].map(bg => (
                                            <button
                                                key={bg.value}
                                                onClick={() => handleChange('background', bg.value)}
                                                className={`px-4 py-2 rounded ${
                                                    localSettings.background === bg.value
                                                        ? 'bg-blue-600 text-white'
                                                        : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
                                                }`}
                                            >
                                                {bg.label}
                                            </button>
                                        ))}
                                    </div>
                                </div>

                                {/* Show Probability */}
                                <div>
                                    <label className="block text-xs font-medium text-gray-700 mb-1">Show Probability</label>
                                    <div className="grid grid-cols-2 gap-2">
                                        {[
                                            { value: 'hide', label: 'Do Not Show' },
                                            { value: '0', label: '0 Digits (1.E-5)' },
                                            { value: '1', label: '1 Digit (1.2E-5)' },
                                            { value: '2', label: '2 Digits (1.23E-5)' }
                                        ].map(option => (
                                            <button
                                                key={option.value}
                                                onClick={() => handleChange('showProbability', option.value)}
                                                className={`px-4 py-2 rounded text-sm ${
                                                    localSettings.showProbability === option.value
                                                        ? 'bg-blue-600 text-white'
                                                        : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
                                                }`}
                                            >
                                                {option.label}
                                            </button>
                                        ))}
                                    </div>
                                </div>

                                {/* Line Style */}
                                <div>
                                    <label className="block text-xs font-medium text-gray-700 mb-1">Line Style</label>
                                    <div className="flex gap-2">
                                        {[
                                            { value: 'curved', label: 'Curved Lines' },
                                            { value: 'straight', label: 'Straight Lines' }
                                        ].map(style => (
                                            <button
                                                key={style.value}
                                                onClick={() => handleChange('lineStyle', style.value)}
                                                className={`flex-1 px-4 py-2 rounded ${
                                                    localSettings.lineStyle === style.value
                                                        ? 'bg-blue-600 text-white'
                                                        : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
                                                }`}
                                            >
                                                {style.label}
                                            </button>
                                        ))}
                                    </div>
                                </div>

                                {/* Default Tree View Style */}
                                <div>
                                    <label className="block text-xs font-medium text-gray-700 mb-1">Default Tree View Style</label>
                                    <div className="flex gap-2">
                                        {[
                                            { value: 'fit', label: 'Fit to Window' },
                                            { value: '100', label: '100%' },
                                            { value: '150', label: '150%' }
                                        ].map(style => (
                                            <button
                                                key={style.value}
                                                onClick={() => handleChange('defaultViewStyle', style.value)}
                                                className={`flex-1 px-4 py-2 rounded ${
                                                    localSettings.defaultViewStyle === style.value
                                                        ? 'bg-blue-600 text-white'
                                                        : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
                                                }`}
                                            >
                                                {style.label}
                                            </button>
                                        ))}
                                    </div>
                                </div>

                                {/* Box Type */}
                                <div>
                                    <label className="block text-xs font-medium text-gray-700 mb-1">Box Type</label>
                                    <div className="flex gap-2">
                                        {[
                                            { value: 'box-only', label: 'Just the Box' },
                                            { value: 'circle', label: 'Circle Below Box' },
                                            { value: 'gate-symbol', label: 'Fault Tree Symbol' }
                                        ].map(type => (
                                            <button
                                                key={type.value}
                                                onClick={() => handleChange('boxType', type.value)}
                                                className={`flex-1 px-4 py-2 rounded ${
                                                    localSettings.boxType === type.value
                                                        ? 'bg-blue-600 text-white'
                                                        : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
                                                }`}
                                            >
                                                {type.label}
                                            </button>
                                        ))}
                                    </div>
                                </div>

                                {/* Tree Spacing */}
                                <div>
                                    <label className="block text-xs font-medium text-gray-700 mb-1">Tree Spacing</label>
                                    <div className="flex gap-2">
                                        {[
                                            { value: 'small', label: 'Small' },
                                            { value: 'medium', label: 'Medium' },
                                            { value: 'large', label: 'Large' }
                                        ].map(spacing => (
                                            <button
                                                key={spacing.value}
                                                onClick={() => handleChange('treeSpacing', spacing.value)}
                                                className={`flex-1 px-4 py-2 rounded ${
                                                    localSettings.treeSpacing === spacing.value
                                                        ? 'bg-blue-600 text-white'
                                                        : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
                                                }`}
                                            >
                                                {spacing.label}
                                            </button>
                                        ))}
                                    </div>
                                </div>
                            </div>

                            {/* Action Buttons */}
                            <div className="flex justify-between mt-4">
                                <button
                                    onClick={handleReset}
                                    className="px-3 py-1 text-sm bg-gray-200 text-gray-700 rounded hover:bg-gray-300"
                                >
                                    Reset to Defaults
                                </button>
                                <div className="flex gap-2">
                                    <button
                                        onClick={onClose}
                                        className="px-3 py-1 text-sm bg-gray-200 text-gray-700 rounded hover:bg-gray-300"
                                    >
                                        Cancel
                                    </button>
                                    <button
                                        onClick={handleSave}
                                        className="px-4 py-1 text-sm bg-blue-600 text-white rounded hover:bg-blue-700"
                                    >
                                        Save
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        }

        // Main Application Component
        function FaultTreeVisualizer() {
            const [db, setDb] = useState(null);
            const [savedProjects, setSavedProjects] = useState([]);
            const [currentProject, setCurrentProject] = useState(null);
            const [selectedTreeIndex, setSelectedTreeIndex] = useState(0);
            const [view, setView] = useState('upload');
            const [error, setError] = useState('');
            const [eventDescriptions, setEventDescriptions] = useState({});
            const [gateDescriptions, setGateDescriptions] = useState({});
            const [eventInfo, setEventInfo] = useState({});
            const [cutSets, setCutSets] = useState({});
            const [autoLoadBED, setAutoLoadBED] = useState(true);
            const [autoLoadGTD, setAutoLoadGTD] = useState(true);
            const [autoLoadBEI, setAutoLoadBEI] = useState(true);
            const [autoLoadFTC, setAutoLoadFTC] = useState(true);
            const [settings, setSettings] = useState(() => SettingsManager.load());
            const [showSettings, setShowSettings] = useState(false);
            const [showReport, setShowReport] = useState(false);
            const [workingDirectory, setWorkingDirectory] = useState('');
            
            // Cut sets floating window state
            const [cutSetsPosition, setCutSetsPosition] = useState({ x: 300, y: 80 });
            const [cutSetsSize, setCutSetsSize] = useState({ width: 450, height: 600 });
            const [cutSetsMinimized, setCutSetsMinimized] = useState(false);
            const [cutSetsClosed, setCutSetsClosed] = useState(false);
            const [isDraggingCutSets, setIsDraggingCutSets] = useState(false);
            const [isResizingCutSets, setIsResizingCutSets] = useState(false);
            const [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });

            useEffect(() => {
                const initDB = async () => {
                    try {
                        const database = new TreeDB();
                        await database.init();
                        setDb(database);
                        loadSavedProjects(database);
                    } catch (err) {
                        console.error('Database initialization failed:', err);
                        setError('Failed to initialize database. Some features may not work.');
                    }
                };
                initDB();
            }, []);

            async function loadSavedProjects(database) {
                try {
                    const projects = await database.getAllTrees();
                    setSavedProjects(projects);
                } catch (err) {
                    console.error('Failed to load projects:', err);
                }
            }

            async function handleFileUpload(e) {
                const files = e.target.files;
                if (!files || files.length === 0) return;

                setError('');
                
                // Collect all relevant file names that were opened
                const openedFiles = [];
                for (let i = 0; i < files.length; i++) {
                    const file = files[i];
                    const fileName = file.name.toLowerCase();
                    // Include FTL, BED, GTD, BEI, and FTC files
                    if (fileName.endsWith('.ftl') || 
                        fileName.endsWith('.bed') || 
                        fileName.endsWith('.gtd') || 
                        fileName.endsWith('.bei') || 
                        fileName.endsWith('.ftc') ||
                        (fileName.endsWith('.txt') && !fileName.endsWith('.bed') && !fileName.endsWith('.gtd') && !fileName.endsWith('.bei') && !fileName.endsWith('.ftc'))) {
                        openedFiles.push(file.name);
                    }
                }
                
                // Set the list of opened files
                setWorkingDirectory(openedFiles.join(', '));
                
                // Find the FTL, BED, GTD, BEI, and FTC files
                let ftlFile = null;
                let bedFile = null;
                let gtdFile = null;
                let beiFile = null;
                let ftcFile = null;
                
                for (let i = 0; i < files.length; i++) {
                    const file = files[i];
                    const fileName = file.name.toLowerCase();
                    if (fileName.endsWith('.ftl') || (fileName.endsWith('.txt') && !fileName.endsWith('.bed') && !fileName.endsWith('.gtd') && !fileName.endsWith('.bei') && !fileName.endsWith('.ftc'))) {
                        ftlFile = file;
                    } else if (fileName.endsWith('.bed')) {
                        bedFile = file;
                    } else if (fileName.endsWith('.gtd')) {
                        gtdFile = file;
                    } else if (fileName.endsWith('.bei')) {
                        beiFile = file;
                    } else if (fileName.endsWith('.ftc')) {
                        ftcFile = file;
                    }
                }
                
                if (!ftlFile) {
                    setError('No FTL file found in selection.');
                    return;
                }

                // If auto-load is checked and no BED/GTD/BEI/FTC files were explicitly selected, 
                // look for BED, GTD, BEI, and FTC files with the same base name
                if (files.length > 1) {
                    const baseName = ftlFile.name.replace(/\.(ftl|FTL|txt|TXT)$/, '');
                    
                    if (!bedFile && autoLoadBED) {
                        for (let i = 0; i < files.length; i++) {
                            const file = files[i];
                            const fileBaseName = file.name.replace(/\.(bed|BED|txt|TXT)$/, '');
                            if (file.name.toLowerCase().endsWith('.bed') && fileBaseName === baseName) {
                                bedFile = file;
                                break;
                            }
                        }
                    }
                    
                    if (!gtdFile && autoLoadGTD) {
                        for (let i = 0; i < files.length; i++) {
                            const file = files[i];
                            const fileBaseName = file.name.replace(/\.(gtd|GTD|txt|TXT)$/, '');
                            if (file.name.toLowerCase().endsWith('.gtd') && fileBaseName === baseName) {
                                gtdFile = file;
                                break;
                            }
                        }
                    }
                    
                    if (!beiFile && autoLoadBEI) {
                        for (let i = 0; i < files.length; i++) {
                            const file = files[i];
                            const fileBaseName = file.name.replace(/\.(bei|BEI|txt|TXT)$/, '');
                            if (file.name.toLowerCase().endsWith('.bei') && fileBaseName === baseName) {
                                beiFile = file;
                                break;
                            }
                        }
                    }
                    
                    if (!ftcFile && autoLoadFTC) {
                        for (let i = 0; i < files.length; i++) {
                            const file = files[i];
                            const fileBaseName = file.name.replace(/\.(ftc|FTC|txt|TXT)$/, '');
                            if (file.name.toLowerCase().endsWith('.ftc') && fileBaseName === baseName) {
                                ftcFile = file;
                                break;
                            }
                        }
                    }
                }

                // Read FTL file
                const ftlReader = new FileReader();
                ftlReader.onload = async (event) => {
                    try {
                        const text = event.target.result;
                        const parsed = parseFTLStructure(text);

                        if (!parsed || !parsed.faultTrees || parsed.faultTrees.length === 0) {
                            setError('Invalid FTL file format. Please check the file structure.');
                            return;
                        }

                        let bedDescriptions = {};
                        let gtdDescriptions = {};
                        let beiInfo = {};
                        let ftcData = {};
                        let filesProcessed = 0;
                        const filesToProcess = (bedFile && autoLoadBED ? 1 : 0) + (gtdFile && autoLoadGTD ? 1 : 0) + (beiFile && autoLoadBEI ? 1 : 0) + (ftcFile && autoLoadFTC ? 1 : 0);

                        // Function to create project after all files are loaded
                        const createProject = () => {
                            const projectData = {
                                ...parsed,
                                fileName: ftlFile.name,
                                eventDescriptions: bedDescriptions,
                                gateDescriptions: gtdDescriptions,
                                eventInfo: beiInfo,
                                cutSets: ftcData
                            };

                            setCurrentProject(projectData);
                            setSelectedTreeIndex(0);
                            setView('visualize');
                        };

                        // If we found a BED file, read it
                        if (bedFile && autoLoadBED) {
                            const bedReader = new FileReader();
                            bedReader.onload = async (bedEvent) => {
                                try {
                                    const bedText = bedEvent.target.result;
                                    bedDescriptions = parseEventDescriptions(bedText);
                                    setEventDescriptions(bedDescriptions);
                                    filesProcessed++;
                                    
                                    if (filesProcessed === filesToProcess) {
                                        createProject();
                                    }
                                } catch (err) {
                                    setError(`Error parsing BED file: ${err.message}`);
                                }
                            };
                            bedReader.readAsText(bedFile);
                        }

                        // If we found a GTD file, read it
                        if (gtdFile && autoLoadGTD) {
                            const gtdReader = new FileReader();
                            gtdReader.onload = async (gtdEvent) => {
                                try {
                                    const gtdText = gtdEvent.target.result;
                                    gtdDescriptions = parseGateDescriptions(gtdText);
                                    setGateDescriptions(gtdDescriptions);
                                    filesProcessed++;
                                    
                                    if (filesProcessed === filesToProcess) {
                                        createProject();
                                    }
                                } catch (err) {
                                    setError(`Error parsing GTD file: ${err.message}`);
                                }
                            };
                            gtdReader.readAsText(gtdFile);
                        }

                        // If we found a BEI file, read it
                        if (beiFile && autoLoadBEI) {
                            const beiReader = new FileReader();
                            beiReader.onload = async (beiEvent) => {
                                try {
                                    const beiText = beiEvent.target.result;
                                    beiInfo = parseBEI(beiText);
                                    setEventInfo(beiInfo);
                                    filesProcessed++;
                                    
                                    if (filesProcessed === filesToProcess) {
                                        createProject();
                                    }
                                } catch (err) {
                                    setError(`Error parsing BEI file: ${err.message}`);
                                }
                            };
                            beiReader.readAsText(beiFile);
                        }

                        // If we found an FTC file, read it
                        if (ftcFile && autoLoadFTC) {
                            const ftcReader = new FileReader();
                            ftcReader.onload = async (ftcEvent) => {
                                try {
                                    const ftcText = ftcEvent.target.result;
                                    ftcData = parseFTC(ftcText);
                                    setCutSets(ftcData);
                                    filesProcessed++;
                                    
                                    if (filesProcessed === filesToProcess) {
                                        createProject();
                                    }
                                } catch (err) {
                                    setError(`Error parsing FTC file: ${err.message}`);
                                }
                            };
                            ftcReader.readAsText(ftcFile);
                        }

                        // If no description files, just set project
                        if (!bedFile && !gtdFile && !beiFile && !ftcFile) {
                            bedDescriptions = { ...eventDescriptions };
                            gtdDescriptions = { ...gateDescriptions };
                            beiInfo = { ...eventInfo };
                            ftcData = { ...cutSets };
                            createProject();
                        }
                    } catch (err) {
                        setError(`Error parsing file: ${err.message}`);
                    }
                };

                ftlReader.readAsText(ftlFile);
            }

            async function handleDescriptionUpload(e) {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const text = event.target.result;
                        const descriptions = parseEventDescriptions(text);
                        setEventDescriptions(descriptions);
                    } catch (err) {
                        setError(`Error parsing description file: ${err.message}`);
                    }
                };

                reader.readAsText(file);
            }

            async function handleGateDescriptionUpload(e) {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const text = event.target.result;
                        const descriptions = parseGateDescriptions(text);
                        setGateDescriptions(descriptions);
                    } catch (err) {
                        setError(`Error parsing gate description file: ${err.message}`);
                    }
                };

                reader.readAsText(file);
            }

            async function handleBEIUpload(e) {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const text = event.target.result;
                        const info = parseBEI(text);
                        setEventInfo(info);
                    } catch (err) {
                        setError(`Error parsing BEI file: ${err.message}`);
                    }
                };

                reader.readAsText(file);
            }

            async function handleFTCUpload(e) {
                const file = e.target.files[0];
                if (!file) return;

                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const text = event.target.result;
                        const data = parseFTC(text);
                        setCutSets(data);
                    } catch (err) {
                        setError(`Error parsing FTC file: ${err.message}`);
                    }
                };

                reader.readAsText(file);
            }

            async function handleDeleteProject(id) {
                if (!confirm('Are you sure you want to delete this project?')) return;

                try {
                    await db.deleteTree(id);
                    await loadSavedProjects(db);
                } catch (err) {
                    setError(`Error deleting project: ${err.message}`);
                }
            }

            function loadProject(project) {
                setCurrentProject(project);
                setEventDescriptions(project.eventDescriptions || {});
                setGateDescriptions(project.gateDescriptions || {});
                setEventInfo(project.eventInfo || {});
                setCutSets(project.cutSets || {});
                setSelectedTreeIndex(0);
                setView('visualize');
            }

            // Handle dragging the cut sets window
            React.useEffect(() => {
                if (!isDraggingCutSets) return;

                const handleMouseMove = (e) => {
                    setCutSetsPosition({
                        x: e.clientX - dragOffset.x,
                        y: e.clientY - dragOffset.y
                    });
                };

                const handleMouseUp = () => {
                    setIsDraggingCutSets(false);
                };

                document.addEventListener('mousemove', handleMouseMove);
                document.addEventListener('mouseup', handleMouseUp);

                return () => {
                    document.removeEventListener('mousemove', handleMouseMove);
                    document.removeEventListener('mouseup', handleMouseUp);
                };
            }, [isDraggingCutSets, dragOffset]);

            const handleCutSetsDragStart = (e) => {
                setIsDraggingCutSets(true);
                setDragOffset({
                    x: e.clientX - cutSetsPosition.x,
                    y: e.clientY - cutSetsPosition.y
                });
            };

            // Reopen cut sets window when switching trees (if cut sets exist for new tree)
            React.useEffect(() => {
                if (view === 'visualize' && currentProject && currentProject.faultTrees[selectedTreeIndex]) {
                    const treeName = currentProject.faultTrees[selectedTreeIndex].treeName;
                    const cutSetData = currentProject.cutSets && currentProject.cutSets[treeName];
                    
                    if (cutSetData && cutSetData.cutSets) {
                        setCutSetsClosed(false); // Reopen when switching to tree with cut sets
                    }
                }
            }, [selectedTreeIndex, view, currentProject]);

            return (
                <div className="h-screen flex flex-col bg-gray-50">
                    {/* Header with buttons */}
                    <header className="bg-blue-600 text-white p-3 shadow-lg">
                        <div className="container mx-auto flex items-center justify-between">
                            <div className="flex items-center gap-4">
                                <h1 className="text-xl font-bold">KUREAS-FTL v1.0</h1>
                                <span className="text-sm opacity-90">Fault Tree Logic Visualizer</span>
                            </div>
                            <div className="flex gap-2">
                                <button
                                    onClick={() => {
                                        setView('upload');
                                        setCurrentProject(null);
                                        setSelectedTreeIndex(0);
                                    }}
                                    className="px-3 py-1 rounded flex items-center gap-2 bg-blue-500 hover:bg-blue-700 text-white text-sm"
                                    title="Open New FTL"
                                >
                                    <UploadIcon />
                                    <span>Open New FTL</span>
                                </button>
                                {view === 'visualize' && (
                                    <>
                                        <button
                                            onClick={() => setShowReport(true)}
                                            className="px-3 py-1 rounded flex items-center gap-2 bg-blue-500 hover:bg-blue-700 text-white text-sm"
                                            title="Generate Report"
                                        >
                                            <ReportIcon />
                                            <span>Report</span>
                                        </button>
                                        <button
                                            onClick={() => setShowSettings(true)}
                                            className="px-3 py-1 rounded flex items-center gap-2 bg-blue-500 hover:bg-blue-700 text-white text-sm"
                                            title="Settings"
                                        >
                                            <SettingsIcon />
                                            <span>Settings</span>
                                        </button>
                                    </>
                                )}
                            </div>
                        </div>
                    </header>

                    {/* Main Content - No nav bar */}

                    {/* Error Display */}
                    {error && (
                        <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 mx-4 mt-4 rounded">
                            {error}
                        </div>
                    )}

                    {/* Main Content */}
                    <main className="flex-1 overflow-hidden">
                        {view === 'upload' && (
                            <div className="container mx-auto p-8 max-w-4xl">
                                <div className="bg-white rounded-lg shadow-lg p-8">
                                    <h2 className="text-2xl font-bold mb-6">Open Fault Tree and Related File(s)</h2>
                                    
                                    <div className="space-y-6">
                                        <div>
                                            <label className="block text-xs font-medium text-gray-700 mb-1">
                                                FTL File (Required)
                                            </label>
                                            <input
                                                type="file"
                                                accept=".ftl,.txt,.bed,.gtd,.bei,.ftc"
                                                multiple
                                                onChange={handleFileUpload}
                                                className="block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100"
                                            />
                                            <p className="mt-1 text-xs text-gray-500">
                                                You can select multiple files (FTL, BED, GTD, BEI, and FTC) at once using Ctrl+Click or Cmd+Click. Files with matching base names will be loaded automatically.
                                            </p>
                                        </div>
                                    </div>

                                </div>
                            </div>
                        )}

                        {view === 'database' && (
                            <div className="container mx-auto p-8">
                                <h2 className="text-2xl font-bold mb-6">Saved Projects</h2>
                                {savedProjects.length === 0 ? (
                                    <div className="bg-white rounded-lg shadow p-8 text-center text-gray-500">
                                        No saved projects. Upload a file to get started.
                                    </div>
                                ) : (
                                    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                                        {savedProjects.map(project => (
                                            <div key={project.id} className="bg-white rounded-lg shadow-lg p-6 hover:shadow-xl transition-shadow">
                                                <div className="flex justify-between items-start mb-4">
                                                    <h3 className="text-lg font-bold text-gray-800">{project.projectName}</h3>
                                                    <button
                                                        onClick={() => handleDeleteProject(project.id)}
                                                        className="text-red-600 hover:text-red-800"
                                                        title="Delete Project"
                                                    >
                                                        <TrashIcon />
                                                    </button>
                                                </div>
                                                <p className="text-sm text-gray-600 mb-2">File: {project.fileName}</p>
                                                <p className="text-sm text-gray-600 mb-2">
                                                    Trees: {project.faultTrees.length}
                                                </p>
                                                {project.eventDescriptions && Object.keys(project.eventDescriptions).length > 0 && (
                                                    <p className="text-sm text-green-600 mb-2">
                                                         {Object.keys(project.eventDescriptions).length} descriptions
                                                    </p>
                                                )}
                                                <p className="text-xs text-gray-500 mb-4">
                                                    {new Date(project.timestamp).toLocaleString()}
                                                </p>
                                                <button
                                                    onClick={() => loadProject(project)}
                                                    className="w-full bg-blue-600 text-white py-2 px-4 rounded hover:bg-blue-700"
                                                >
                                                    Open Project
                                                </button>
                                            </div>
                                        ))}
                                    </div>
                                )}
                            </div>
                        )}

                        {view === 'visualize' && currentProject && (
                            <div className="h-full flex">
                                {/* Sidebar */}
                                <div className="w-64 bg-white border-r border-gray-200 p-4 overflow-y-auto">
                                    <h3 className="font-bold text-lg mb-2">{currentProject.projectName}</h3>
                                    <p className="text-sm text-gray-600 mb-1">
                                        {currentProject.faultTrees.length} fault tree(s)
                                    </p>
                                    {currentProject.eventDescriptions && Object.keys(currentProject.eventDescriptions).length > 0 && (
                                        <p className="text-sm text-green-600 mb-1">
                                            {Object.keys(currentProject.eventDescriptions).length} event descriptions
                                        </p>
                                    )}
                                    {currentProject.gateDescriptions && Object.keys(currentProject.gateDescriptions).length > 0 && (
                                        <p className="text-sm text-green-600 mb-4">
                                            {Object.keys(currentProject.gateDescriptions).length} gate descriptions
                                        </p>
                                    )}
                                    <div className="space-y-2 mt-4">
                                        {currentProject.faultTrees.map((tree, index) => {
                                            // Get font size based on settings
                                            const fontSizeClass = (() => {
                                                switch(settings.fontSize) {
                                                    case 'small': return 'text-xs';
                                                    case 'large': return 'text-base';
                                                    default: return 'text-sm'; // medium
                                                }
                                            })();
                                            
                                            return (
                                                <button
                                                    key={index}
                                                    onClick={() => setSelectedTreeIndex(index)}
                                                    className={`w-full text-left px-3 py-2 rounded ${fontSizeClass} ${
                                                        selectedTreeIndex === index
                                                            ? 'bg-blue-600 text-white'
                                                            : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
                                                    }`}
                                                >
                                                    {tree.treeName}
                                                </button>
                                            );
                                        })}
                                    </div>
                                </div>

                                {/* Canvas Area */}
                                <div className="flex-1">
                                    <TreeCanvas
                                        tree={currentProject.faultTrees[selectedTreeIndex]}
                                        eventDescriptions={currentProject.eventDescriptions || {}}
                                        gateDescriptions={currentProject.gateDescriptions || {}}
                                        eventInfo={currentProject.eventInfo || {}}
                                        project={currentProject}
                                        settings={settings}
                                    />
                                </div>
                            </div>
                        )}
                    </main>

                    {/* Report Modal */}
                    {showReport && (
                        <ReportModal
                            savedProjects={savedProjects}
                            currentProject={currentProject}
                            cutSets={cutSets}
                            settings={settings}
                            selectedTreeIndex={selectedTreeIndex}
                            setSelectedTreeIndex={setSelectedTreeIndex}
                            onClose={() => setShowReport(false)}
                        />
                    )}

                    {/* Settings Modal */}
                    {showSettings && (
                        <SettingsModal
                            settings={settings}
                            onSave={(newSettings) => setSettings(newSettings)}
                            onClose={() => setShowSettings(false)}
                        />
                    )}

                    {/* Cut Sets Floating Window - Auto-show when in visualize view with cut sets */}
                    {view === 'visualize' && currentProject && currentProject.faultTrees[selectedTreeIndex] && !cutSetsClosed && (() => {
                        const treeName = currentProject.faultTrees[selectedTreeIndex].treeName;
                        const cutSetData = currentProject.cutSets && currentProject.cutSets[treeName];
                        return cutSetData;
                    })() && (
                        <CutSetsFloatingWindow
                            cutSetsData={currentProject.cutSets[currentProject.faultTrees[selectedTreeIndex].treeName]}
                            position={cutSetsPosition}
                            size={cutSetsSize}
                            minimized={cutSetsMinimized}
                            onPositionChange={setCutSetsPosition}
                            onSizeChange={setCutSetsSize}
                            onMinimize={() => setCutSetsMinimized(!cutSetsMinimized)}
                            onClose={() => setCutSetsClosed(true)}
                            onMouseDown={handleCutSetsDragStart}
                            eventInfo={eventInfo}
                            eventDescriptions={eventDescriptions}
                            treeName={currentProject.faultTrees[selectedTreeIndex].treeName}
                            settings={settings}
                        />
                    )}

                    {/* Footer with opened files */}
                    <footer className="bg-gray-800 text-white text-xs py-1.5 px-4 flex items-center">
                        {workingDirectory && (
                            <span className="text-gray-300">
                                Files: <span className="text-white font-mono">{workingDirectory}</span>
                            </span>
                        )}
                    </footer>
                </div>
            );
        }

        // Initialize Application
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<FaultTreeVisualizer />);
    </script>
</body>
</html>
